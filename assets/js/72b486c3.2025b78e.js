"use strict";(self.webpackChunkfury_site=self.webpackChunkfury_site||[]).push([[2452],{21955:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>d,contentTitle:()=>l,default:()=>h,frontMatter:()=>r,metadata:()=>a,toc:()=>c});var t=i(85893),s=i(11151);const r={title:"Fury Xlang Serialization Format",sidebar_position:0,id:"fury_xlang_serialization_spec"},l=void 0,a={id:"specification/fury_xlang_serialization_spec",title:"Fury Xlang Serialization Format",description:"Cross-language Serialization Specification",source:"@site/docs/specification/xlang_serialization_spec.md",sourceDirName:"specification",slug:"/specification/fury_xlang_serialization_spec",permalink:"/docs/specification/fury_xlang_serialization_spec",draft:!1,unlisted:!1,editUrl:"https://github.com/apache/fury-site/tree/main/docs/specification/xlang_serialization_spec.md",tags:[],version:"current",sidebarPosition:0,frontMatter:{title:"Fury Xlang Serialization Format",sidebar_position:0,id:"fury_xlang_serialization_spec"},sidebar:"specificationSidebar",next:{title:"Fury Java Serialization Format",permalink:"/docs/specification/fury_java_serialization_spec"}},d={},c=[{value:"Cross-language Serialization Specification",id:"cross-language-serialization-specification",level:2},{value:"Type Systems",id:"type-systems",level:2},{value:"Data Types",id:"data-types",level:3},{value:"Polymorphisms",id:"polymorphisms",level:3},{value:"Type disambiguation",id:"type-disambiguation",level:3},{value:"Type ID",id:"type-id",level:3},{value:"Type mapping",id:"type-mapping",level:3},{value:"Spec overview",id:"spec-overview",level:2},{value:"Fury header",id:"fury-header",level:2},{value:"Reference Meta",id:"reference-meta",level:2},{value:"Type Meta",id:"type-meta",level:2},{value:"Schema consistent",id:"schema-consistent",level:3},{value:"Schema evolution",id:"schema-evolution",level:3},{value:"Type Def",id:"type-def",level:4},{value:"Meta header",id:"meta-header",level:5},{value:"Single layer type meta",id:"single-layer-type-meta",level:5},{value:"Other layers type meta",id:"other-layers-type-meta",level:5},{value:"Meta String",id:"meta-string",level:2},{value:"Encoding Algorithms",id:"encoding-algorithms",level:3},{value:"Value Format",id:"value-format",level:2},{value:"Basic types",id:"basic-types",level:3},{value:"bool",id:"bool",level:4},{value:"int8",id:"int8",level:4},{value:"int16",id:"int16",level:4},{value:"unsigned int32",id:"unsigned-int32",level:4},{value:"unsigned varint32",id:"unsigned-varint32",level:4},{value:"signed int32",id:"signed-int32",level:4},{value:"signed varint32",id:"signed-varint32",level:4},{value:"unsigned int64",id:"unsigned-int64",level:4},{value:"unsigned varint64",id:"unsigned-varint64",level:4},{value:"signed int64",id:"signed-int64",level:4},{value:"signed varint64",id:"signed-varint64",level:4},{value:"float32",id:"float32",level:4},{value:"float64",id:"float64",level:4},{value:"string",id:"string",level:3},{value:"list",id:"list",level:3},{value:"elements header",id:"elements-header",level:4},{value:"elements data",id:"elements-data",level:4},{value:"array",id:"array",level:3},{value:"primitive array",id:"primitive-array",level:4},{value:"object array",id:"object-array",level:4},{value:"map",id:"map",level:3},{value:"map key-value chunk data",id:"map-key-value-chunk-data",level:4},{value:"Why serialize chunk by chunk?",id:"why-serialize-chunk-by-chunk",level:4},{value:"enum",id:"enum",level:3},{value:"decimal",id:"decimal",level:3},{value:"struct",id:"struct",level:3},{value:"field order",id:"field-order",level:4},{value:"schema consistent",id:"schema-consistent-1",level:4},{value:"Schema evolution",id:"schema-evolution-1",level:4},{value:"Type",id:"type",level:3},{value:"Implementation guidelines",id:"implementation-guidelines",level:2},{value:"How to reduce memory read/write code",id:"how-to-reduce-memory-readwrite-code",level:3},{value:"Fast deserialization for static languages without runtime codegen support",id:"fast-deserialization-for-static-languages-without-runtime-codegen-support",level:3}];function o(e){const n={a:"a",blockquote:"blockquote",code:"code",h2:"h2",h3:"h3",h4:"h4",h5:"h5",li:"li",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,s.a)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.h2,{id:"cross-language-serialization-specification",children:"Cross-language Serialization Specification"}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"Format Version History:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Version 0.1 - serialization spec formalized"}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"Fury xlang serialization is an automatic object serialization framework that supports reference and polymorphism.\nFury will convert an object from/to fury xlang serialization binary format.\nFury has two core concepts for xlang serialization:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.strong,{children:"Fury xlang binary format"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.strong,{children:"Framework implemented in different languages to convert object to/from Fury xlang binary format"})}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"The serialization format is a dynamic binary format. The dynamics and reference/polymorphism support make Fury flexible,\nmuch more easy to use, but\nalso introduce more complexities compared to static serialization frameworks. So the format will be more complex."}),"\n",(0,t.jsx)(n.h2,{id:"type-systems",children:"Type Systems"}),"\n",(0,t.jsx)(n.h3,{id:"data-types",children:"Data Types"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"bool: a boolean value (true or false)."}),"\n",(0,t.jsx)(n.li,{children:"int8: a 8-bit signed integer."}),"\n",(0,t.jsx)(n.li,{children:"int16: a 16-bit signed integer."}),"\n",(0,t.jsx)(n.li,{children:"int32: a 32-bit signed integer."}),"\n",(0,t.jsx)(n.li,{children:"var_int32: a 32-bit signed integer which use fury var_int32 encoding."}),"\n",(0,t.jsx)(n.li,{children:"int64: a 64-bit signed integer."}),"\n",(0,t.jsx)(n.li,{children:"var_int64: a 64-bit signed integer which use fury PVL encoding."}),"\n",(0,t.jsx)(n.li,{children:"sli_int64: a 64-bit signed integer which use fury SLI encoding."}),"\n",(0,t.jsx)(n.li,{children:"float16: a 16-bit floating point number."}),"\n",(0,t.jsx)(n.li,{children:"float32: a 32-bit floating point number."}),"\n",(0,t.jsx)(n.li,{children:"float64: a 64-bit floating point number including NaN and Infinity."}),"\n",(0,t.jsx)(n.li,{children:"string: a text string encoded using Latin1/UTF16/UTF-8 encoding."}),"\n",(0,t.jsx)(n.li,{children:"enum: a data type consisting of a set of named values. Rust enum with non-predefined field values are not supported as\nan enum."}),"\n",(0,t.jsx)(n.li,{children:"named_enum: an enum whose value will be serialized as the registered name."}),"\n",(0,t.jsxs)(n.li,{children:["struct: a morphic(final) type serialized by Fury Struct serializer. i.e. it doesn't have subclasses. Suppose we're\ndeserializing ",(0,t.jsx)(n.code,{children:"List<SomeClass>"}),", we can save dynamic serializer dispatch since ",(0,t.jsx)(n.code,{children:"SomeClass"})," is morphic(final)."]}),"\n",(0,t.jsx)(n.li,{children:"compatible_struct: a morphic(final) type serialized by Fury compatible Struct serializer."}),"\n",(0,t.jsxs)(n.li,{children:["named_struct: a ",(0,t.jsx)(n.code,{children:"struct"})," whose type mapping will be encoded as a name."]}),"\n",(0,t.jsxs)(n.li,{children:["named_compatible_struct: a ",(0,t.jsx)(n.code,{children:"compatible_struct"})," whose type mapping will be encoded as a name."]}),"\n",(0,t.jsx)(n.li,{children:"ext: a type which will be serialized by a customized serializer."}),"\n",(0,t.jsxs)(n.li,{children:["named_ext: an ",(0,t.jsx)(n.code,{children:"ext"})," type whose type mapping will be encoded as a name."]}),"\n",(0,t.jsx)(n.li,{children:"list: a sequence of objects."}),"\n",(0,t.jsx)(n.li,{children:"set: an unordered set of unique elements."}),"\n",(0,t.jsxs)(n.li,{children:["map: a map of key-value pairs. Mutable types such as ",(0,t.jsx)(n.code,{children:"list/map/set/array/tensor/arrow"})," are not allowed as key of map."]}),"\n",(0,t.jsx)(n.li,{children:"duration: an absolute length of time, independent of any calendar/timezone, as a count of nanoseconds."}),"\n",(0,t.jsx)(n.li,{children:"timestamp: a point in time, independent of any calendar/timezone, as a count of nanoseconds. The count is relative\nto an epoch at UTC midnight on January 1, 1970."}),"\n",(0,t.jsx)(n.li,{children:"local_date: a naive date without timezone. The count is days relative to an epoch at UTC midnight on Jan 1, 1970."}),"\n",(0,t.jsx)(n.li,{children:"decimal: exact decimal value represented as an integer value in two's complement."}),"\n",(0,t.jsx)(n.li,{children:"binary: an variable-length array of bytes."}),"\n",(0,t.jsx)(n.li,{children:"array: only allow numeric components. Other arrays will be taken as List. The implementation should support the\ninteroperability between array and list."}),"\n",(0,t.jsx)(n.li,{children:"array: multidimensional array which every sub-array can have different sizes but all have same type."}),"\n",(0,t.jsx)(n.li,{children:"bool_array: one dimensional int16 array."}),"\n",(0,t.jsx)(n.li,{children:"int8_array: one dimensional int8 array."}),"\n",(0,t.jsx)(n.li,{children:"int16_array: one dimensional int16 array."}),"\n",(0,t.jsx)(n.li,{children:"int32_array: one dimensional int32 array."}),"\n",(0,t.jsx)(n.li,{children:"int64_array: one dimensional int64 array."}),"\n",(0,t.jsx)(n.li,{children:"float16_array: one dimensional half_float_16 array."}),"\n",(0,t.jsx)(n.li,{children:"float32_array: one dimensional float32 array."}),"\n",(0,t.jsx)(n.li,{children:"float64_array: one dimensional float64 array."}),"\n",(0,t.jsxs)(n.li,{children:["arrow record batch: an arrow ",(0,t.jsx)(n.a,{href:"https://arrow.apache.org/docs/cpp/tables.html#record-batches",children:"record batch"})," object."]}),"\n",(0,t.jsxs)(n.li,{children:["arrow table: an arrow ",(0,t.jsx)(n.a,{href:"https://arrow.apache.org/docs/cpp/tables.html#tables",children:"table"})," object."]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"Note:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Unsigned int/long are not added here, since not every language support those types."}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"polymorphisms",children:"Polymorphisms"}),"\n",(0,t.jsx)(n.p,{children:"For polymorphism, if one non-final class is registered, and only one subclass is registered, then we can take all\nelements in List/Map have same type, thus reduce runtime check cost."}),"\n",(0,t.jsx)(n.p,{children:"Collection/Array polymorphism are not fully supported, since some languages such as golang have only one collection\ntype. If users want to get exactly the type he passed, he must pass that type when deserializing or annotate that type\nto the field of struct."}),"\n",(0,t.jsx)(n.h3,{id:"type-disambiguation",children:"Type disambiguation"}),"\n",(0,t.jsx)(n.p,{children:"Due to differences between type systems of languages, those types can't be mapped one-to-one between languages. When\ndeserializing, Fury use the target data structure type and the data type in the data jointly to determine how to\ndeserialize and populate the target data structure. For example:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:"class Foo {\n  int[] intArray;\n  Object[] objects;\n  List<Object> objectList;\n}\n\nclass Foo2 {\n  int[] intArray;\n  List<Object> objects;\n  List<Object> objectList;\n}\n"})}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"intArray"})," has an ",(0,t.jsx)(n.code,{children:"int32_array"})," type. But both ",(0,t.jsx)(n.code,{children:"objects"})," and ",(0,t.jsx)(n.code,{children:"objectList"})," fields in the serialize data have ",(0,t.jsx)(n.code,{children:"list"})," data\ntype. When deserializing, the implementation will create an ",(0,t.jsx)(n.code,{children:"Object"})," array for ",(0,t.jsx)(n.code,{children:"objects"}),", but create a ",(0,t.jsx)(n.code,{children:"ArrayList"}),"\nfor ",(0,t.jsx)(n.code,{children:"objectList"})," to populate its elements. And the serialized data of ",(0,t.jsx)(n.code,{children:"Foo"})," can be deserialized into ",(0,t.jsx)(n.code,{children:"Foo2"})," too."]}),"\n",(0,t.jsx)(n.p,{children:"Users can also provide meta hints for fields of a type, or the type whole. Here is an example in java which use\nannotation to provide such information."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:"@FuryObject(fieldsNullable = false, trackingRef = false)\nclass Foo {\n  @FuryField(trackingRef = false)\n  int[] intArray;\n  @FuryField(polymorphic = true)\n  Object object;\n  @FuryField(tagId = 1, nullable = true)\n  List<Object> objectList;\n}\n"})}),"\n",(0,t.jsx)(n.p,{children:"Such information can be provided in other languages too:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"cpp: use macro and template."}),"\n",(0,t.jsx)(n.li,{children:"golang: use struct tag."}),"\n",(0,t.jsx)(n.li,{children:"python: use typehint."}),"\n",(0,t.jsx)(n.li,{children:"rust: use macro."}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"type-id",children:"Type ID"}),"\n",(0,t.jsxs)(n.p,{children:["All internal data types are expressed using an ID in range ",(0,t.jsx)(n.code,{children:"0~64"}),". Users can use ",(0,t.jsx)(n.code,{children:"0~4096"})," for representing their\ntypes."]}),"\n",(0,t.jsx)(n.h3,{id:"type-mapping",children:"Type mapping"}),"\n",(0,t.jsxs)(n.p,{children:["See ",(0,t.jsx)(n.a,{href:"/docs/guide/xlang_type_mapping",children:"Type mapping"})]}),"\n",(0,t.jsx)(n.h2,{id:"spec-overview",children:"Spec overview"}),"\n",(0,t.jsx)(n.p,{children:"Here is the overall format:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"| fury header | object ref meta | object type meta | object value data |\n"})}),"\n",(0,t.jsx)(n.p,{children:"The data are serialized using little endian byte order overall. If bytes swap is costly for some object,\nFury will write the byte order for that object into the data instead of converting it to little endian."}),"\n",(0,t.jsx)(n.h2,{id:"fury-header",children:"Fury header"}),"\n",(0,t.jsx)(n.p,{children:"Fury header consists starts one byte:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"|    2 bytes   |     4 bits    | 1 bit | 1 bit | 1 bit  | 1 bit |   1 byte   |          optional 4 bytes          |\n+--------------+---------------+-------+-------+--------+-------+------------+------------------------------------+\n| magic number | reserved bits |  oob  | xlang | endian | null  |  language  | unsigned int for meta start offset |\n"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["magic number: used to identify fury serialization protocol, current version use ",(0,t.jsx)(n.code,{children:"0x62d4"}),"."]}),"\n",(0,t.jsx)(n.li,{children:"null flag: 1 when object is null, 0 otherwise. If an object is null, other bits won't be set."}),"\n",(0,t.jsx)(n.li,{children:"endian flag: 1 when data is encoded by little endian, 0 for big endian."}),"\n",(0,t.jsx)(n.li,{children:"xlang flag: 1 when serialization uses xlang format, 0 when serialization uses Fury java format."}),"\n",(0,t.jsxs)(n.li,{children:["oob flag: 1 when passed ",(0,t.jsx)(n.code,{children:"BufferCallback"})," is not null, 0 otherwise."]}),"\n",(0,t.jsx)(n.li,{children:"language: the language when serializing objects, such as JAVA, PYTHON, GO, etc. Fury can use this flag to determine whether spend more time on serialization to make the deserialization faster for dynamic languages."}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"If meta share mode is enabled, an uncompressed unsigned int is appended to indicate the start offset of metadata."}),"\n",(0,t.jsx)(n.h2,{id:"reference-meta",children:"Reference Meta"}),"\n",(0,t.jsx)(n.p,{children:"Reference tracking handles whether the object is null, and whether to track reference for the object by writing\ncorresponding flags and maintaining internal state."}),"\n",(0,t.jsx)(n.p,{children:"Reference flags:"}),"\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"Flag"}),(0,t.jsx)(n.th,{children:"Byte Value"}),(0,t.jsx)(n.th,{children:"Description"})]})}),(0,t.jsxs)(n.tbody,{children:[(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"NULL FLAG"}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"-3"})}),(0,t.jsx)(n.td,{children:"This flag indicates the object is a null value. We don't use another byte to indicate REF, so that we can save one byte."})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"REF FLAG"}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"-2"})}),(0,t.jsx)(n.td,{children:"This flag indicates the object is already serialized previously, and fury will write a ref id with unsigned varint format instead of serialize it again"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"NOT_NULL VALUE FLAG"}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"-1"})}),(0,t.jsx)(n.td,{children:"This flag indicates the object is a non-null value and fury doesn't track ref for this type of object."})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"REF VALUE FLAG"}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"0"})}),(0,t.jsx)(n.td,{children:"This flag indicates the object is referencable and the first time to serialize."})]})]})]}),"\n",(0,t.jsxs)(n.p,{children:["When reference tracking is disabled globally or for specific types, or for certain types within a particular\ncontext(e.g., a field of a type), only the ",(0,t.jsx)(n.code,{children:"NULL"})," and ",(0,t.jsx)(n.code,{children:"NOT_NULL VALUE"})," flags will be used for reference meta."]}),"\n",(0,t.jsx)(n.p,{children:"For languages which doesn't support reference such as rust, reference tracking must be disabled for correct\ndeserialization by fury rust implementation."}),"\n",(0,t.jsx)(n.p,{children:"For languages whose object values are not null by default:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["In rust, Fury takes ",(0,t.jsx)(n.code,{children:"Option:None"})," as a null value"]}),"\n",(0,t.jsxs)(n.li,{children:["In c++, Fury takes ",(0,t.jsx)(n.code,{children:"std::nullopt"})," as a null value"]}),"\n",(0,t.jsxs)(n.li,{children:["In golang, Fury takes ",(0,t.jsx)(n.code,{children:"null interface/pointer"})," as a null value"]}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:["If one want to deserialize in languages like ",(0,t.jsx)(n.code,{children:"Java/Python/JavaScript"}),", he should mark the type with all fields\nnot-null by default, or using schema-evolution mode to carry the not-null fields info in the data."]}),"\n",(0,t.jsx)(n.h2,{id:"type-meta",children:"Type Meta"}),"\n",(0,t.jsxs)(n.p,{children:["For every type to be serialized, it must be registered with an optional ID first. The registered type will have a\nuser-provided or an auto-growing unsigned int i.e. ",(0,t.jsx)(n.code,{children:"type_id"}),". The registration can be used for security check and type\nidentification. The id of user registered type will be added by ",(0,t.jsx)(n.code,{children:"64"})," to make space for Fury internal data types."]}),"\n",(0,t.jsx)(n.p,{children:"Depending on whether meta share mode and registration is enabled for current type, Fury will write type meta\ndifferently."}),"\n",(0,t.jsx)(n.h3,{id:"schema-consistent",children:"Schema consistent"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["If schema consistent mode is enabled globally when creating fury, type meta will be written as a fury unsigned varint\nof ",(0,t.jsx)(n.code,{children:"type_id"}),". Schema evolution related meta will be ignored."]}),"\n",(0,t.jsxs)(n.li,{children:["If schema evolution mode is enabled globally when creating fury, and current class is configured to use schema\nconsistent mode like ",(0,t.jsx)(n.code,{children:"struct"})," vs ",(0,t.jsx)(n.code,{children:"table"})," in flatbuffers:","\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["Type meta will be add to ",(0,t.jsx)(n.code,{children:"captured_type_defs"}),": ",(0,t.jsx)(n.code,{children:"captured_type_defs[type def stub] = map size"})," ahead when\nregistering type."]}),"\n",(0,t.jsxs)(n.li,{children:["Get index of the meta in ",(0,t.jsx)(n.code,{children:"captured_type_defs"}),", write that index as ",(0,t.jsx)(n.code,{children:"| unsigned varint: index |"}),"."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"schema-evolution",children:"Schema evolution"}),"\n",(0,t.jsx)(n.p,{children:"If schema evolution mode is enabled globally when creating fury, and enabled for current type, type meta will be written\nusing one of the following mode. Which mode to use is configured when creating fury."}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:"Normal mode(meta share not enabled):"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["If type meta hasn't been written before, add ",(0,t.jsx)(n.code,{children:"type def"}),"\nto ",(0,t.jsx)(n.code,{children:"captured_type_defs"}),": ",(0,t.jsx)(n.code,{children:"captured_type_defs[type def] = map size"}),"."]}),"\n",(0,t.jsxs)(n.li,{children:["Get index of the meta in ",(0,t.jsx)(n.code,{children:"captured_type_defs"}),", write that index as ",(0,t.jsx)(n.code,{children:"| unsigned varint: index |"}),"."]}),"\n",(0,t.jsxs)(n.li,{children:["After finished the serialization of the object graph, fury will start to write ",(0,t.jsx)(n.code,{children:"captured_type_defs"}),":","\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:["Firstly, set current to ",(0,t.jsx)(n.code,{children:"meta start offset"})," of fury header"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:["Then write ",(0,t.jsx)(n.code,{children:"captured_type_defs"})," one by one:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:"buffer.write_var_uint32(len(writting_type_defs) - len(schema_consistent_type_def_stubs))\nfor type_meta in writting_type_defs:\n    if not type_meta.is_stub():\n        type_meta.write_type_def(buffer)\nwriting_type_defs = copy(schema_consistent_type_def_stubs)\n"})}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:["Meta share mode: the writing steps are same as the normal mode, but ",(0,t.jsx)(n.code,{children:"captured_type_defs"})," will be shared across\nmultiple serializations of different objects. For example, suppose we have a batch to serialize:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:"captured_type_defs = {}\nstream = ...\n# add `Type1` to `captured_type_defs` and write `Type1`\nfury.serialize(stream, [Type1()])\n# add `Type2` to `captured_type_defs` and write `Type2`, `Type1` is written before.\nfury.serialize(stream, [Type1(), Type2()])\n# `Type1` and `Type2` are written before, no need to write meta.\nfury.serialize(stream, [Type1(), Type2()])\n"})}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:"Streaming mode(streaming mode doesn't support meta share):"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:"If type meta hasn't been written before, the data will be written as:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"| unsigned varint: 0b11111111 | type def |\n"})}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:"If type meta has been written before, the data will be written as:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"| unsigned varint: written index << 1 |\n"})}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"written index"})," is the id in ",(0,t.jsx)(n.code,{children:"captured_type_defs"}),"."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:["With this mode, ",(0,t.jsx)(n.code,{children:"meta start offset"})," can be omitted."]}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"The normal mode and meta share mode will forbid streaming writing since it needs to look back for update the start\noffset after the whole object graph writing and meta collecting is finished. Only in this way we can ensure\ndeserialization failure in meta share mode doesn't lost shared meta."}),"\n"]}),"\n",(0,t.jsx)(n.h4,{id:"type-def",children:"Type Def"}),"\n",(0,t.jsx)(n.p,{children:"Here we mainly describe the meta layout for schema evolution mode:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"|      8 bytes meta header      |   variable bytes   |  variable bytes   | variable bytes |\n+-------------------------------+--------------------+-------------------+----------------+\n| 7 bytes hash + 1 bytes header |  current type meta |  parent type meta |      ...       |\n"})}),"\n",(0,t.jsx)(n.p,{children:"Type meta are encoded from parent type to leaf type, only type with serializable fields will be encoded."}),"\n",(0,t.jsx)(n.h5,{id:"meta-header",children:"Meta header"}),"\n",(0,t.jsx)(n.p,{children:"Meta header is a 64 bits number value encoded in little endian order."}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["Lowest 4 digits ",(0,t.jsx)(n.code,{children:"0b0000~0b1110"})," are used to record num classes. ",(0,t.jsx)(n.code,{children:"0b1111"})," is preserved to indicate that Fury need to\nread more bytes for length using Fury unsigned int encoding. If current type doesn't has parent type, or parent\ntype doesn't have fields to serialize, or we're in a context which serialize fields of current type\nonly, num classes will be 1."]}),"\n",(0,t.jsx)(n.li,{children:"The 5th bit is used to indicate whether this type needs schema evolution."}),"\n",(0,t.jsxs)(n.li,{children:["Other 56 bits are used to store the unique hash of ",(0,t.jsx)(n.code,{children:"flags + all layers type meta"}),"."]}),"\n"]}),"\n",(0,t.jsx)(n.h5,{id:"single-layer-type-meta",children:"Single layer type meta"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"| unsigned varint | var uint |  field info: variable bytes   | variable bytes  | ... |\n+-----------------+----------+-------------------------------+-----------------+-----+\n|   num_fields    | type id  | header + type id + field name | next field info | ... |\n"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["num fields: encode ",(0,t.jsx)(n.code,{children:"num fields"})," as unsigned varint.","\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["If the current type is schema consistent, then num_fields will be ",(0,t.jsx)(n.code,{children:"0"})," to flag it."]}),"\n",(0,t.jsx)(n.li,{children:"If the current type isn't schema consistent, then num_fields will be the number of compatible fields. For example,\nusers can use tag id to mark some fields as compatible fields in schema consistent context. In such cases, schema\nconsistent fields will be serialized first, then compatible fields will be serialized next. At deserialization,\nFury will use fields info of those fields which aren't annotated by tag id for deserializing schema consistent\nfields, then use fields info in meta for deserializing compatible fields."}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.li,{children:"type id: the registered id for the current type, which will be written as an unsigned varint."}),"\n",(0,t.jsxs)(n.li,{children:["field info:","\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["header(8\nbits): ",(0,t.jsx)(n.code,{children:"4 bits size + 2 bits field name encoding + nullability flag + ref tracking flag"}),".\nUsers can use annotation to provide those info.","\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["2 bits field name encoding:","\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["encoding: ",(0,t.jsx)(n.code,{children:"UTF8/ALL_TO_LOWER_SPECIAL/LOWER_UPPER_DIGIT_SPECIAL/TAG_ID"})]}),"\n",(0,t.jsxs)(n.li,{children:["If tag id is used, i.e. field name is written by an unsigned varint tag id. 2 bits encoding will be ",(0,t.jsx)(n.code,{children:"11"}),"."]}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["size of field name:","\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["The ",(0,t.jsx)(n.code,{children:"4 bits size: 0~14"}),"  will be used to indicate length ",(0,t.jsx)(n.code,{children:"1~15"}),", the value ",(0,t.jsx)(n.code,{children:"15"})," indicates to read more bytes,\nthe encoding will encode ",(0,t.jsx)(n.code,{children:"size - 15"})," as a varint next."]}),"\n",(0,t.jsxs)(n.li,{children:["If encoding is ",(0,t.jsx)(n.code,{children:"TAG_ID"}),", then num_bytes of field name will be used to store tag id."]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.li,{children:"ref tracking: when set to 1, ref tracking will be enabled for this field."}),"\n",(0,t.jsx)(n.li,{children:"nullability: when set to 1, this field can be null."}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["field name: If tag id is set, tag id will be used instead. Otherwise meta string encoding ",(0,t.jsx)(n.code,{children:"[length]"})," and data will\nbe written instead."]}),"\n",(0,t.jsxs)(n.li,{children:["type id:","\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["Format: ",(0,t.jsx)(n.code,{children:"id << 1 | polymorphic flag"}),". If field type is polymorphic, this flag is set to ",(0,t.jsx)(n.code,{children:"0b1"}),", otherwise it's\n",(0,t.jsx)(n.code,{children:"0b0"})]}),"\n",(0,t.jsx)(n.li,{children:"For registered type-consistent classes, it will be the registered type id."}),"\n",(0,t.jsxs)(n.li,{children:["For struct type it will be written as ",(0,t.jsx)(n.code,{children:"STRUCT"}),"."]}),"\n",(0,t.jsx)(n.li,{children:"The meta for struct type is written separately instead of inlining here is to reduce meta space cost if object of\nthis type is serialized in current object graph multiple times, and the field value may be null too."}),"\n",(0,t.jsxs)(n.li,{children:["For enum type, it will be written as ",(0,t.jsx)(n.code,{children:"ENUM"}),"."]}),"\n",(0,t.jsxs)(n.li,{children:["For collection type, it will be written as ",(0,t.jsx)(n.code,{children:"COLLECTION"}),", then write element type recursively."]}),"\n",(0,t.jsxs)(n.li,{children:["For map type, it will be written as ",(0,t.jsx)(n.code,{children:"MAP"}),", then write key and value type recursively."]}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"Field order are left as implementation details, which is not exposed to specification, the deserialization need to\nresort fields based on Fury field comparator. In this way, fury can compute statistics for field names or types and\nusing a more compact encoding."}),"\n",(0,t.jsx)(n.h5,{id:"other-layers-type-meta",children:"Other layers type meta"}),"\n",(0,t.jsx)(n.p,{children:"Same encoding algorithm as the previous layer."}),"\n",(0,t.jsx)(n.h2,{id:"meta-string",children:"Meta String"}),"\n",(0,t.jsx)(n.p,{children:"Meta string is mainly used to encode meta strings such as field names."}),"\n",(0,t.jsx)(n.h3,{id:"encoding-algorithms",children:"Encoding Algorithms"}),"\n",(0,t.jsx)(n.p,{children:"String binary encoding algorithm:"}),"\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"Algorithm"}),(0,t.jsx)(n.th,{children:"Pattern"}),(0,t.jsx)(n.th,{children:"Description"})]})}),(0,t.jsxs)(n.tbody,{children:[(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"LOWER_SPECIAL"}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"a-z._$|"})}),(0,t.jsxs)(n.td,{children:["every char is written using 5 bits, ",(0,t.jsx)(n.code,{children:"a-z"}),": ",(0,t.jsx)(n.code,{children:"0b00000~0b11001"}),", ",(0,t.jsx)(n.code,{children:"._$|"}),": ",(0,t.jsx)(n.code,{children:"0b11010~0b11101"}),", prepend one bit at the start to indicate whether strip last char since last byte may have 7 redundant bits(1 indicates strip last char)"]})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"LOWER_UPPER_DIGIT_SPECIAL"}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"a-zA-Z0~9._"})}),(0,t.jsxs)(n.td,{children:["every char is written using 6 bits, ",(0,t.jsx)(n.code,{children:"a-z"}),": ",(0,t.jsx)(n.code,{children:"0b00000~0b11001"}),", ",(0,t.jsx)(n.code,{children:"A-Z"}),": ",(0,t.jsx)(n.code,{children:"0b11010~0b110011"}),", ",(0,t.jsx)(n.code,{children:"0~9"}),": ",(0,t.jsx)(n.code,{children:"0b110100~0b111101"}),", ",(0,t.jsx)(n.code,{children:"._"}),": ",(0,t.jsx)(n.code,{children:"0b111110~0b111111"}),",  prepend one bit at the start to indicate whether strip last char since last byte may have 7 redundant bits(1 indicates strip last char)"]})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"UTF-8"}),(0,t.jsx)(n.td,{children:"any chars"}),(0,t.jsx)(n.td,{children:"UTF-8 encoding"})]})]})]}),"\n",(0,t.jsx)(n.p,{children:"Encoding flags:"}),"\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"Encoding Flag"}),(0,t.jsx)(n.th,{children:"Pattern"}),(0,t.jsx)(n.th,{children:"Encoding Algorithm"})]})}),(0,t.jsxs)(n.tbody,{children:[(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"LOWER_SPECIAL"}),(0,t.jsxs)(n.td,{children:["every char is in ",(0,t.jsx)(n.code,{children:"a-z._|"})]}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"LOWER_SPECIAL"})})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"FIRST_TO_LOWER_SPECIAL"}),(0,t.jsxs)(n.td,{children:["every char is in ",(0,t.jsx)(n.code,{children:"a-z._"})," except first char is upper case"]}),(0,t.jsxs)(n.td,{children:["replace first upper case char to lower case, then use ",(0,t.jsx)(n.code,{children:"LOWER_SPECIAL"})]})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"ALL_TO_LOWER_SPECIAL"}),(0,t.jsxs)(n.td,{children:["every char is in ",(0,t.jsx)(n.code,{children:"a-zA-Z._"})]}),(0,t.jsxs)(n.td,{children:["replace every upper case char by ",(0,t.jsx)(n.code,{children:"|"})," + ",(0,t.jsx)(n.code,{children:"lower case"}),", then use ",(0,t.jsx)(n.code,{children:"LOWER_SPECIAL"}),", use this encoding if it's smaller than Encoding ",(0,t.jsx)(n.code,{children:"LOWER_UPPER_DIGIT_SPECIAL"})]})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"LOWER_UPPER_DIGIT_SPECIAL"}),(0,t.jsxs)(n.td,{children:["every char is in ",(0,t.jsx)(n.code,{children:"a-zA-Z._"})]}),(0,t.jsxs)(n.td,{children:["use ",(0,t.jsx)(n.code,{children:"LOWER_UPPER_DIGIT_SPECIAL"})," encoding if it's smaller than Encoding ",(0,t.jsx)(n.code,{children:"FIRST_TO_LOWER_SPECIAL"})]})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"UTF8"}),(0,t.jsx)(n.td,{children:"any utf-8 char"}),(0,t.jsxs)(n.td,{children:["use ",(0,t.jsx)(n.code,{children:"UTF-8"})," encoding"]})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"Compression"}),(0,t.jsx)(n.td,{children:"any utf-8 char"}),(0,t.jsx)(n.td,{children:"lossless compression"})]})]})]}),"\n",(0,t.jsx)(n.p,{children:"Notes:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["Depending on cases, one can choose encoding ",(0,t.jsx)(n.code,{children:"flags + data"})," jointly, uses 3 bits of first byte for flags and other\nbytes\nfor data."]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"value-format",children:"Value Format"}),"\n",(0,t.jsx)(n.h3,{id:"basic-types",children:"Basic types"}),"\n",(0,t.jsx)(n.h4,{id:"bool",children:"bool"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"size: 1 byte"}),"\n",(0,t.jsxs)(n.li,{children:["format: 0 for ",(0,t.jsx)(n.code,{children:"false"}),", 1 for ",(0,t.jsx)(n.code,{children:"true"})]}),"\n"]}),"\n",(0,t.jsx)(n.h4,{id:"int8",children:"int8"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"size: 1 byte"}),"\n",(0,t.jsx)(n.li,{children:"format: write as pure byte."}),"\n"]}),"\n",(0,t.jsx)(n.h4,{id:"int16",children:"int16"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"size: 2 byte"}),"\n",(0,t.jsx)(n.li,{children:"byte order: raw bytes of little endian order"}),"\n"]}),"\n",(0,t.jsx)(n.h4,{id:"unsigned-int32",children:"unsigned int32"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"size: 4 byte"}),"\n",(0,t.jsx)(n.li,{children:"byte order: raw bytes of little endian order"}),"\n"]}),"\n",(0,t.jsx)(n.h4,{id:"unsigned-varint32",children:"unsigned varint32"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"size: 1~5 byte"}),"\n",(0,t.jsxs)(n.li,{children:["Format: The most significant bit (MSB) in every byte indicates whether to have the next byte. If first bit is set\ni.e. ",(0,t.jsx)(n.code,{children:"b & 0x80 == 0x80"}),", then\nthe next byte should be read until the first bit of the next byte is unset."]}),"\n"]}),"\n",(0,t.jsx)(n.h4,{id:"signed-int32",children:"signed int32"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"size: 4 byte"}),"\n",(0,t.jsx)(n.li,{children:"byte order: raw bytes of little endian order"}),"\n"]}),"\n",(0,t.jsx)(n.h4,{id:"signed-varint32",children:"signed varint32"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"size: 1~5 byte"}),"\n",(0,t.jsxs)(n.li,{children:["Format: First convert the number into positive unsigned int by ",(0,t.jsx)(n.code,{children:"(v << 1) ^ (v >> 31)"})," ZigZag algorithm, then encode\nit as an unsigned varint."]}),"\n"]}),"\n",(0,t.jsx)(n.h4,{id:"unsigned-int64",children:"unsigned int64"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"size: 8 byte"}),"\n",(0,t.jsx)(n.li,{children:"byte order: raw bytes of little endian order"}),"\n"]}),"\n",(0,t.jsx)(n.h4,{id:"unsigned-varint64",children:"unsigned varint64"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"size: 1~9 byte"}),"\n",(0,t.jsxs)(n.li,{children:["Fury SLI(Small long as int) Encoding:","\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["If long is in ",(0,t.jsx)(n.code,{children:"[0, 2147483647]"}),", encode as 4 bytes int: ",(0,t.jsx)(n.code,{children:"| little-endian: ((int) value) << 1 |"})]}),"\n",(0,t.jsxs)(n.li,{children:["Otherwise write as 9 bytes: ",(0,t.jsx)(n.code,{children:"| 0b1 | little-endian 8 bytes long |"})]}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["Fury PVL(Progressive Variable-length Long) Encoding:","\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["positive long format: first bit in every byte indicates whether to have the next byte. If first bit is set\ni.e. ",(0,t.jsx)(n.code,{children:"b & 0x80 == 0x80"}),", then the next byte should be read until the first bit is unset."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.h4,{id:"signed-int64",children:"signed int64"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"size: 8 byte"}),"\n",(0,t.jsx)(n.li,{children:"byte order: raw bytes of little endian order"}),"\n"]}),"\n",(0,t.jsx)(n.h4,{id:"signed-varint64",children:"signed varint64"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"size: 1~9 byte"}),"\n",(0,t.jsxs)(n.li,{children:["Fury SLI(Small long as int) Encoding:","\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["If long is in ",(0,t.jsx)(n.code,{children:"[-1073741824, 1073741823]"}),", encode as 4 bytes int: ",(0,t.jsx)(n.code,{children:"| little-endian: ((int) value) << 1 |"})]}),"\n",(0,t.jsxs)(n.li,{children:["Otherwise write as 9 bytes: ",(0,t.jsx)(n.code,{children:"| 0b1 | little-endian 8 bytes long |"})]}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["Fury PVL(Progressive Variable-length Long) Encoding:","\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["First convert the number into positive unsigned long by ",(0,t.jsx)(n.code,{children:"(v << 1) ^ (v >> 63)"})," ZigZag algorithm to reduce cost of\nsmall negative numbers, then encoding it as an unsigned long."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.h4,{id:"float32",children:"float32"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"size: 4 byte"}),"\n",(0,t.jsx)(n.li,{children:'format: encode the specified floating-point value according to the IEEE 754 floating-point "single format" bit layout,\npreserving Not-a-Number (NaN) values, then write as binary by little endian order.'}),"\n"]}),"\n",(0,t.jsx)(n.h4,{id:"float64",children:"float64"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"size: 8 byte"}),"\n",(0,t.jsx)(n.li,{children:'format: encode the specified floating-point value according to the IEEE 754 floating-point "double format" bit layout,\npreserving Not-a-Number (NaN) values. then write as binary by little endian order.'}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"string",children:"string"}),"\n",(0,t.jsx)(n.p,{children:"Format:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"| unsigned varint64: size << 2 `bitor` 2 bits encoding flags | binary data |\n"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"size + encoding"})," will be concat as a long and encoded as an unsigned varint64. The little 2 bits is used for\nencoding:\n0 for ",(0,t.jsx)(n.code,{children:"latin1(ISO-8859-1)"}),", 1 for ",(0,t.jsx)(n.code,{children:"utf-16"}),", 2 for ",(0,t.jsx)(n.code,{children:"utf-8"}),"."]}),"\n",(0,t.jsxs)(n.li,{children:["encoded string binary data based on encoding: ",(0,t.jsx)(n.code,{children:"latin/utf-16/utf-8"}),"."]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"Which encoding to choose:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["For JDK8: fury detect ",(0,t.jsx)(n.code,{children:"latin"})," at runtime, if string is ",(0,t.jsx)(n.code,{children:"latin"})," string, then use ",(0,t.jsx)(n.code,{children:"latin"})," encoding, otherwise\nuse ",(0,t.jsx)(n.code,{children:"utf-16"}),"."]}),"\n",(0,t.jsxs)(n.li,{children:["For JDK9+: fury use ",(0,t.jsx)(n.code,{children:"coder"})," in ",(0,t.jsx)(n.code,{children:"String"})," object for encoding, ",(0,t.jsx)(n.code,{children:"latin"}),"/",(0,t.jsx)(n.code,{children:"utf-16"})," will be used for encoding."]}),"\n",(0,t.jsxs)(n.li,{children:["If the string is encoded by ",(0,t.jsx)(n.code,{children:"utf-8"}),", then fury will use ",(0,t.jsx)(n.code,{children:"utf-8"})," to decode the data. Cross-language string\nserialization of fury uses ",(0,t.jsx)(n.code,{children:"utf-8"})," by default."]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"list",children:"list"}),"\n",(0,t.jsx)(n.p,{children:"Format:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"| unsigned varint64: length << 4 `bitor` 4 bits elements header | elements data |\n"})}),"\n",(0,t.jsx)(n.h4,{id:"elements-header",children:"elements header"}),"\n",(0,t.jsx)(n.p,{children:"In most cases, all elements are same type and not null, elements header will encode those homogeneous\ninformation to avoid the cost of writing it for every element. Specifically, there are four kinds of information\nwhich will be encoded by elements header, each use one bit:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["If track elements ref, use the first bit ",(0,t.jsx)(n.code,{children:"0b1"})," of the header to flag it."]}),"\n",(0,t.jsxs)(n.li,{children:["If the elements have null, use the second bit ",(0,t.jsx)(n.code,{children:"0b10"})," of the header to flag it. If ref tracking is enabled for this\nelement type, this flag is invalid."]}),"\n",(0,t.jsxs)(n.li,{children:["If the element types are not the declared type, use the 3rd bit ",(0,t.jsx)(n.code,{children:"0b100"})," of the header to flag it."]}),"\n",(0,t.jsxs)(n.li,{children:["If the element types are different, use the 4rd bit ",(0,t.jsx)(n.code,{children:"0b1000"})," header to flag it."]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"By default, all bits are unset, which means all elements won't track ref, all elements are same type, not null and\nthe actual element is the declared type in the custom type field."}),"\n",(0,t.jsx)(n.p,{children:"The implementation can generate different deserialization code based read header, and look up the generated code from\na linear map/list."}),"\n",(0,t.jsx)(n.h4,{id:"elements-data",children:"elements data"}),"\n",(0,t.jsxs)(n.p,{children:["Based on the elements header, the serialization of elements data may skip ",(0,t.jsx)(n.code,{children:"ref flag"}),"/",(0,t.jsx)(n.code,{children:"null flag"}),"/",(0,t.jsx)(n.code,{children:"element type info"}),"."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:"fury = ...\nbuffer = ...\nelems = ...\nif element_type_is_same:\n    if not is_declared_type:\n        fury.write_type(buffer, elem_type)\n    elem_serializer = get_serializer(...)\n    if track_ref:\n        for elem in elems:\n            if not ref_resolver.write_ref_or_null(buffer, elem):\n                elem_serializer.write(buffer, elem)\n    elif has_null:\n        for elem in elems:\n            if elem is None:\n                buffer.write_byte(null_flag)\n            else:\n                buffer.write_byte(not_null_flag)\n                elem_serializer.write(buffer, elem)\n    else:\n        for elem in elems:\n            elem_serializer.write(buffer, elem)\nelse:\n    if track_ref:\n        for elem in elems:\n            fury.write_ref(buffer, elem)\n    elif has_null:\n        for elem in elems:\n            fury.write_nullable(buffer, elem)\n    else:\n        for elem in elems:\n            fury.write_value(buffer, elem)\n"})}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.a,{href:"https://github.com/apache/fury/blob/20a1a78b17a75a123a6f5b7094c06ff77defc0fe/java/fury-core/src/main/java/org/apache/fury/serializer/collection/AbstractCollectionSerializer.java#L302",children:(0,t.jsx)(n.code,{children:"CollectionSerializer#writeElements"})}),"\ncan be taken as an example."]}),"\n",(0,t.jsx)(n.h3,{id:"array",children:"array"}),"\n",(0,t.jsx)(n.h4,{id:"primitive-array",children:"primitive array"}),"\n",(0,t.jsx)(n.p,{children:"Primitive array are taken as a binary buffer, serialization will just write the length of array size as an unsigned int,\nthen copy the whole buffer into the stream."}),"\n",(0,t.jsx)(n.p,{children:"Such serialization won't compress the array. If users want to compress primitive array, users need to register custom\nserializers for such types or mark it as list type."}),"\n",(0,t.jsx)(n.h4,{id:"object-array",children:"object array"}),"\n",(0,t.jsx)(n.p,{children:"Object array is serialized using the list format. Object component type will be taken as list element\ngeneric type."}),"\n",(0,t.jsx)(n.h3,{id:"map",children:"map"}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsxs)(n.p,{children:["All Map serializers must extend ",(0,t.jsx)(n.code,{children:"AbstractMapSerializer"}),"."]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"Format:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"| length(unsigned varint) | key value chunk data | ... | key value chunk data |\n"})}),"\n",(0,t.jsx)(n.h4,{id:"map-key-value-chunk-data",children:"map key-value chunk data"}),"\n",(0,t.jsxs)(n.p,{children:["Map iteration is too expensive, Fury won't compute the header like for list since it introduce\n",(0,t.jsx)(n.a,{href:"https://github.com/apache/fury/issues/925",children:"considerable overhead"}),".\nUsers can use ",(0,t.jsx)(n.code,{children:"MapFieldInfo"})," annotation to provide the header in advance. Otherwise Fury will use first key-value pair\nto predict header optimistically, and update the chunk header if the prediction failed at some pair."]}),"\n",(0,t.jsx)(n.p,{children:"Fury will serialize the map chunk by chunk, every chunk has 255 pairs at most."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"|    1 byte      |     1 byte     | variable bytes  |\n+----------------+----------------+-----------------+\n|    KV header   | chunk size: N  |   N*2 objects   |\n"})}),"\n",(0,t.jsx)(n.p,{children:"KV header:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["If track key ref, use the first bit ",(0,t.jsx)(n.code,{children:"0b1"})," of the header to flag it."]}),"\n",(0,t.jsxs)(n.li,{children:["If the key has null, use the second bit ",(0,t.jsx)(n.code,{children:"0b10"})," of the header to flag it. If ref tracking is enabled for this\nkey type, this flag is invalid."]}),"\n",(0,t.jsxs)(n.li,{children:["If the actual key type of map is not the declared key type, use the 3rd bit ",(0,t.jsx)(n.code,{children:"0b100"})," of the header to flag it."]}),"\n",(0,t.jsxs)(n.li,{children:["If track value ref, use the 4th bit ",(0,t.jsx)(n.code,{children:"0b1000"})," of the header to flag it."]}),"\n",(0,t.jsxs)(n.li,{children:["If the value has null, use the 5th bit ",(0,t.jsx)(n.code,{children:"0b10000"})," of the header to flag it. If ref tracking is enabled for this\nvalue type, this flag is invalid."]}),"\n",(0,t.jsxs)(n.li,{children:["If the value type of map is not the declared value type, use the 6rd bit ",(0,t.jsx)(n.code,{children:"0b100000"})," of the header to flag it."]}),"\n",(0,t.jsx)(n.li,{children:"If key or value is null, that key and value will be written as a separate chunk, and chunk size writing will be\nskipped too."}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:["If streaming write is enabled, which means Fury can't update written ",(0,t.jsx)(n.code,{children:"chunk size"}),". In such cases, map key-value data\nformat will be:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"|    1 byte      | variable bytes  |\n+----------------+-----------------+\n|    KV header   |   N*2 objects   |\n"})}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"KV header"})," will be a header marked by ",(0,t.jsx)(n.code,{children:"MapFieldInfo"})," in java. For languages such as golang, this can be computed in\nadvance for non-interface types most times. The implementation can generate different deserialization code based read\nheader, and look up the generated code from a linear map/list."]}),"\n",(0,t.jsx)(n.h4,{id:"why-serialize-chunk-by-chunk",children:"Why serialize chunk by chunk?"}),"\n",(0,t.jsxs)(n.p,{children:["When fury will use first key-value pair to predict header optimistically, it can't know how many pairs have same\nmeta(tracking kef ref, key has null and so on). If we don't write chunk by chunk with max chunk size, we must write at\nleast ",(0,t.jsx)(n.code,{children:"X"})," bytes to take up a place for later to update the number which has same elements, ",(0,t.jsx)(n.code,{children:"X"})," is the num_bytes for\nencoding varint encoding of map size."]}),"\n",(0,t.jsx)(n.p,{children:"And most map size are smaller than 255, if all pairs have same data, the chunk will be 1. This is common in golang/rust,\nwhich object are not reference by default."}),"\n",(0,t.jsx)(n.p,{children:"Also, if only one or two keys have different meta, we can make it into a different chunk, so that most pairs can share\nmeta."}),"\n",(0,t.jsx)(n.p,{children:"The implementation can accumulate read count with map size to decide whether to read more chunks."}),"\n",(0,t.jsx)(n.h3,{id:"enum",children:"enum"}),"\n",(0,t.jsx)(n.p,{children:"Enums are serialized as an unsigned var int. If the order of enum values change, the deserialized enum value may not be\nthe value users expect. In such cases, users must register enum serializer by make it write enum value as an enumerated\nstring with unique hash disabled."}),"\n",(0,t.jsx)(n.h3,{id:"decimal",children:"decimal"}),"\n",(0,t.jsx)(n.p,{children:"Not supported for now."}),"\n",(0,t.jsx)(n.h3,{id:"struct",children:"struct"}),"\n",(0,t.jsxs)(n.p,{children:["Struct means object of ",(0,t.jsx)(n.code,{children:"class/pojo/struct/bean/record"})," type.\nStruct will be serialized by writing its fields data in fury order."]}),"\n",(0,t.jsx)(n.p,{children:"Depending on schema compatibility, structs will have different formats."}),"\n",(0,t.jsx)(n.h4,{id:"field-order",children:"field order"}),"\n",(0,t.jsx)(n.p,{children:"Field will be ordered as following, every group of fields will have its own order:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"primitive fields: larger size type first, smaller later, variable size type last."}),"\n",(0,t.jsx)(n.li,{children:"boxed primitive fields: same order as primitive fields"}),"\n",(0,t.jsx)(n.li,{children:"final fields: same type together, then sorted by field name lexicographically."}),"\n",(0,t.jsx)(n.li,{children:"list fields: same order as final fields"}),"\n",(0,t.jsx)(n.li,{children:"map fields: same order as final fields"}),"\n",(0,t.jsx)(n.li,{children:"other fields: same order as final fields"}),"\n"]}),"\n",(0,t.jsx)(n.h4,{id:"schema-consistent-1",children:"schema consistent"}),"\n",(0,t.jsx)(n.p,{children:"Object will be written as:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"|    4 byte     |  variable bytes  |\n+---------------+------------------+\n|   type hash   |   field values   |\n"})}),"\n",(0,t.jsx)(n.p,{children:"Type hash is used to check the type schema consistency across languages. Type hash will be the first 32 bits of 56 bits\nvalue of the type meta."}),"\n",(0,t.jsx)(n.p,{children:"Object fields will be serialized one by one using following format:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"not null primitive field value:\n|   var bytes    |\n+----------------+\n|   value data   |\n+----------------+\nnullable primitive field value:\n| one byte  |   var bytes   |\n+-----------+---------------+\n| null flag |  field value  |\n+-----------+---------------+\nfield value of final type with ref tracking:\n| var bytes | var objects |\n+-----------+-------------+\n| ref meta  | value data  |\n+-----------+-------------+\nfield value of final type without ref tracking:\n| one byte  | var objects |\n+-----------+-------------+\n| null flag | field value |\n+-----------+-------------+\nfield value of non-final type with ref tracking:\n| one byte  | var bytes | var objects |\n+-----------+-------------+-------------+\n| ref meta  | type meta  | value data  |\n+-----------+-------------+-------------+\nfield value of non-final type without ref tracking:\n| one byte  | var bytes | var objects |\n+-----------+------------+------------+\n| null flag | type meta | value data |\n+-----------+------------+------------+\n"})}),"\n",(0,t.jsx)(n.h4,{id:"schema-evolution-1",children:"Schema evolution"}),"\n",(0,t.jsx)(n.p,{children:"Schema evolution have similar format as schema consistent mode for object except:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["For the object type, ",(0,t.jsx)(n.code,{children:"schema consistent"})," mode will write type by id only, but ",(0,t.jsx)(n.code,{children:"schema evolution"})," mode will\nwrite type consisting of field names, types and other meta too, see ",(0,t.jsx)(n.a,{href:"#type-meta",children:"Type meta"}),"."]}),"\n",(0,t.jsxs)(n.li,{children:["Type meta of ",(0,t.jsx)(n.code,{children:"final custom type"})," needs to be written too, because peers may not have this type defined."]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"type",children:"Type"}),"\n",(0,t.jsx)(n.p,{children:"Type will be serialized using type meta format."}),"\n",(0,t.jsx)(n.h2,{id:"implementation-guidelines",children:"Implementation guidelines"}),"\n",(0,t.jsx)(n.h3,{id:"how-to-reduce-memory-readwrite-code",children:"How to reduce memory read/write code"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Try to merge multiple bytes into an int/long write before writing to reduce memory IO and bound check cost."}),"\n",(0,t.jsx)(n.li,{children:"Read multiple bytes as an int/long, then split into multiple bytes to reduce memory IO and bound check cost."}),"\n",(0,t.jsx)(n.li,{children:"Try to use one varint/long to write flags and length together to save one byte cost and reduce memory io."}),"\n",(0,t.jsx)(n.li,{children:"Condition branches are less expensive compared to memory IO cost unless there are too many branches."}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"fast-deserialization-for-static-languages-without-runtime-codegen-support",children:"Fast deserialization for static languages without runtime codegen support"}),"\n",(0,t.jsx)(n.p,{children:"For type evolution, the serializer will encode the type meta into the serialized data. The deserializer will compare\nthis meta with class meta in the current process, and use the diff to determine how to deserialize the data."}),"\n",(0,t.jsx)(n.p,{children:"For java/javascript/python, we can use the diff to generate serializer code at runtime and load it as class/function for\ndeserialization. In this way, the type evolution will be as fast as type consist mode."}),"\n",(0,t.jsx)(n.p,{children:"For C++/Rust, we can't generate the serializer code at runtime. So we need to generate the code at compile-time using\nmeta programming. But at that time, we don't know the type schema in other processes, so we can't generate the\nserializer code for such inconsistent types. We may need to generate the code which has a loop and compare field name\none by one to decide whether to deserialize and assign the field or skip the field value."}),"\n",(0,t.jsxs)(n.p,{children:["One fast way is that we can optimize the string comparison into ",(0,t.jsx)(n.code,{children:"jump"})," instructions:"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["Assume the current type has ",(0,t.jsx)(n.code,{children:"n"})," fields, and the peer type has ",(0,t.jsx)(n.code,{children:"n1"})," fields."]}),"\n",(0,t.jsxs)(n.li,{children:["Generate an auto growing ",(0,t.jsx)(n.code,{children:"field id"})," from ",(0,t.jsx)(n.code,{children:"0"})," for every sorted field in the current type at the compile time."]}),"\n",(0,t.jsxs)(n.li,{children:["Compare the received type meta with current type, generate same id if the field name is same, otherwise generate an\nauto growing id starting from ",(0,t.jsx)(n.code,{children:"n"}),", cache this meta at runtime."]}),"\n",(0,t.jsxs)(n.li,{children:["Iterate the fields of received type meta, use a ",(0,t.jsx)(n.code,{children:"switch"})," to compare the ",(0,t.jsx)(n.code,{children:"field id"})," to deserialize data\nand ",(0,t.jsx)(n.code,{children:"assign/skip"})," field value. ",(0,t.jsx)(n.strong,{children:"Continuous"})," field id will be optimized into ",(0,t.jsx)(n.code,{children:"jump"})," in ",(0,t.jsx)(n.code,{children:"switch"})," block, so it will\nvery fast."]}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:["Here is an example, suppose process A has a class ",(0,t.jsx)(n.code,{children:"Foo"})," with version 1 defined as ",(0,t.jsx)(n.code,{children:"Foo1"}),", process B has a class ",(0,t.jsx)(n.code,{children:"Foo"}),"\nwith version 2 defined as ",(0,t.jsx)(n.code,{children:"Foo2"}),":"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-c++",children:"// class Foo with version 1\nclass Foo1 {\n  int32_t v1; // id 0\n  std::string v2; // id 1\n};\n// class Foo with version 2\nclass Foo2 {\n  // id 0, but will have id 2 in process A\n  bool v0;\n  // id 1, but will have id 0 in process A\n  int32_t v1;\n  // id 2, but will have id 3 in process A\n  int64_t long_value;\n  // id 3, but will have id 1 in process A\n  std::string v2;\n  // id 4, but will have id 4 in process A\n  std::vector<std::string> list;\n};\n"})}),"\n",(0,t.jsxs)(n.p,{children:["When process A received serialized ",(0,t.jsx)(n.code,{children:"Foo2"})," from process B, here is how it deserialize the data:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-c++",children:"Foo1 foo1 = ...;\nconst std::vector<fury::FieldInfo> &field_infos = type_meta.field_infos;\nfor (const auto &field_info : field_infos) {\n  switch (field_info.field_id) {\n    case 0:\n      foo1.v1 = buffer.read_varint32();\n      break;\n    case 1:\n      foo1.v2 = fury.read_string();\n      break;\n    default:\n      fury.skip_data(field_info);\n  }\n}\n"})})]})}function h(e={}){const{wrapper:n}={...(0,s.a)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(o,{...e})}):o(e)}},11151:(e,n,i)=>{i.d(n,{Z:()=>a,a:()=>l});var t=i(67294);const s={},r=t.createContext(s);function l(e){const n=t.useContext(r);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:l(e.components),t.createElement(r.Provider,{value:n},e.children)}}}]);