---
title: Fury Java 序列化规范
sidebar_position: 1
id: fury_java_serialization_spec
---

## 规范概述

Fury Java 序列化是一个支持引用和多态性的自动对象序列化框架。Fury 会将对象转换为/从 fury java 序列化二进制格式。Fury Java 序列化有两个核心概念：

- **Fury Java 二进制格式**
- **将对象转换为/从 Fury Java 二进制格式的框架**

序列化格式是一种动态二进制格式。动态性和对引用/多态性的支持使 Fury 更加灵活、更容易使用，但与静态序列化框架相比，也引入了更多的复杂性。因此，格式会更复杂。

以下是整体格式：

```
| fury 头部 | 对象引用元数据 | 对象类元数据 | 对象值数据 |
```

数据总体上使用小端字节序进行序列化。如果对某些对象进行字节交换的成本较高，Fury 将把该对象的字节序写入数据中，而不是将其转换为小端序。

## Fury 头部

Fury 头部由一个字节开始：

```
|     4 位     | 1 位 | 1 位  | 1 位   | 1 位  |          可选的 4 字节          |
+---------------+------+-------+--------+-------+------------------------------------+
|   保留位     |  oob  | xlang | 字节序 | 空值  | 用于元数据起始偏移量的无符号整数 |
```

- 空值标志：当对象为 null 时为 1，否则为 0。如果对象为 null，其他位不会被设置。
- 字节序标志：当数据使用小端编码时为 1，大端编码时为 0。
- xlang 标志：当序列化使用 xlang 格式时为 1，当序列化使用 Fury java 格式时为 0。
- oob 标志：当传递的 `BufferCallback` 不为 null 时为 1，否则为 0。

如果启用了元数据共享模式，会附加一个未压缩的无符号整数来指示元数据的起始偏移量。

## 引用元数据

引用跟踪处理对象是否为 null，以及是否通过写入相应的标志和维护内部状态来跟踪对象的引用。

引用标志：

| 标志                 | 字节值 | 描述                                                                                                     |
|---------------------|--------|----------------------------------------------------------------------------------------------------------|
| NULL FLAG           | `-3`   | 此标志表示对象是一个 null 值。我们不使用另一个字节来指示 REF，这样可以节省一个字节。                       |
| REF FLAG            | `-2`   | 此标志表示对象之前已被序列化，fury 将使用无符号 varint 格式写入 ref id，而不是再次序列化它                 |
| NOT_NULL VALUE FLAG | `-1`   | 此标志表示对象是非空值，fury 不跟踪此类对象的引用。                                                        |
| REF VALUE FLAG      | `0`    | 此标志表示对象是可引用的，并且是第一次序列化。                                                             |

当全局禁用引用跟踪或对特定类型禁用引用跟踪，或在特定上下文（例如，类的字段）中对某些类型禁用引用跟踪时，引用元数据仅使用 `NULL` 和 `NOT_NULL VALUE` 标志。

## 类元数据

Fury 支持通过可选的 id 注册类，注册可用于安全检查和类标识。
如果一个类被注册，它将具有一个用户提供的或自动增长的无符号整数，即 `class_id`。

根据当前类是否启用元数据共享模式和注册，Fury 将以不同方式写入类元数据。

### 模式一致性

如果全局启用了模式一致性模式或为当前类启用了模式一致性，类元数据将按如下方式写入：

- 如果类已注册，它将作为 fury 无符号 varint 写入：`class_id << 1`。
- 如果类未注册：
  - 如果类不是数组，fury 将首先写入一个字节 `0bxxxxxxx1`，然后写入类名。
    - 第一个小位是 `1`，与编码类 id 的第一位 `0` 不同。Fury 可以使用此信息来确定是否通过类 id 读取类进行反序列化。
  - 如果类未注册且类是数组，fury 将首先写入一个字节 `dimensions << 1 | 1`，然后随后写入组件类。如果组件类已序列化或将被序列化，这可以减少数组类名成本。
  - 类默认将作为两个枚举的 fury 无符号写入：`包名` 和 `类名`。如果启用了元数据共享模式，类将作为一个无符号 varint 写入，它指向 `MetaContext` 中的索引。

### 模式演进

如果全局启用了模式演进模式或为当前类启用了模式演进，类元数据将按如下方式写入：

- 如果未启用元数据共享模式，类元数据将按照模式一致性模式写入。此外，字段元数据（如字段类型和名称）将与字段值一起使用类似键值的布局写入。
- 如果启用了元数据共享模式，如果类之前没有被写入，类元数据将作为元数据共享编码二进制写入，否则将写入一个无符号 varint id，它引用之前写入的类元数据。

## 元数据共享

> 此模式将禁止流式写入，因为它需要在整个对象图写入和元数据收集完成后回溯以更新起始偏移量。只有这样，我们才能确保反序列化失败不会丢失共享元数据。
> 未来将支持元数据流线化，用于不跨多个不同对象序列化的封闭元数据共享。

对于模式一致性模式，类将通过完整类名编码为枚举字符串。这里我们主要描述模式演进模式的元数据布局：

```
|  8 字节全局元数据头    |  1~2 字节  |   可变字节   |  可变字节   | 可变字节 |
+-------------------------------+-------------|--------------------+-------------------+----------------+
| 50 位哈希 + 14 位头部 | 类型头部 | 当前类元数据 | 父类元数据 |      ...       |
```

类元数据从父类到叶类进行编码，只有具有可序列化字段的类才会被编码。

### 全局元数据头部

元数据头部是一个以小端序编码的 64 位数值。

- 低 12 位用于编码元数据大小。如果元数据大小 `>= 0b111_1111_1111`，则接下来写入 `meta_size - 0b111_1111_1111`。
- 第 13 位用于指示是否写入字段元数据。当此类是模式一致性或使用注册的序列化器时，字段元数据将被跳过。类元数据将仅用于共享命名空间 + 类型名称。
- 第 14 位用于指示元数据是否压缩。
- 其他 50 位用于存储 `flags + 所有层的类元数据` 的唯一哈希值。

### 类型头部

- 最低 4 位 `0b0000~0b1110` 用于记录类的数量。`0b1111` 保留用于指示 Fury 需要使用 Fury 无符号整数编码读取更多字节的长度。如果当前类没有父类，或父类没有要序列化的字段，或者我们在只序列化当前类字段的上下文中（`ObjectStreamSerializer#SlotInfo` 是一个例子），类的数量将是 1。
- 其他 4 位保留用于未来扩展。
- 如果类的数量大于或等于 `0b1111`，接下来将 `num_classes - 0b1111` 作为 varuint 写入。

### 单层类元数据

```
|      无符号 varint       |      元字符串      |     元字符串     |  字段信息：可变字节   | 可变字节  | ... |
+----------------------------+-----------------------+---------------------+-------------------------------+-----------------+-----+
| 字段数量 + 注册标志 | 头部 + 包名 | 头部 + 类名 | 头部 + 类型 id + 字段名 | 下一个字段信息 | ... |
```

- 字段数量：将 `字段数量 << 1 | 注册标志(类已注册时为1)` 编码为无符号 varint。
  - 如果类已注册，则接下来将写入一个无符号 varint 类 id，将省略包和类名。
  - 如果当前类是模式一致性的，则字段数量将是 `0` 来标记它。
  - 如果当前类不是模式一致性的，则字段数量将是兼容字段的数量。例如，用户可以使用标签 id 在模式一致性上下文中将某些字段标记为兼容字段。在这种情况下，模式一致性字段将首先被序列化，然后是兼容字段。在反序列化时，Fury 将使用那些未被标签 id 注释的字段信息来反序列化模式一致性字段，然后使用元数据中的字段信息来反序列化兼容字段。
- 包名编码（当类已注册时省略）：
  - 编码算法：`UTF8/ALL_TO_LOWER_SPECIAL/LOWER_UPPER_DIGIT_SPECIAL`
  - 头部：`6 位大小 | 2 位编码标志`。`6 位大小：0~63` 将用于指示大小 `0~63`，值 `63` 表示大小需要更多字节来读取，编码将接下来编码 `size - 63` 为 varint。
- 类名编码（当类已注册时省略）：
  - 编码算法：`UTF8/LOWER_UPPER_DIGIT_SPECIAL/FIRST_TO_LOWER_SPECIAL/ALL_TO_LOWER_SPECIAL`
  - 头部：`6 位大小 | 2 位编码标志`。`6 位大小：0~63` 将用于指示大小 `0~63`，值 `63` 表示大小需要更多字节来读取，编码将接下来编码 `size - 63` 为 varint。
- 字段信息：
  - 头部（8位）：`3 位大小 + 2 位字段名称编码 + 多态标志 + 可空性标志 + 引用跟踪标志`。用户可以使用注释提供这些信息。
    - 2 位字段名称编码：
      - 编码：`UTF8/ALL_TO_LOWER_SPECIAL/LOWER_UPPER_DIGIT_SPECIAL/TAG_ID`
      - 如果使用标签 id，即字段名由无符号 varint 标签 id 写入。2 位编码将是 `11`。
    - 字段名称的大小：
      - `3 位大小：0~7` 将用于指示长度 `1~7`，值 `6` 表示大小需要读取更多字节，编码将接下来编码 `size - 7` 为 varint。
      - 如果编码是 `TAG_ID`，则字段名称的 num_bytes 将用于存储标签 id。
    - 引用跟踪：设置为 1 时，将为此字段启用引用跟踪。
    - 可空性：设置为 1 时，此字段可以为 null。
    - 多态性：设置为 1 时，字段的实际类型将是声明的字段类型，即使类型不是 `final`。
  - 类型 id：
    - 对于已注册的类型一致性类，它将是已注册的类 id。
    - 否则，如果它不是 `final` 的，它将被编码为 `OBJECT_ID`，如果它是 `final` 的，则编码为 `FINAL_OBJECT_ID`。此类类型的元数据被单独写入而不是内联在这里，是为了减少元数据空间成本，如果当前对象图中多次序列化此类型的对象，且字段值也可能为 null。
  - 字段名称：如果设置了类型 id，将使用类型 id。否则，将写入元字符串编码长度和数据。

字段顺序作为实现细节留下，不向规范公开，反序列化需要根据 Fury 字段比较器对字段进行重新排序。通过这种方式，fury 可以计算字段名称或类型的统计信息，并使用更紧凑的编码。

### 其他层类元数据

编码算法与前一层相同，除了：

- 头部 + 包名：
  - 头部：
    - 如果包名之前已经写入：将写入 `varint 索引 + 共享标志（设置）`
    - 如果包名之前没有写入：
      - 如果元字符串编码是 `LOWER_SPECIAL` 且编码字符串的长度 `<=` 64，则头部将是 `6 位大小 + 编码标志（设置）+ 共享标志（未设置）`。
      - 否则，头部将是 `3 位未设置 + 3 位编码标志 + 编码标志（未设置）+ 共享标志（未设置）`

## 元字符串

元字符串主要用于编码元数据字符串，如类名和字段名。

### 编码算法

字符串二进制编码算法：

| 算法                    | 模式          | 描述                                                                                                                                                                                                                                                                              |
|------------------------|---------------|-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| LOWER_SPECIAL          | `a-z._$\|`    | 每个字符使用 5 位写入，`a-z`：`0b00000~0b11001`，`._$\|`：`0b11010~0b11101`，在开始处添加一个位以指示是否剪掉最后一个字符，因为最后一个字节可能有 7 个冗余位（1 表示剪掉最后一个字符）                                                                                             |
| LOWER_UPPER_DIGIT_SPECIAL | `a-zA-Z0~9._` | 每个字符使用 6 位写入，`a-z`：`0b00000~0b11001`，`A-Z`：`0b11010~0b110011`，`0~9`：`0b110100~0b111101`，`._`：`0b111110~0b111111`，在开始处添加一个位以指示是否剪掉最后一个字符，因为最后一个字节可能有 7 个冗余位（1 表示剪掉最后一个字符） |
| UTF-8                  | 任何字符       | UTF-8 编码                                                                                                                                                                                                                                                                       |

编码标志：

| 编码标志                 | 模式                                                           | 编码算法                                                                                                                                                  |
|------------------------|----------------------------------------------------------------|-----------------------------------------------------------------------------------------------------------------------------------------------------------|
| LOWER_SPECIAL          | 每个字符都在 `a-z._$\|` 中                                      | `LOWER_SPECIAL`                                                                                                                                             |
| FIRST_TO_LOWER_SPECIAL | 每个字符都在 `a-z[c1,c2]` 中，除了首字符是大写                   | 替换首个大写字符为小写，然后使用 `LOWER_SPECIAL`                                                                                                            |
| ALL_TO_LOWER_SPECIAL   | 每个字符都在 `a-zA-Z[c1,c2]` 中                                | 用 `\|` + `小写字符` 替换每个大写字符，然后使用 `LOWER_SPECIAL`，如果它比编码 `LOWER_UPPER_DIGIT_SPECIAL` 更小则使用此编码                                   |
| LOWER_UPPER_DIGIT_SPECIAL | 每个字符都在 `a-zA-Z[c1,c2]` 中                             | 如果它比编码 `FIRST_TO_LOWER_SPECIAL` 更小，则使用 `LOWER_UPPER_DIGIT_SPECIAL` 编码                                                                          |
| UTF8                   | 任何 utf-8 字符                                                | 使用 `UTF-8` 编码                                                                                                                                           |
| Compression            | 任何 utf-8 字符                                                | 无损压缩                                                                                                                                                    |

注意：

- 对于包名编码，`c1,c2` 应该是 `._`；对于字段/类型名称编码，`c1,c2` 应该是 `_$`；
- 根据情况，可以选择联合编码 `标志 + 数据`，使用第一个字节的 3 位作为标志，其他字节作为数据。

### 共享元字符串

共享元字符串格式由头部和编码字符串二进制组成。编码字符串二进制的头部将内联在共享元数据头部中。

头部使用小端序写入，Fury 可以首先读取此标志来确定如何反序列化数据。

#### 通过数据写入

如果字符串之前没有被写入，数据将按如下方式写入：

```
| 无符号 varint：字符串二进制大小 + 1 位：之前未写入 | 56 位：唯一哈希 | 3 位编码标志 + 字符串二进制 |
```

如果字符串二进制大小小于 `16` 字节，哈希将被省略以节省空间。如果调用者传递标志以禁用唯一哈希，也可以省略唯一哈希。在这种情况下，格式将是：

```
| 无符号 varint：字符串二进制大小 + 1 位：之前未写入  | 3 位编码标志 + 字符串二进制 |
```

#### 通过引用写入

如果字符串之前已经被写入，数据将按如下方式写入：

```
| 无符号 varint：已写入字符串 id + 1 位：之前已写入 |
```

## 值格式

### 基本类型

#### Bool

- 大小：1 字节
- 格式：`false` 为 0，`true` 为 1

#### Byte

- 大小：1 字节
- 格式：作为纯字节写入。

#### Short

- 大小：2 字节
- 字节序：小端序

#### Char

- 大小：2 字节
- 字节序：小端序

#### 无符号整数

- 大小：1~5 字节
- 格式：每个字节中的最高有效位（MSB）指示是否有下一个字节。如果第一位被设置，即 `b & 0x80 == 0x80`，则应该读取下一个字节，直到下一个字节的第一位未设置。

#### 有符号整数

- 大小：1~5 字节
- 格式：首先通过 `(v << 1) ^ (v >> 31)` ZigZag 算法将数字转换为正无符号整数，然后将其编码为无符号整数。

#### 无符号长整数

- 大小：1~9 字节
- Fury PVL（Progressive Variable-length Long）编码：
  - 正长整数格式：每个字节中的第一位指示是否有下一个字节。如果第一位被设置，即 `b & 0x80 == 0x80`，则应该读取下一个字节，直到第一位未设置。

#### 有符号长整数

- 大小：1~9 字节
- Fury SLI（Small long as int）编码：
  - 如果长整数在 [-1073741824, 1073741823] 范围内，编码为 4 字节整数：`| 小端序：((int) value) << 1 |`
  - 否则写为 9 字节：`| 0b1 | 小端序 8 字节长整数 |`
- Fury PVL（Progressive Variable-length Long）编码：
  - 首先通过 `(v << 1) ^ (v >> 63)` ZigZag 算法将数字转换为正无符号长整数，以减少小负数的成本，然后将其编码为无符号长整数。

#### Float

- 大小：4 字节
- 格式：通过 `Float.floatToRawIntBits` 将浮点数转换为 4 字节整数，然后按小端序写入二进制。

#### Double

- 大小：8 字节
- 格式：通过 `Double.doubleToRawLongBits` 将双精度浮点数转换为 8 字节整数，然后按小端序写入二进制。

### 字符串

格式：

```
| 头部：大小 << 2 | 2 位编码标志 | 二进制数据 |
```

- `大小 + 编码` 将连接为一个长整数并编码为无符号变长长整数。小 2 位用于编码：0 表示 `latin`，1 表示 `utf-16`，2 表示 `utf-8`。
- 基于编码的编码字符串二进制数据：`latin/utf-16/utf-8`。

如何选择编码：

- 对于 JDK8：fury 在运行时检测 `latin`，如果字符串是 `latin` 字符串，则使用 `latin` 编码，否则使用 `utf-16`。
- 对于 JDK9+：fury 使用 `String` 对象中的 `coder` 进行编码，将使用 `latin`/`utf-16` 进行编码。
- 如果字符串由 `utf-8` 编码，则 fury 将使用 `utf-8` 解码数据。fury 的跨语言字符串序列化默认使用 `utf-8`。

### 集合

> 所有集合序列化器必须扩展 `AbstractCollectionSerializer`。

格式：

```
长度（无符号 varint）| 集合头部 | 元素头部 | 元素数据
```

#### 集合头部

- 对于 `ArrayList/LinkedArrayList/HashSet/LinkedHashSet`，这将为空。
- 对于 `TreeSet`，这将是 `Comparator`
- 对于 `ArrayList` 的子类，这可能是额外的对象字段信息。

#### 元素头部

在大多数情况下，所有集合元素都是相同类型且非空的，元素头部将编码这些同质信息，以避免为每个元素写入它的成本。具体来说，有四种信息将由元素头部编码，每种使用一位：

- 如果跟踪元素引用，使用头部的第一位 `0b1` 来标记它。
- 如果集合有空值，使用头部的第二位 `0b10` 来标记它。如果为此元素类型启用了引用跟踪，此标志无效。
- 如果集合元素类型不是声明类型，使用头部的第三位 `0b100` 来标记它。
- 如果集合元素类型不同，使用头部的第四位 `0b1000` 来标记它。

默认情况下，所有位都未设置，这意味着所有元素都不会跟踪引用，所有元素都是相同类型，非空，并且实际元素是自定义类字段中声明的类型。

实现可以根据读取的头部生成不同的反序列化代码，并从线性映射/列表中查找生成的代码。

#### 元素数据

基于元素头部，元素数据的序列化可能会跳过 `引用标志`/`空标志`/`元素类信息`。

`CollectionSerializer#write/read` 可以作为示例。

### 数组

#### 基本类型数组

基本类型数组被视为二进制缓冲区，序列化只会将数组大小的长度写为无符号整数，然后将整个缓冲区复制到流中。

这种序列化不会压缩数组。如果用户想要压缩基本类型数组，用户需要为此类类型注册自定义序列化器。

#### 对象数组

对象数组使用集合格式序列化。对象组件类型将被视为集合元素泛型类型。

### 映射

> 所有映射序列化器必须扩展 `AbstractMapSerializer`。

格式：

```
| 长度（无符号 varint）| 映射头部 | 键值对数据 |
```

#### 映射头部

- 对于 `HashMap/LinkedHashMap`，这将为空。
- 对于 `TreeMap`，这将是 `Comparator`
- 对于其他 `Map`，这可能是额外的对象字段信息。

#### 映射键值数据

映射迭代成本太高，Fury 不会像集合那样提前计算头部，因为它会引入[相当大的开销](https://github.com/apache/fury/issues/925)。
用户可以使用 `MapFieldInfo` 注解提前提供头部。否则，Fury 将乐观地使用第一个键值对来预测头部，如果预测在某些对中失败，则更新块头部。

Fury 将按块序列化映射，每个块最多有 127 对。

```
|    1 字节      |     1 字节     | 可变字节  |
+----------------+----------------+-----------------+
|    KV 头部     | 块大小：N      |   N*2 个对象   |
```

KV 头部：

- 如果跟踪键引用，使用头部的第一位 `0b1` 来标记它。
- 如果键有空值，使用头部的第二位 `0b10` 来标记它。如果为此键类型启用了引用跟踪，此标志无效。
- 如果映射的实际键类型不是声明的键类型，使用头部的第三位 `0b100` 来标记它。
- 如果跟踪值引用，使用头部的第四位 `0b1000` 来标记它。
- 如果值有空值，使用头部的第五位 `0b10000` 来标记它。如果为此值类型启用了引用跟踪，此标志无效。
- 如果映射的值类型不是声明的值类型，使用头部的第六位 `0b100000` 来标记它。
- 如果键或值为空，那么该键和值将作为单独的块写入，并且块大小写入也将被跳过。

如果启用了流式写入，这意味着 Fury 不能更新已写入的 `块大小`。在这种情况下，映射键值数据格式将是：

```
|    1 字节      | 可变字节  |
+----------------+-----------------+
|    KV 头部     |   N*2 个对象   |
```

`KV 头部` 将是 java 中由 `MapFieldInfo` 标记的头部。实现可以根据读取的头部生成不同的反序列化代码，并从线性映射/列表中查找生成的代码。

### 枚举

枚举被序列化为无符号 var int。如果枚举值的顺序发生变化，反序列化的枚举值可能不是用户期望的值。在这种情况下，用户必须通过使其将枚举值写为禁用唯一哈希的枚举字符串来注册枚举序列化器。

### 对象

对象指的是 `pojo/struct/bean/record` 类型的对象。
对象将通过按 fury 顺序写入其字段数据来序列化。

根据模式兼容性，对象将有不同的格式。

#### 字段顺序

字段将按如下排序，每组字段都有自己的顺序：

- 基本类型字段：大小类型先，小型后，可变大小类型最后。
- 装箱基本类型字段：与基本类型字段相同的顺序
- final 字段：相同类型在一起，然后按字段名称字典序排序。
- 集合字段：与 final 字段相同的顺序
- 映射字段：与 final 字段相同的顺序
- 其他字段：与 final 字段相同的顺序

#### 模式一致性

对象字段将一个接一个地使用以下格式序列化：

```
基本字段值：
|   可变字节    |
+----------------+
|   值数据      |
+----------------+
装箱字段值：
| 一个字节  |   可变字节   |
+-----------+---------------+
| 空值标志  |  字段值       |
+-----------+---------------+
具有引用跟踪的 final 类型字段值：
| 可变字节 | 可变对象 |
+-----------+-------------+
| 引用元数据 | 值数据   |
+-----------+-------------+
不具有引用跟踪的 final 类型字段值：
| 一个字节  | 可变对象 |
+-----------+-------------+
| 空值标志  | 字段值    |
+-----------+-------------+
具有引用跟踪的非 final 类型字段值：
| 一个字节  | 可变字节 | 可变对象 |
+-----------+-------------+-------------+
| 引用元数据 | 类元数据  | 值数据   |
+-----------+-------------+-------------+
不具有引用跟踪的非 final 类型字段值：
| 一个字节  | 可变字节 | 可变对象 |
+-----------+------------+------------+
| 空值标志  | 类元数据  | 值数据   |
+-----------+------------+------------+
```

#### 模式演进

模式演进对对象的格式与模式一致性模式相似，除了：

- 对于对象类型本身，`模式一致性` 模式将通过 id/名称写入类，但 `模式演进` 模式也将写入类字段名称、类型和其他元数据，参见 [类元数据](#类元数据)。
- `final 自定义类型` 的类元数据也需要写入，因为对等方可能没有定义此类。

### 类

类将使用类元数据格式序列化。

## 实现指南

- 尝试在写入之前将多个字节合并为一个 int/long 写入，以减少内存 IO 和边界检查成本。
- 将多个字节作为一个 int/long 读取，然后分成多个字节，以减少内存 IO 和边界检查成本。
- 尝试使用一个 varint/long 来一起写入标志和长度，以节省一个字节成本并减少内存 io。
- 与内存 IO 成本相比，条件分支的成本较低，除非有太多分支。