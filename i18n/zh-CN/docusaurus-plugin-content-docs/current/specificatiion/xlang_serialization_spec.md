---
title: Fury Xlang 序列化规范
sidebar_position: 0
id: fury_xlang_serialization_spec
---

## 跨语言序列化规范

> 格式版本历史：
>
> - 版本 0.1 - 序列化规范正式确立

Fury Xlang 序列化是一个支持引用和多态性的自动对象序列化框架。
Fury 将对象转换为/从 fury 跨语言序列化二进制格式。
Fury Xlang 序列化有两个核心概念：

- **Fury Xlang 二进制格式**
- **用不同语言实现的框架，用于将对象转换为/从 Fury Xlang 二进制格式**

序列化格式是一种动态二进制格式。动态性和对引用/多态性的支持使 Fury 更加灵活、更容易使用，但与静态序列化框架相比，也引入了更多的复杂性。因此，格式会更复杂。

## 类型系统

### 数据类型

- bool: 布尔值（true 或 false）。
- int8: 8 位有符号整数。
- int16: 16 位有符号整数。
- int32: 32 位有符号整数。
- var_int32: 使用 fury var_int32 编码的 32 位有符号整数。
- int64: 64 位有符号整数。
- var_int64: 使用 fury PVL 编码的 64 位有符号整数。
- sli_int64: 使用 fury SLI 编码的 64 位有符号整数。
- float16: 16 位浮点数。
- float32: 32 位浮点数。
- float64: 64 位浮点数，包括 NaN 和无穷大。
- string: 使用 Latin1/UTF16/UTF-8 编码的文本字符串。
- enum: 由一组命名值组成的数据类型。不支持带有非预定义字段值的 Rust 枚举作为枚举。
- named_enum: 其值将作为注册名称序列化的枚举。
- struct: 由 Fury Struct 序列化器序列化的态射（final）类型。即它没有子类。假设我们正在反序列化 `List<SomeClass>`，我们可以节省动态序列化器调度，因为 `SomeClass` 是态射（final）的。
- compatible_struct: 由 Fury 兼容 Struct 序列化器序列化的态射（final）类型。
- named_struct: 其类型映射将编码为名称的 `struct`。
- named_compatible_struct: 其类型映射将编码为名称的 `compatible_struct`。
- ext: 将由自定义序列化器序列化的类型。
- named_ext: 其类型映射将编码为名称的 `ext` 类型。
- list: 对象序列。
- set: 唯一元素的无序集合。
- map: 键值对映射。不允许可变类型如 `list/map/set/array/tensor/arrow` 作为映射的键。
- duration: 与任何日历/时区无关的绝对时间长度，以纳秒计数。
- timestamp: 与任何日历/时区无关的时间点，以纳秒计数。计数相对于 1970 年 1 月 1 日 UTC 午夜的纪元。
- local_date: 没有时区的朴素日期。计数是相对于 1970 年 1 月 1 日 UTC 午夜的纪元的天数。
- decimal: 以二进制补码表示的精确十进制值。
- binary: 可变长度的字节数组。
- array: 只允许 1d 数值组件。其他数组将被视为列表。实现应支持数组和列表之间的互操作性。
  - bool_array: 一维 int16 数组。
  - int8_array: 一维 int8 数组。
  - int16_array: 一维 int16 数组。
  - int32_array: 一维 int32 数组。
  - int64_array: 一维 int64 数组。
  - float16_array: 一维 half_float_16 数组。
  - float32_array: 一维 float32 数组。
  - float64_array: 一维 float64 数组。
- tensor: 多维数组，每个子数组具有相同的大小和类型。
- arrow record batch: arrow [记录批次](https://arrow.apache.org/docs/cpp/tables.html#record-batches) 对象。
- arrow table: arrow [表](https://arrow.apache.org/docs/cpp/tables.html#tables) 对象。

注意：

- 这里没有添加无符号 int/long，因为并非每种语言都支持这些类型。

### 多态性

对于多态性，如果注册了一个非 final 类，并且只注册了一个子类，那么我们可以认为 List/Map 中的所有元素都是相同类型，从而减少运行时检查成本。

集合/数组多态性不完全支持，因为某些语言（如 golang）只有一种集合类型。如果用户想要获得他传递的确切类型，他必须在反序列化时传递该类型，或者将该类型注释到结构的字段中。

### 类型消歧

由于语言之间的类型系统差异，这些类型不能在语言之间一对一映射。在反序列化时，Fury 使用目标数据结构类型和数据中的数据类型共同确定如何反序列化和填充目标数据结构。例如：

```java
class Foo {
  int[] intArray;
  Object[] objects;
  List<Object> objectList;
}

class Foo2 {
  int[] intArray;
  List<Object> objects;
  List<Object> objectList;
}
```

`intArray` 具有 `int32_array` 类型。但序列化数据中的 `objects` 和 `objectList` 字段都具有 `list` 数据类型。在反序列化时，实现将为 `objects` 创建一个 `Object` 数组，但为 `objectList` 创建一个 `ArrayList` 来填充其元素。而且 `Foo` 的序列化数据也可以反序列化为 `Foo2`。

用户还可以为类型的字段或整个类型提供元数据提示。以下是在 java 中使用注解提供此类信息的示例。

```java
@FuryObject(fieldsNullable = false, trackingRef = false)
class Foo {
  @FuryField(trackingRef = false)
  int[] intArray;
  @FuryField(polymorphic = true)
  Object object;
  @FuryField(tagId = 1, nullable = true)
  List<Object> objectList;
}
```

在其他语言中也可以提供此类信息：

- cpp: 使用宏和模板。
- golang: 使用结构标签。
- python: 使用类型提示。
- rust: 使用宏。

### 类型 ID

所有内部数据类型都使用范围 `0~64` 内的 ID 表示。用户可以使用 `0~4096` 来表示他们的类型。

### 类型映射

请参见[类型映射](../guide/xlang_type_mapping.md)

## 规范概述

以下是整体格式：

```
| fury 头部 | 对象引用元数据 | 对象类型元数据 | 对象值数据 |
```

数据总体上使用小端字节序进行序列化。如果对某些对象进行字节交换的成本较高，Fury 将把该对象的字节序写入数据中，而不是将其转换为小端序。

## Fury 头部

Fury 头部由一个字节开始：

```
|    2 字节   |     4 位     | 1 位 | 1 位  | 1 位   | 1 位 |   1 字节   |          可选的 4 字节          |
+--------------+---------------+-------+-------+--------+-------+------------+------------------------------------+
| 魔术数 | 保留位 |  oob  | xlang | 字节序 | 空值 |  语言  | 用于元数据起始偏移量的无符号整数 |
```

- 魔术数：用于标识 fury 序列化协议，当前版本使用 `0x62d4`。
- 空值标志：当对象为 null 时为 1，否则为 0。如果对象为 null，其他位不会被设置。
- 字节序标志：当数据使用小端编码时为 1，大端编码时为 0。
- xlang 标志：当序列化使用 xlang 格式时为 1，当序列化使用 Fury java 格式时为 0。
- oob 标志：当传递的 `BufferCallback` 不为 null 时为 1，否则为 0。
- 语言：序列化对象时的语言，如 JAVA、PYTHON、GO 等。Fury 可以使用此标志来确定是否在序列化上花费更多时间，以使动态语言的反序列化更快。

如果启用了元数据共享模式，会附加一个未压缩的无符号整数来指示元数据的起始偏移量。

## 引用元数据

引用跟踪处理对象是否为 null，以及是否通过写入相应的标志和维护内部状态来跟踪对象的引用。

引用标志：

| 标志                 | 字节值 | 描述                                                                                                     |
|---------------------|--------|----------------------------------------------------------------------------------------------------------|
| NULL FLAG           | `-3`   | 此标志表示对象是一个 null 值。我们不使用另一个字节来指示 REF，这样可以节省一个字节。                       |
| REF FLAG            | `-2`   | 此标志表示对象之前已被序列化，fury 将使用无符号 varint 格式写入 ref id，而不是再次序列化它                 |
| NOT_NULL VALUE FLAG | `-1`   | 此标志表示对象是非空值，fury 不跟踪此类对象的引用。                                                        |
| REF VALUE FLAG      | `0`    | 此标志表示对象是可引用的，并且是第一次序列化。                                                             |

当全局禁用引用跟踪或对特定类型禁用引用跟踪，或在特定上下文（例如，类型的字段）中对某些类型禁用引用跟踪时，引用元数据仅使用 `NULL` 和 `NOT_NULL VALUE` 标志。

对于不支持引用的语言，如 rust，必须禁用引用跟踪以正确进行 fury rust 实现的反序列化。

对于默认对象值不为 null 的语言：

- 在 rust 中，Fury 将 `Option:None` 视为 null 值
- 在 c++ 中，Fury 将 `std::nullopt` 视为 null 值
- 在 golang 中，Fury 将 `null interface/pointer` 视为 null 值

如果想要在如 `Java/Python/JavaScript` 等语言中反序列化，应该将所有字段默认标记为非空，或使用模式演进模式在数据中携带非空字段信息。

## 类型元数据

对于每种要序列化的类型，它都有一个类型 id 来指示其类型。

- 基本类型：类型 id
- 枚举：
  - `Type.ENUM` + 已注册 id
  - `Type.NAMED_ENUM` + 已注册命名空间+类型名
- 列表：`Type.List`
- 集合：`Type.SET`
- 映射：`Type.MAP`
- ext：
  - `Type.EXT` + 已注册 id
  - `Type.NAMED_EXT` + 已注册命名空间+类型名
- struct：
  - `Type.STRUCT` + 结构元数据
  - `Type.NAMED_STRUCT` + 结构元数据

每种类型必须首先使用 ID 或名称注册。注册可用于安全检查和类型识别。

结构是一种特殊类型，根据是否启用模式兼容性，Fury 将以不同方式写入结构元数据。

### 结构模式一致性

- 如果在创建 fury 时全局启用了模式一致性模式，类型元数据将作为 fury 无符号 varint 的 `type_id` 写入。将忽略模式演进相关的元数据。
- 如果在创建 fury 时全局启用了模式演进模式，并且当前类配置为使用模式一致性模式（类似于 flatbuffers 中的 `struct` vs `table`）：
  - 类型元数据将在注册类型时提前添加到 `captured_type_defs`：`captured_type_defs[type def stub] = map size`。
  - 获取 `captured_type_defs` 中元数据的索引，将该索引写为 `| 无符号 varint：索引 |`。

### 结构模式演进

如果在创建 fury 时全局启用了模式演进模式，并且为当前类型启用了模式演进，类型元数据将使用以下模式之一写入。使用哪种模式在创建 fury 时配置。

- 普通模式（未启用元数据共享）：
  - 如果类型元数据之前没有被写入，将 `type def` 添加到 `captured_type_defs`：`captured_type_defs[type def] = map size`。
  - 获取 `captured_type_defs` 中元数据的索引，将该索引写为 `| 无符号 varint：索引 |`。
  - 完成对象图的序列化后，fury 将开始写入 `captured_type_defs`：

      ```python
      buffer.write_var_uint32(len(writting_type_defs) - len(schema_consistent_type_def_stubs))
      for type_meta in writting_type_defs:
          if not type_meta.is_stub():
              type_meta.write_type_def(buffer)
      writing_type_defs = copy(schema_consistent_type_def_stubs)
      ```

- 元数据共享模式：写入步骤与普通模式相同，但 `captured_type_defs` 将在不同对象的多次序列化之间共享。例如，假设我们有一个要序列化的批次：

    ```python
    captured_type_defs = {}
    stream = ...
    # 将 `Type1` 添加到 `captured_type_defs` 并写入 `Type1`
    fury.serialize(stream, [Type1()])
    # 将 `Type2` 添加到 `captured_type_defs` 并写入 `Type2`，`Type1` 之前已写入。
    fury.serialize(stream, [Type1(), Type2()])
    # `Type1` 和 `Type2` 之前已写入，无需写入元数据。
    fury.serialize(stream, [Type1(), Type2()])
    ```

- 流式模式（流式模式不支持元数据共享）：
  - 如果类型元数据之前没有被写入，数据将被写为：

      ```
      | 无符号 varint：0b11111111 | type def |
      ```

  - 如果类型元数据之前已被写入，数据将被写为：

      ```
      | 无符号 varint：written index << 1 |
      ```

      `written index` 是 `captured_type_defs` 中的 id。
  - 使用此模式，可以省略 `meta start offset`。

> 普通模式和元数据共享模式将禁止流式写入，因为它需要在整个对象图写入和元数据收集完成后回溯以更新起始偏移量。只有这样，我们才能确保在元数据共享模式下的反序列化失败不会丢失共享元数据。

#### 类型定义

这里我们主要描述模式演进模式的元数据布局：

```
|    8 字节头部    |   可变字节   |  可变字节   |
+----------------------+--------------------+-------------------+
| 全局二进制头部 |    元数据头部     |    字段元数据    |
```

对于支持继承的语言，如果父类和子类有相同名称的字段，使用子类中的字段。

##### 全局二进制头部

`50 位哈希 + 1位压缩标志 + 写入字段元数据 + 12 位元数据大小`。右侧是低位。

- 低 12 位用于编码元数据大小。如果元数据大小 `>= 0b111_1111_1111`，则接下来写入 `meta_size - 0b111_1111_1111`。
- 第 13 位用于指示是否写入字段元数据。当此类是模式一致性或使用注册的序列化器时，字段元数据将被跳过。类元数据将仅用于共享命名空间 + 类型名称。
- 第 14 位用于指示元数据是否压缩。
- 其他 50 位用于存储 `flags + 所有层的类元数据` 的唯一哈希值。

##### 元数据头部

元数据头部是一个 8 位数值。

- 最低 5 位 `0b00000~0b11110` 用于记录字段数量。`0b11111` 保留用于指示 Fury 需要使用 Fury 无符号整数编码读取更多长度字节。注意，num_fields 是兼容字段的数量。用户可以使用标签 id 在模式一致性上下文中将某些字段标记为兼容字段。在这种情况下，模式一致性字段将首先被序列化，然后是兼容字段。在反序列化时，Fury 将使用那些未被标签 id 注释的字段信息来反序列化模式一致性字段，然后使用元数据中的字段信息来反序列化兼容字段。
- 第 6 位：0 表示通过 id 注册，1 表示通过名称注册。
- 剩余 2 位保留用于未来扩展。

##### 字段元数据

格式：

```
|   字段信息：可变字节    | 可变字节  | ... |
+---------------------------------+-----------------+-----+
| 头部 + 类型信息 + 字段名 | 下一个字段信息 | ... |
```

###### 字段头部

字段头部是 8 位，可以使用注解提供更具体的信息。如果注解不存在，fury 将自动推断这些信息。

字段头部的格式是：

```
2 位字段名编码 + 4 位大小 + 可空性标志 + 引用跟踪标志
```

详细规范：

- 2 位字段名编码：
  - 编码：`UTF8/ALL_TO_LOWER_SPECIAL/LOWER_UPPER_DIGIT_SPECIAL/TAG_ID`
  - 如果使用标签 id，字段名将由无符号 varint 标签 id 写入，2 位编码将是 `11`。
- 字段名的大小：
  - `4 位大小：0~14` 将用于指示长度 `1~15`，值 `15` 表示需要读取更多字节，编码将接下来编码 `size - 15` 为 varint。
  - 如果编码是 `TAG_ID`，则字段名的 num_bytes 将用于存储标签 id。
- 引用跟踪：设置为 1 时，将为此字段启用引用跟踪。
- 可空性：设置为 1 时，此字段可以为 null。 

###### 字段类型信息

字段类型信息写为无符号 int8。详细的 id 规范如下：

- 对于通过 id 注册的结构，它将是 `Type.STRUCT`。
- 对于通过名称注册的结构，它将是 `Type.NAMED_STRUCT`。
- 对于通过 id 注册的枚举，它将是 `Type.ENUM`。
- 对于通过名称注册的枚举，它将是 `Type.NAMED_ENUM`。
- 对于通过 id 注册的 ext 类型，它将是 `Type.EXT`。
- 对于通过名称注册的 ext 类型，它将是 `Type.NAMED_EXT`。
- 对于列表/集合类型，它将写为 `Type.LIST/SET`，然后递归写入元素类型。
- 对于一维基本类型数组，它将写为 `Type.XXX_ARRAY`。
- 对于每个维度具有相同大小的多维基本类型数组，它将写为 `Type.TENSOR`。
- 对于其他数组类型，它将写为 `Type.LIST`，然后递归写入元素类型。
- 对于映射类型，它将写为 `Type.MAP`，然后递归写入键和值类型。
- 对于 fury 直接支持的其他类型，它将是该类型的 fury 类型 id。
- 对于在编译时未确定的其他类型，写入 `Type.UNKNOWN`。对于此类类型，实际类型将在序列化此类字段值时写入。

多态性规范：

- `struct/named_struct/ext/named_ext` 被视为多态，这些类型的元数据被单独写入，而不是内联在此处，以减少元数据空间成本（如果此类型的对象在当前对象图中多次序列化，并且字段值也可能为 null）。
- `enum` 被视为态射，如果反序列化没有此字段，或者类型不是枚举，则将跳过枚举值。
- `list/map/set` 被视为态射，当序列化这些类型的值时，不会再次写入具体类型。
- fury 支持的其他类型也被视为态射。

列表/集合/映射嵌套类型规范：

- `list`：`| 列表类型 id | 嵌套类型 id << 2 + 可空性标志 + 引用跟踪标志 | ... 多层类型信息 |`
- `set`：`| 集合类型 id | 嵌套类型 id << 2 + 可空性标志 + 引用跟踪标志 | ... 多层类型信息 |`
- `map`：`| 集合类型 id | 键类型信息 | 值类型信息 |`
  - 键类型格式：`| 嵌套类型 id << 2 + 可空性标志 + 引用跟踪标志 | ... 多层类型信息 |`
  - 值类型格式：`| 嵌套类型 id << 2 + 可空性标志 + 引用跟踪标志 | ... 多层类型信息 |`

###### 字段名

如果设置了标签 id，将使用标签 id。否则，将写入字段名的元字符串。

###### 字段顺序

字段顺序作为实现细节留下，不向规范公开，反序列化需要根据 Fury 字段排序算法对字段进行重新排序。通过这种方式，fury 可以计算字段名称或类型的统计信息，并使用更紧凑的编码。

## 支持继承的扩展类型元数据

如果希望支持结构的继承，可以实现以下规范。

### 模式一致性

字段从父类型序列化到叶类型。字段使用 fury 结构字段排序算法进行排序。

### 模式演进

模式演进模式的元数据布局：

```
|    8 字节头部    | 可变字节 | 可变字节 |   可变字节   |   可变字节   |
+----------------------+----------------+----------------+--------------------+--------------------+
| 全局二进制头部 |  元数据头部   |  字段元数据   | 父元数据头部 | 父字段元数据 |
```

#### 元数据头部

元数据头部是一个以小端序编码的 64 位数值。

- 最低 4 位 `0b0000~0b1110` 用于记录类的数量。`0b1111` 保留用于指示 Fury 需要使用 Fury 无符号整数编码读取更多字节的长度。如果当前类型没有父类型，或者父类型没有要序列化的字段，或者我们在只序列化当前类型字段的上下文中，类的数量将是 1。
- 第 5 位用于指示此类型是否需要模式演进。
- 其他 56 位用于存储 `flags + 所有层类型元数据` 的唯一哈希值。

#### 单层类型元数据

```
| 无符号 varint | var uint |  字段信息：可变字节   | 可变字节  | ... |
+-----------------+----------+-------------------------------+-----------------+-----+
|   num_fields    | 类型 id  | 头部 + 类型 id + 字段名 | 下一个字段信息 | ... |
```

#### 其他层类型元数据

编码算法与前一层相同。

## 元字符串

元字符串主要用于编码元数据字符串，如字段名。

### 编码算法

字符串二进制编码算法：

| 算法                    | 模式          | 描述                                                                                                                                                                                                                                                                              |
|------------------------|---------------|-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n| LOWER_SPECIAL          | `a-z._$\\|`    | 每个字符使用 5 位写入，`a-z`：`0b00000~0b11001`，`._$\\|`：`0b11010~0b11101`，在开始处添加一个位以指示是否剪掉最后一个字符，因为最后一个字节可能有 7 个冗余位（1 表示剪掉最后一个字符）                                                                                             |\n| LOWER_UPPER_DIGIT_SPECIAL | `a-zA-Z0~9._` | 每个字符使用 6 位写入，`a-z`：`0b00000~0b11001`，`A-Z`：`0b11010~0b110011`，`0~9`：`0b110100~0b111101`，`._`：`0b111110~0b111111`，在开始处添加一个位以指示是否剪掉最后一个字符，因为最后一个字节可能有 7 个冗余位（1 表示剪掉最后一个字符） |\n| UTF-8                  | 任何字符       | UTF-8 编码                                                                                                                                                                                                                                                                       |

编码标志：

| 编码标志                 | 模式                                                           | 编码算法                                                                                                                                                  |\n|------------------------|----------------------------------------------------------------|-----------------------------------------------------------------------------------------------------------------------------------------------------------|\n| LOWER_SPECIAL          | 每个字符都在 `a-z._\\|` 中                                     | `LOWER_SPECIAL`                                                                                                                                             |\n| FIRST_TO_LOWER_SPECIAL | 每个字符都在 `a-z._` 中，除了首字符是大写                   | 替换首个大写字符为小写，然后使用 `LOWER_SPECIAL`                                                                                                            |\n| ALL_TO_LOWER_SPECIAL   | 每个字符都在 `a-zA-Z._` 中                                  | 用 `\\|` + `小写字符` 替换每个大写字符，然后使用 `LOWER_SPECIAL`，如果它比编码 `LOWER_UPPER_DIGIT_SPECIAL` 更小则使用此编码                                   |\n| LOWER_UPPER_DIGIT_SPECIAL | 每个字符都在 `a-zA-Z._` 中                                  | 如果它比编码 `FIRST_TO_LOWER_SPECIAL` 更小，则使用 `LOWER_UPPER_DIGIT_SPECIAL` 编码                                                                          |\n| UTF8                   | 任何 utf-8 字符                                                | 使用 `UTF-8` 编码                                                                                                                                           |\n| Compression            | 任何 utf-8 字符                                                | 无损压缩                                                                                                                                                    |

注意：

- 根据情况，可以选择联合编码 `标志 + 数据`，使用第一个字节的 3 位作为标志，其他字节作为数据。 

## 值格式

### 基本类型

#### bool

- 大小：1 字节
- 格式：0 表示 `false`，1 表示 `true`

#### int8

- 大小：1 字节
- 格式：作为纯字节写入。

#### int16

- 大小：2 字节
- 字节序：小端序的原始字节

#### 无符号 int32

- 大小：4 字节
- 字节序：小端序的原始字节

#### 无符号 varint32

- 大小：1~5 字节
- 格式：每个字节中的最高有效位（MSB）指示是否有下一个字节。如果第一位被设置，即 `b & 0x80 == 0x80`，则应该读取下一个字节，直到下一个字节的第一位未设置。

#### 有符号 int32

- 大小：4 字节
- 字节序：小端序的原始字节

#### 有符号 varint32

- 大小：1~5 字节
- 格式：首先通过 `(v << 1) ^ (v >> 31)` ZigZag 算法将数字转换为正无符号整数，然后将其编码为无符号 varint。

#### 无符号 int64

- 大小：8 字节
- 字节序：小端序的原始字节

#### 无符号 varint64

- 大小：1~9 字节
- Fury SLI（Small long as int）编码：
  - 如果长整数在 `[0, 2147483647]` 范围内，编码为 4 字节整数：`| 小端序：((int) value) << 1 |`
  - 否则写为 9 字节：`| 0b1 | 小端序 8 字节长整数 |`
- Fury PVL（Progressive Variable-length Long）编码：
  - 正长整数格式：每个字节中的第一位指示是否有下一个字节。如果第一位被设置，即 `b & 0x80 == 0x80`，则应该读取下一个字节，直到第一位未设置。

#### 有符号 int64

- 大小：8 字节
- 字节序：小端序的原始字节

#### 有符号 varint64

- 大小：1~9 字节
- Fury SLI（Small long as int）编码：
  - 如果长整数在 `[-1073741824, 1073741823]` 范围内，编码为 4 字节整数：`| 小端序：((int) value) << 1 |`
  - 否则写为 9 字节：`| 0b1 | 小端序 8 字节长整数 |`
- Fury PVL（Progressive Variable-length Long）编码：
  - 首先通过 `(v << 1) ^ (v >> 63)` ZigZag 算法将数字转换为正无符号长整数，以减少小负数的成本，然后将其编码为无符号长整数。

#### float32

- 大小：4 字节
- 格式：根据 IEEE 754 浮点"单精度格式"位布局对指定的浮点值进行编码，保留非数字（NaN）值，然后按小端序写入二进制。

#### float64

- 大小：8 字节
- 格式：根据 IEEE 754 浮点"双精度格式"位布局对指定的浮点值进行编码，保留非数字（NaN）值。然后按小端序写入二进制。

### 字符串

格式：

```
| 无符号 varint64：大小 << 2 `bitor` 2 位编码标志 | 二进制数据 |
```

- `大小 + 编码` 将连接为一个长整数并编码为无符号 varint64。小 2 位用于编码：0 表示 `latin1(ISO-8859-1)`，1 表示 `utf-16`，2 表示 `utf-8`。
- 基于编码的编码字符串二进制数据：`latin/utf-16/utf-8`。

如何选择编码：

- 对于 JDK8：fury 在运行时检测 `latin`，如果字符串是 `latin` 字符串，则使用 `latin` 编码，否则使用 `utf-16`。
- 对于 JDK9+：fury 使用 `String` 对象中的 `coder` 进行编码，将使用 `latin`/`utf-16` 进行编码。
- 如果字符串由 `utf-8` 编码，则 fury 将使用 `utf-8` 解码数据。fury 的跨语言字符串序列化默认使用 `utf-8`。

### 列表

格式：

```
| 无符号 varint64：长度 | 1 字节元素头部 | 元素数据 |
```

#### 元素头部

在大多数情况下，所有元素都是相同类型且非空的，元素头部将编码这些同质信息，以避免为每个元素写入它的成本。具体来说，有四种信息将由元素头部编码，每种使用一位：

- 如果跟踪元素引用，使用头部的第一位 `0b1` 来标记它。
- 如果元素有空值，使用头部的第二位 `0b10` 来标记它。如果为此元素类型启用了引用跟踪，此标志无效。
- 如果元素类型不是声明类型，使用头部的第三位 `0b100` 来标记它。
- 如果元素类型不同，使用头部的第四位 `0b1000` 来标记它。

默认情况下，所有位都未设置，这意味着所有元素都不会跟踪引用，所有元素都是相同类型，非空，并且实际元素是自定义类型字段中声明的类型。

实现可以根据读取的头部生成不同的反序列化代码，并从线性映射/列表中查找生成的代码。

#### 元素数据

基于元素头部，元素数据的序列化可能会跳过 `引用标志`/`空标志`/`元素类型信息`。

```python
fury = ...
buffer = ...
elems = ...
if element_type_is_same:
    if not is_declared_type:
        fury.write_type(buffer, elem_type)
    elem_serializer = get_serializer(...)
    if track_ref:
        for elem in elems:
            if not ref_resolver.write_ref_or_null(buffer, elem):
                elem_serializer.write(buffer, elem)
    elif has_null:
        for elem in elems:
            if elem is None:
                buffer.write_byte(null_flag)
            else:
                buffer.write_byte(not_null_flag)
                elem_serializer.write(buffer, elem)
    else:
        for elem in elems:
            elem_serializer.write(buffer, elem)
else:
    if track_ref:
        for elem in elems:
            fury.write_ref(buffer, elem)
    elif has_null:
        for elem in elems:
            fury.write_nullable(buffer, elem)
    else:
        for elem in elems:
            fury.write_value(buffer, elem)
```

[`CollectionSerializer#writeElements`](https://github.com/apache/fury/blob/20a1a78b17a75a123a6f5b7094c06ff77defc0fe/java/fury-core/src/main/java/org/apache/fury/serializer/collection/AbstractCollectionSerializer.java#L302) 可以作为示例。

### 数组

#### 基本类型数组

基本类型数组被视为二进制缓冲区，序列化只会将数组大小的长度写为无符号整数，然后将整个缓冲区复制到流中。

这种序列化不会压缩数组。如果用户想要压缩基本类型数组，用户需要为此类类型注册自定义序列化器或将其标记为列表类型。

#### 张量

张量是一种特殊的原始多维数组，所有维度具有相同的大小和类型。序列化格式是：

```
| num_dims（无符号 varint）| shape[0]（无符号 varint）| shape[...] | shape[N] | 元素类型 | 数据 |
```

数据是连续的以减少复制，并且在某些情况下可能实现零复制。

#### 对象数组

对象数组使用列表格式序列化。对象组件类型将被视为列表元素泛型类型。

### 映射

映射使用基于块的格式：

```
| 长度（无符号 varint）| 键值块数据 | ... | 键值块数据 |
```

#### 映射键值块数据

映射迭代成本太高，Fury 不会像列表那样计算头部，因为它会引入[相当大的开销](https://github.com/apache/fury/issues/925)。
用户可以使用 `MapFieldInfo` 注解提前提供头部。否则，Fury 将乐观地使用第一个键值对来预测头部，如果预测在某些对中失败，则更新块头部。

Fury 将按块序列化映射，每个块最多有 255 对。

```
|    1 字节      |     1 字节     | 可变字节  |
+----------------+----------------+-----------------+
|    KV 头部     | 块大小：N      |   N*2 个对象   |
```

KV 头部：

- 如果跟踪键引用，使用头部的第一位 `0b1` 来标记它。
- 如果键有空值，使用头部的第二位 `0b10` 来标记它。如果为此键类型启用了引用跟踪，此标志无效。
- 如果映射的实际键类型不是声明的键类型，使用头部的第三位 `0b100` 来标记它。
- 如果跟踪值引用，使用头部的第四位 `0b1000` 来标记它。
- 如果值有空值，使用头部的第五位 `0b10000` 来标记它。如果为此值类型启用了引用跟踪，此标志无效。
- 如果映射的值类型不是声明的值类型，使用头部的第六位 `0b100000` 来标记它。
- 如果键或值为空，那么该键和值将作为单独的块写入，并且块大小写入也将被跳过。

如果启用了流式写入，这意味着 Fury 不能更新已写入的 `块大小`。在这种情况下，映射键值数据格式将是：

```
|    1 字节      | 可变字节  |
+----------------+-----------------+
|    KV 头部     |   N*2 个对象   |
```

`KV 头部` 将是 java 中由 `MapFieldInfo` 标记的头部。对于诸如 golang 之类的语言，大多数情况下可以为非接口类型提前计算。实现可以根据读取的头部生成不同的反序列化代码，并从线性映射/列表中查找生成的代码。

#### 为什么按块序列化？

当 fury 乐观地使用第一个键值对来预测头部时，它无法知道有多少对具有相同的元数据（跟踪 kef ref、键是否为空等等）。如果我们不按最大块大小逐块写入，我们必须至少写入 `X` 个字节来为以后更新具有相同元素的数量留出位置，`X` 是编码映射大小的 varint 编码的字节数。

而且大多数映射大小都小于 255，如果所有对具有相同的数据，则块将是 1。这在 golang/rust 中很常见，其中对象默认不是引用的。

此外，如果只有一个或两个键具有不同的元数据，我们可以将其放入不同的块中，以便大多数对可以共享元数据。

实现可以通过映射大小累积读取计数来决定是否读取更多块。

### 枚举

枚举被序列化为无符号 var int。如果枚举值的顺序发生变化，反序列化的枚举值可能不是用户期望的值。在这种情况下，用户必须通过使其将枚举值写为禁用唯一哈希的枚举字符串来注册枚举序列化器。

### 十进制

目前不支持。

### 结构

结构指的是 `class/pojo/struct/bean/record` 类型的对象。
结构将通过按 fury 顺序写入其字段数据来序列化。

根据模式兼容性，结构将有不同的格式。

#### 字段顺序

字段将按如下排序，每组字段都有自己的顺序：

- 基本类型字段：
  - 大小类型先，小型后，可变大小类型最后。
  - 大小相同时，按类型 id 排序
  - 大小和类型 id 相同时，按蛇形命名法字段名排序
  - 类型：bool/int8/int16/int32/varint32/int64/varint64/sliint64/float16/float32/float64
- 可空基本类型字段：与基本类型字段相同的顺序
- 态射字段：相同类型在一起，然后按蛇形命名法字段名按字典序排序。
- 未知字段：与态射字段相同的排序算法
- 列表字段：与态射字段相同的排序算法
- 集合字段：与态射字段相同的排序算法
- 映射字段：与态射字段相同的排序算法

#### 字段顺序

结构中的字段按升序排序：

- 基本类型字段优先：bool/int8/int16/int32/varint32/int64/varint64/sliint64/float16/float32/float64，按类型 id 排序。
- 可空基本类型字段
- 除 `list/set/map` 外的态射类型
- 未知类型
- 列表类型
- 集合类型
- 映射类型

如果两个字段具有相同类型，则按 snake_case 样式的字段名排序。

#### 模式一致性

对象将写为：

```
|    4 字节     |  可变字节  |
+---------------+------------------+
|   类型哈希   |   字段值   |
```

类型哈希用于检查跨语言的类型模式一致性。类型哈希将是类型元数据的 56 位值的前 32 位。

对象字段将一个接一个地使用以下格式序列化：

```
非空基本字段值：
|   可变字节    |
+----------------+
|   值数据      |
+----------------+
可空基本字段值：
| 一个字节  |   可变字节   |
+-----------+---------------+
| 空值标志  |  字段值       |
+-----------+---------------+
具有引用跟踪的 final 类型字段值：
| 可变字节 | 可变对象 |
+-----------+-------------+
| 引用元数据 | 值数据   |
+-----------+-------------+
不具有引用跟踪的 final 类型字段值：
| 一个字节  | 可变对象 |
+-----------+-------------+
| 空值标志  | 字段值    |
+-----------+-------------+
具有引用跟踪的非 final 类型字段值：
| 一个字节  | 可变字节 | 可变对象 |
+-----------+-------------+-------------+
| 引用元数据 | 类型元数据  | 值数据   |
+-----------+-------------+-------------+
不具有引用跟踪的非 final 类型字段值：
| 一个字节  | 可变字节 | 可变对象 |
+-----------+------------+------------+
| 空值标志  | 类型元数据  | 值数据   |
+-----------+------------+------------+
```

#### 模式演进

模式演进对对象的格式与模式一致性模式相似，除了：

- 对于对象类型，`模式一致性` 模式将仅通过 id 写入类型，但 `模式演进` 模式也将写入包含字段名称、类型和其他元数据的类型，参见[类型元数据](#类型元数据)。
- `final 自定义类型` 的类型元数据也需要写入，因为对等方可能没有定义此类型。

### 类型

类型将使用类型元数据格式序列化。

## 实现指南

### 如何减少内存读/写代码

- 尝试在写入之前将多个字节合并为一个 int/long 写入，以减少内存 IO 和边界检查成本。
- 将多个字节作为一个 int/long 读取，然后分成多个字节，以减少内存 IO 和边界检查成本。
- 尝试使用一个 varint/long 来一起写入标志和长度，以节省一个字节成本并减少内存 io。
- 与内存 IO 成本相比，条件分支的成本较低，除非有太多分支。

### 不支持运行时代码生成的静态语言的快速反序列化

对于类型演进，序列化器会将类型元数据编码到序列化数据中。反序列化器会将此元数据与当前进程中的类元数据进行比较，并使用差异来确定如何反序列化数据。

对于 java/javascript/python，我们可以使用差异在运行时生成序列化器代码并将其作为类/函数加载以进行反序列化。通过这种方式，类型演进将与类型一致模式一样快。

对于 C++/Rust，我们无法在运行时生成序列化器代码。因此，我们需要使用元编程在编译时生成代码。但是在那时，我们不知道其他进程中的类型模式，因此我们无法为此类不一致的类型生成序列化器代码。我们可能需要生成具有循环并逐个比较字段名称以决定是反序列化和分配字段还是跳过字段值的代码。

一种快速的方法是我们可以将字符串比较优化为 `jump` 指令：

- 假设当前类型有 `n` 个字段，而对等类型有 `n1` 个字段。
- 在编译时为当前类型中的每个排序字段从 `0` 生成一个自动增长的 `field id`。
- 将接收到的类型元数据与当前类型进行比较，如果字段名相同则生成相同的 id，否则从 `n` 开始生成一个自动增长的 id，并在运行时缓存此元数据。
- 迭代接收到的类型元数据的字段，使用 `switch` 比较 `field id` 以反序列化数据并 `assign/skip` 字段值。**连续的** 字段 id 将在 `switch` 块中优化为 `jump`，因此它会非常快。

这是一个示例，假设进程 A 有一个版本为 1 的类 `Foo` 定义为 `Foo1`，进程 B 有一个版本为 2 的类 `Foo` 定义为 `Foo2`：

```c++
// class Foo with version 1
class Foo1 {
  int32_t v1; // id 0
  std::string v2; // id 1
};
// class Foo with version 2
class Foo2 {
  // id 0, but will have id 2 in process A
  bool v0;
  // id 1, but will have id 0 in process A
  int32_t v1;
  // id 2, but will have id 3 in process A
  int64_t long_value;
  // id 3, but will have id 1 in process A
  std::string v2;
  // id 4, but will have id 4 in process A
  std::vector<std::string> list;
};
```

当进程 A 从进程 B 接收到序列化的 `Foo2` 时，以下是它如何反序列化数据：

```c++
Foo1 foo1 = ...;
const std::vector<fury::FieldInfo> &field_infos = type_meta.field_infos;
for (const auto &field_info : field_infos) {
  switch (field_info.field_id) {
    case 0:
      foo1.v1 = buffer.read_varint32();
      break;
    case 1:
      foo1.v2 = fury.read_string();
      break;
    default:
      fury.skip_data(field_info);
  }
}
```
