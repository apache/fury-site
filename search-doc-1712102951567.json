{"searchDocs":[{"title":"Fury v0.1.0 released","type":0,"sectionRef":"#","url":"/blog/fury_0_1_0_release","content":"","keywords":"","version":null},{"title":"New Contributors​","type":1,"pageTitle":"Fury v0.1.0 released","url":"/blog/fury_0_1_0_release#new-contributors","content":" @wangweipeng2 made their first contribution in https://github.com/alipay/fury/pull/215@rainsonGain made their first contribution in https://github.com/alipay/fury/pull/429@leeco-cloud made their first contribution in https://github.com/alipay/fury/pull/436@dependabot made their first contribution in https://github.com/alipay/fury/pull/590@tisonkun made their first contribution in https://github.com/alipay/fury/pull/762@hieu-ht made their first contribution in https://github.com/alipay/fury/pull/786@s31k31 made their first contribution in https://github.com/alipay/fury/pull/782  ","version":null,"tagName":"h2"},{"title":"What's Changed​","type":1,"pageTitle":"Fury v0.1.0 released","url":"/blog/fury_0_1_0_release#whats-changed","content":" Create pull_request_template.md by @chaokunyang in https://github.com/alipay/fury/pull/2add apache licence file by @chaokunyang in https://github.com/alipay/fury/pull/3[Java] add java code structure by @chaokunyang in https://github.com/alipay/fury/pull/4[Java] add java code formatter by @chaokunyang in https://github.com/alipay/fury/pull/5[Java] Add licence to file header by @chaokunyang in https://github.com/alipay/fury/pull/6[Docs] add fury debug doc by @chaokunyang in https://github.com/alipay/fury/pull/8[Docs] refine readme by fix syntax error by @chaokunyang in https://github.com/alipay/fury/pull/10[Community] add getting involved document by @chaokunyang in https://github.com/alipay/fury/pull/12[Java] add java ci by @chaokunyang in https://github.com/alipay/fury/pull/14[Java] fix license format conflict with checkstyle by @chaokunyang in https://github.com/alipay/fury/pull/16[Java] Add unsafe memory util by @chaokunyang in https://github.com/alipay/fury/pull/18[Java] add tuple2/tuple3 utils by @chaokunyang in https://github.com/alipay/fury/pull/20[Java] add LoggerFactory for disable logging more easily by @chaokunyang in https://github.com/alipay/fury/pull/22[Java] add string utils by @chaokunyang in https://github.com/alipay/fury/pull/24[Java] add memory read/write utils by @chaokunyang in https://github.com/alipay/fury/pull/26[Community] update slack invite link by @chaokunyang in https://github.com/alipay/fury/pull/27[Java] add cross-language type id by @chaokunyang in https://github.com/alipay/fury/pull/35[Java] Add api annotation to mark api stability by @chaokunyang in https://github.com/alipay/fury/pull/37[Java] add int array to avoid box cost by @chaokunyang in https://github.com/alipay/fury/pull/39[Java] add auto-growing object array by @chaokunyang in https://github.com/alipay/fury/pull/41[Java] Add optimized map for faster lookup by @chaokunyang in https://github.com/alipay/fury/pull/43[Java] add basic type inference support by @chaokunyang in https://github.com/alipay/fury/pull/45[Java] Add long map support by @chaokunyang in https://github.com/alipay/fury/pull/47[Java] add fury exceptions by @chaokunyang in https://github.com/alipay/fury/pull/48[Java] add MurmurHash3 support by @chaokunyang in https://github.com/alipay/fury/pull/50[Java] add Reflection support by @chaokunyang in https://github.com/alipay/fury/pull/52add FieldAccessor and fields compare by @chaokunyang in https://github.com/alipay/fury/pull/54[Java] implement basic compiler backend based on janino by @chaokunyang in https://github.com/alipay/fury/pull/56[Java] Add extensible classloaders by @chaokunyang in https://github.com/alipay/fury/pull/58[Java] Support multi key weak map by @chaokunyang in https://github.com/alipay/fury/pull/60[Java] codegen framework for fury java jit by @chaokunyang in https://github.com/alipay/fury/pull/61[Java] add utility for lambda functions by @chaokunyang in https://github.com/alipay/fury/pull/63[Java] add common expression ir for programing construct by @chaokunyang in https://github.com/alipay/fury/pull/64[Java] fix if expression with return child node by @chaokunyang in https://github.com/alipay/fury/pull/66[Java] add expression tree traverser and updater by @chaokunyang in https://github.com/alipay/fury/pull/68[Java] add missing author java odc by @chaokunyang in https://github.com/alipay/fury/pull/69[Java] add enum string resolver support by @chaokunyang in https://github.com/alipay/fury/pull/72[Java] add reference tracking support by @chaokunyang in https://github.com/alipay/fury/pull/74[Java] add java serializer interface by @chaokunyang in https://github.com/alipay/fury/pull/76[Java] add test utils by @chaokunyang in https://github.com/alipay/fury/pull/77[Java] add generics hierarchy resolving support by @chaokunyang in https://github.com/alipay/fury/pull/79[Java] add serialization context to relate serializing different objects by @chaokunyang in https://github.com/alipay/fury/pull/82[Java] add class info util by @chaokunyang in https://github.com/alipay/fury/pull/83[Java] add buffer callback by @chaokunyang in https://github.com/alipay/fury/pull/87[Java] implement basic java serialization framework by @chaokunyang in https://github.com/alipay/fury/pull/88[Java] Add string serializer by @chaokunyang in https://github.com/alipay/fury/pull/90[Java] add string builder/buffer serializers by @chaokunyang in https://github.com/alipay/fury/pull/93[Java] add missing uint serializers tests by @chaokunyang in https://github.com/alipay/fury/pull/95[Java] Implement enum serialization for java by @chaokunyang in https://github.com/alipay/fury/pull/97[Java] Implement bigint/decimal serialization for java by @chaokunyang in https://github.com/alipay/fury/pull/101[Community] add zhihu link by @chaokunyang in https://github.com/alipay/fury/pull/103[Community] fix zhihu link by @chaokunyang in https://github.com/alipay/fury/pull/104[Community] update slack desc by @chaokunyang in https://github.com/alipay/fury/pull/105[Java] Add object array serializer by @chaokunyang in https://github.com/alipay/fury/pull/107[Java] Implement primitive array serializers by @chaokunyang in https://github.com/alipay/fury/pull/109[Java] support serializing byte buffer by @chaokunyang in https://github.com/alipay/fury/pull/113[Java] support serializing java.util.concurrent.atomics by @chaokunyang in https://github.com/alipay/fury/pull/115[Java] move string array serializers by @chaokunyang in https://github.com/alipay/fury/pull/116[Java] support Currency serialization by @chaokunyang in https://github.com/alipay/fury/pull/118[Java] support charset serialization by @chaokunyang in https://github.com/alipay/fury/pull/120[Java] support URI serialization by @chaokunyang in https://github.com/alipay/fury/pull/122[Java] add support for regex serialization by @chaokunyang in https://github.com/alipay/fury/pull/124[Java] support uuid serialization by @chaokunyang in https://github.com/alipay/fury/pull/126[Java] add class serialization test by @chaokunyang in https://github.com/alipay/fury/pull/127[Java] add Locale Serializer support by @chaokunyang in https://github.com/alipay/fury/pull/129[Java] fix LocaleSerializer cache thread safety by @chaokunyang in https://github.com/alipay/fury/pull/132[Java] serialization support for java.util.OptionalXXX by @chaokunyang in https://github.com/alipay/fury/pull/134[Java] Add time serializers by @chaokunyang in https://github.com/alipay/fury/pull/137[Java] add ObjectInput/Output based on fury by @chaokunyang in https://github.com/alipay/fury/pull/139[Java] add JavaSerializer based on ObjectInputStream/ObjectOutputStream by @chaokunyang in https://github.com/alipay/fury/pull/141[Java] implement jdk proxy serialization by @chaokunyang in https://github.com/alipay/fury/pull/143[Java] implement Externalizable serialization by @chaokunyang in https://github.com/alipay/fury/pull/145[Java] implement Collection serialization by @chaokunyang in https://github.com/alipay/fury/pull/147[Java] add sortedset serializer by @chaokunyang in https://github.com/alipay/fury/pull/149[Java] add empty collection serializer by @chaokunyang in https://github.com/alipay/fury/pull/151[Java] add single collection serializers by @chaokunyang in https://github.com/alipay/fury/pull/153[Java] add ConcurrentSkipListSet serializer by @chaokunyang in https://github.com/alipay/fury/pull/155[Java] add java.util.Vector serializer by @chaokunyang in https://github.com/alipay/fury/pull/157[Java] add java.util.ArrayDeque serializer by @chaokunyang in https://github.com/alipay/fury/pull/159[Java] add java.util.EnumSet serializer by @chaokunyang in https://github.com/alipay/fury/pull/161[Java] implement java.util.BitSet serializer by @chaokunyang in https://github.com/alipay/fury/pull/163[Java] implement java.util.PriorityQueue serialization by @chaokunyang in https://github.com/alipay/fury/pull/165[Java] implement map serialization framework by @chaokunyang in https://github.com/alipay/fury/pull/167[Java] support java.util.SortedMap serialization by @chaokunyang in https://github.com/alipay/fury/pull/169[Java] support empty map serialization by @chaokunyang in https://github.com/alipay/fury/pull/171[Java] implement singleton map serialization by @chaokunyang in https://github.com/alipay/fury/pull/173[Java] support concurrent map serialization by @chaokunyang in https://github.com/alipay/fury/pull/175[Java] implement enum map serialization by @chaokunyang in https://github.com/alipay/fury/pull/177[Java] group and sort descriptors for cache and consistency by @chaokunyang in https://github.com/alipay/fury/pull/179[Java] Implement object serialization by @chaokunyang in https://github.com/alipay/fury/pull/181[Java] fury native lambda serialization for java by @chaokunyang in https://github.com/alipay/fury/pull/183Update feature_request.md by @chaokunyang in https://github.com/alipay/fury/pull/184Update bug_report.md by @chaokunyang in https://github.com/alipay/fury/pull/185Update bug_report.md by @chaokunyang in https://github.com/alipay/fury/pull/186[Java] Optimize Collections.synchronized serialization performance by @chaokunyang in https://github.com/alipay/fury/pull/188[Java] optimize unmodifiable serialization by @chaokunyang in https://github.com/alipay/fury/pull/191[Java] add native readResolve/writeReplace serialization support by @chaokunyang in https://github.com/alipay/fury/pull/193[Java] [1/N] support type forward/backward compatibility by @chaokunyang in https://github.com/alipay/fury/pull/196[Java] Add struct util to create test struct class dynamically by @chaokunyang in https://github.com/alipay/fury/pull/199Revert &quot;[Java] Add struct util to create test struct class dynamically&quot; by @chaokunyang in https://github.com/alipay/fury/pull/200[Java] Add struct util to create test struct class dynamically by @chaokunyang in https://github.com/alipay/fury/pull/201[Java][2/N] support type forward/backward compatibility by @chaokunyang in https://github.com/alipay/fury/pull/195[Java] Optimize subclass container serialization by @chaokunyang in https://github.com/alipay/fury/pull/205[Java] remove generated classes automatically by @chaokunyang in https://github.com/alipay/fury/pull/207[Java] implement collection serialization field by field by @chaokunyang in https://github.com/alipay/fury/pull/209[Java] implement java map serialization field by field by @chaokunyang in https://github.com/alipay/fury/pull/210[Java] optimize jdk compatible collection serializer by @chaokunyang in https://github.com/alipay/fury/pull/212[Java] support compatible map serialization by @chaokunyang in https://github.com/alipay/fury/pull/213[JavaScript] javascript of fury by @wangweipeng2 in https://github.com/alipay/fury/pull/215[JavaScript]Replace Nodejs lib by standard lib by @wangweipeng2 in https://github.com/alipay/fury/pull/217[JavaScript]Add test by @wangweipeng2 in https://github.com/alipay/fury/pull/219[JavaScript] Change package.json entry file by @wangweipeng2 in https://github.com/alipay/fury/pull/221Update feature_request.md by @chaokunyang in https://github.com/alipay/fury/pull/223[Java] implement fury-native jdk compatible object serialization by @chaokunyang in https://github.com/alipay/fury/pull/222[Java] Add class def for meta sharing by @chaokunyang in https://github.com/alipay/fury/pull/226[Java] Support meta shared serialization by @chaokunyang in https://github.com/alipay/fury/pull/225[Java] add missing license to ObjectStreamSerializer by @chaokunyang in https://github.com/alipay/fury/pull/228[Java] move loadClass to ClassUtils by @chaokunyang in https://github.com/alipay/fury/pull/229[javascript] add javascript ci by @chaokunyang in https://github.com/alipay/fury/pull/230Fix CI by @chaokunyang in https://github.com/alipay/fury/pull/232[Java] forbid classes serialization by blacklist by @chaokunyang in https://github.com/alipay/fury/pull/234[Java] generate field accessor on the flight by @chaokunyang in https://github.com/alipay/fury/pull/240[Java] expression optimizer for method split by @chaokunyang in https://github.com/alipay/fury/pull/241[JavaScript]Fix ci by @wangweipeng2 in https://github.com/alipay/fury/pull/242[Java] add codec builder base class by @chaokunyang in https://github.com/alipay/fury/pull/244[Java] add jdk serializable check by @chaokunyang in https://github.com/alipay/fury/pull/248[Java] add base object serializer builder by @chaokunyang in https://github.com/alipay/fury/pull/249[Java] Implement jit serialization for object by @chaokunyang in https://github.com/alipay/fury/pull/250[Java] Fix meta shared serializer when jit enabled by @chaokunyang in https://github.com/alipay/fury/pull/252Update bug_report.md by @chaokunyang in https://github.com/alipay/fury/pull/253[Java] type forward/backward compatible jit serializer by @chaokunyang in https://github.com/alipay/fury/pull/254[Java] Meta shared object jit serializer by @chaokunyang in https://github.com/alipay/fury/pull/255[Java] jit context for manage compilation by @chaokunyang in https://github.com/alipay/fury/pull/259[Java] fix javaFury thread safety by @chaokunyang in https://github.com/alipay/fury/pull/261[Java] set rootdir for maven multi-module project by @chaokunyang in https://github.com/alipay/fury/pull/263[Java] add guava immutable list serializer by @chaokunyang in https://github.com/alipay/fury/pull/264[Java] add guava immutable map serializer by @chaokunyang in https://github.com/alipay/fury/pull/266[Java] Async compilation for jit serializers by @chaokunyang in https://github.com/alipay/fury/pull/268[Java] add url serializer by @chaokunyang in https://github.com/alipay/fury/pull/269[Java] optimize java serialization by @chaokunyang in https://github.com/alipay/fury/pull/271[Java] bind fury with classloader by @chaokunyang in https://github.com/alipay/fury/pull/274[Java] add forward serializer by @chaokunyang in https://github.com/alipay/fury/pull/276[Java] add thread-safe fury serializer by @chaokunyang in https://github.com/alipay/fury/pull/278[Java] Add guava/sublist todo serializer by @chaokunyang in https://github.com/alipay/fury/pull/282[Java] add zero-copy tests by @chaokunyang in https://github.com/alipay/fury/pull/284[Java] Profiling fury init by @chaokunyang in https://github.com/alipay/fury/pull/286[Java] add complex cyclic tests by @chaokunyang in https://github.com/alipay/fury/pull/288[Java] enable testArrayStructZeroCopy by @chaokunyang in https://github.com/alipay/fury/pull/290[Java] add complex collection struct tests by @chaokunyang in https://github.com/alipay/fury/pull/292[Java] add complex map struct tests by @chaokunyang in https://github.com/alipay/fury/pull/294[Java] misc serializer tests by @chaokunyang in https://github.com/alipay/fury/pull/295[Java] optimize time reference by @chaokunyang in https://github.com/alipay/fury/pull/297[Java] add unsafe accessor test for duplicate fields by @chaokunyang in https://github.com/alipay/fury/pull/299[Java] add serializer factory test by @chaokunyang in https://github.com/alipay/fury/pull/301[Java] add duplicate fields tests by @chaokunyang in https://github.com/alipay/fury/pull/303[Java] add protocol interoperability tests by @chaokunyang in https://github.com/alipay/fury/pull/305[Java] Lazy map support by @chaokunyang in https://github.com/alipay/fury/pull/307[Java] Support deserialize unexisted classes by @chaokunyang in https://github.com/alipay/fury/pull/309[Java] fix OutOfBandTest pkg by @chaokunyang in https://github.com/alipay/fury/pull/310javascript latin1 string performance improvement by @wangweipeng2 in https://github.com/alipay/fury/pull/312[Java] Add row format interface by @chaokunyang in https://github.com/alipay/fury/pull/316[Java] add Default arrow type visitor by @chaokunyang in https://github.com/alipay/fury/pull/318[Java] add decimal util by @chaokunyang in https://github.com/alipay/fury/pull/320[Java] add pyarrow style data types API in java by @chaokunyang in https://github.com/alipay/fury/pull/322[Java] add fury InputStream/OutputStream by @chaokunyang in https://github.com/alipay/fury/pull/324[Java] Infer arrow schema for java bean by @chaokunyang in https://github.com/alipay/fury/pull/326[Java] add bitmap utils by @chaokunyang in https://github.com/alipay/fury/pull/328[Java] binary row format data structure by @chaokunyang in https://github.com/alipay/fury/pull/330[Java] binary row format writer by @chaokunyang in https://github.com/alipay/fury/pull/333[Java] add arrow visitor for value accessor by @chaokunyang in https://github.com/alipay/fury/pull/335[Java] add row format tests by @chaokunyang in https://github.com/alipay/fury/pull/337[Java] add row format encoder interface by @chaokunyang in https://github.com/alipay/fury/pull/339[Java] Base builder for building jit encoder by @chaokunyang in https://github.com/alipay/fury/pull/341[Java] add jit-based row encoder implementation by @chaokunyang in https://github.com/alipay/fury/pull/343[Java] format code by @chaokunyang in https://github.com/alipay/fury/pull/344[Java] add missing license by @chaokunyang in https://github.com/alipay/fury/pull/345[Java] Add fury channel by @chaokunyang in https://github.com/alipay/fury/pull/346[Java] Mock io for count bytes by @chaokunyang in https://github.com/alipay/fury/pull/349[Java] Arrow record batch zero-copy serializers by @chaokunyang in https://github.com/alipay/fury/pull/351[Java] Add missing license by @chaokunyang in https://github.com/alipay/fury/pull/352[Java] optimize decimal encoding performance by @chaokunyang in https://github.com/alipay/fury/pull/354[Java] optimize schema creation perf by @chaokunyang in https://github.com/alipay/fury/pull/356[Java] update row javadoc by @chaokunyang in https://github.com/alipay/fury/pull/357[Java] Support convert row to arrow format by @chaokunyang in https://github.com/alipay/fury/pull/359[Java] add arrow serializers tests by @chaokunyang in https://github.com/alipay/fury/pull/361[Java] fix arrow tests by @chaokunyang in https://github.com/alipay/fury/pull/362[Java] add serialize to buffer tests by @chaokunyang in https://github.com/alipay/fury/pull/364[Java] add basic cross-langauge serialization tests by @chaokunyang in https://github.com/alipay/fury/pull/366[Java] add serializeBeanTest by @chaokunyang in https://github.com/alipay/fury/pull/367[Java] add registerTest by @chaokunyang in https://github.com/alipay/fury/pull/368[Java] add testTreeMap by @chaokunyang in https://github.com/alipay/fury/pull/369[Java] add offheap tests by @chaokunyang in https://github.com/alipay/fury/pull/371[Java] refine classresovler tests by @chaokunyang in https://github.com/alipay/fury/pull/373[Java] add private bean tests by @chaokunyang in https://github.com/alipay/fury/pull/375[Java] add blocking queue test by @chaokunyang in https://github.com/alipay/fury/pull/377[Java] add duplicate fields test by @chaokunyang in https://github.com/alipay/fury/pull/378[Java] add guava tests by @chaokunyang in https://github.com/alipay/fury/pull/381[Java] add test for jdk serializable check by @chaokunyang in https://github.com/alipay/fury/pull/383[Java] add secure mode test by @chaokunyang in https://github.com/alipay/fury/pull/385[Java] ensure fury doesn't introduce class leak by @chaokunyang in https://github.com/alipay/fury/pull/387[Java] add tests for ignoring fields by @chaokunyang in https://github.com/alipay/fury/pull/389[Java] add thread to blacklist by @chaokunyang in https://github.com/alipay/fury/pull/391[Java] Add complex testsuite by @chaokunyang in https://github.com/alipay/fury/pull/393[Java] add benchmark framework by @chaokunyang in https://github.com/alipay/fury/pull/399[Java] add plotting tool by @chaokunyang in https://github.com/alipay/fury/pull/400[Java] add usertype benchmarks by @chaokunyang in https://github.com/alipay/fury/pull/401[Java] Add string benchmarks by @chaokunyang in https://github.com/alipay/fury/pull/403[Java] add array benchmark by @chaokunyang in https://github.com/alipay/fury/pull/405[Java] add map benchmark by @chaokunyang in https://github.com/alipay/fury/pull/409[Java] add memory benchmark by @chaokunyang in https://github.com/alipay/fury/pull/410[Java] add row format benchmark by @chaokunyang in https://github.com/alipay/fury/pull/411[Java] add zero copy benchmark by @chaokunyang in https://github.com/alipay/fury/pull/413[Java] Add flatbufffer/protobuffer benchmarks by @chaokunyang in https://github.com/alipay/fury/pull/415[Java] update integration_tests readme by @chaokunyang in https://github.com/alipay/fury/pull/416[C++] generate arrow bazel depdencies from pyarrow bundled shared library by @chaokunyang in https://github.com/alipay/fury/pull/418[C++] Add bazel C++ build support by @chaokunyang in https://github.com/alipay/fury/pull/420[C++] add c++ logging util by @chaokunyang in https://github.com/alipay/fury/pull/423[C++] add cpp status util by @chaokunyang in https://github.com/alipay/fury/pull/425[C++] basic util for bytes operations by @chaokunyang in https://github.com/alipay/fury/pull/427Update bug_report.md by @chaokunyang in https://github.com/alipay/fury/pull/430[Java] register class check duplciate id by @chaokunyang in https://github.com/alipay/fury/pull/432[Java] move ExpressionOptimizer into codegen package by @chaokunyang in https://github.com/alipay/fury/pull/433Format/container encoder by @rainsonGain in https://github.com/alipay/fury/pull/429[Java] Thread-safe fury implementation by pooling by @leeco-cloud in https://github.com/alipay/fury/pull/436[C++] Add c++ buffer util by @chaokunyang in https://github.com/alipay/fury/pull/438[CI] fix CI by @chaokunyang in https://github.com/alipay/fury/pull/439[C++] Binary row format for c++ by @chaokunyang in https://github.com/alipay/fury/pull/441[C++] C++ row format to arrow by @chaokunyang in https://github.com/alipay/fury/pull/442[C++] Add c++ ci by @chaokunyang in https://github.com/alipay/fury/pull/444[CI] Add code lint ci job by @chaokunyang in https://github.com/alipay/fury/pull/446[Doc] Add c++ debugging doc by @chaokunyang in https://github.com/alipay/fury/pull/448[Python] [1/n] Fury python binding by @chaokunyang in https://github.com/alipay/fury/pull/450[python] Type infer for python by @chaokunyang in https://github.com/alipay/fury/pull/458[Java] skip checkstyle in java test by @chaokunyang in https://github.com/alipay/fury/pull/459[Python] Fix python ci by @chaokunyang in https://github.com/alipay/fury/pull/461[Python] Python row format by @chaokunyang in https://github.com/alipay/fury/pull/463[Python] Python encoder for row format by @chaokunyang in https://github.com/alipay/fury/pull/466[Python] Row and arrow format converter by @chaokunyang in https://github.com/alipay/fury/pull/467[C++] cpp murmurhash by @chaokunyang in https://github.com/alipay/fury/pull/469[Python] Python murmur hash binding by @chaokunyang in https://github.com/alipay/fury/pull/472[Python] add weak key identity map by @chaokunyang in https://github.com/alipay/fury/pull/474[Python] add reference resolver by @chaokunyang in https://github.com/alipay/fury/pull/476[Python] Implement python serialization framework by @chaokunyang in https://github.com/alipay/fury/pull/478[Python] add common python serializers by @chaokunyang in https://github.com/alipay/fury/pull/480[Python] struct serialization support by @chaokunyang in https://github.com/alipay/fury/pull/482[Java] Fix get super type exception by @chaokunyang in https://github.com/alipay/fury/pull/484[Java] fix map final value type serializer in jit compatible mode by @chaokunyang in https://github.com/alipay/fury/pull/485[Docs] add fury logo by @chaokunyang in https://github.com/alipay/fury/pull/487[Docs] add square fury logo by @chaokunyang in https://github.com/alipay/fury/pull/488[python] add cpp reference resolver based on abseil map by @chaokunyang in https://github.com/alipay/fury/pull/493[python] add cpp class resolver by @chaokunyang in https://github.com/alipay/fury/pull/494[Python] cython serialization framework by @chaokunyang in https://github.com/alipay/fury/pull/496[Python] cython basic serializers by @chaokunyang in https://github.com/alipay/fury/pull/501[Python] cython container serializers by @chaokunyang in https://github.com/alipay/fury/pull/502[Pyhton] cython array serializers by @chaokunyang in https://github.com/alipay/fury/pull/503[Python] cython struct serializer by @chaokunyang in https://github.com/alipay/fury/pull/505[Python] cython misc serializers by @chaokunyang in https://github.com/alipay/fury/pull/506[Python] Unify cython python serializer by @chaokunyang in https://github.com/alipay/fury/pull/507[Python] Codegen serialization support by @chaokunyang in https://github.com/alipay/fury/pull/509[Python] Support arrow serialization in objgraph by @chaokunyang in https://github.com/alipay/fury/pull/515[Python] Add common pytests by @chaokunyang in https://github.com/alipay/fury/pull/517[C++] pin bazel to 4.2.0 by @chaokunyang in https://github.com/alipay/fury/pull/519[Community] Update contacts about wechat/dingding by @chaokunyang in https://github.com/alipay/fury/pull/521[Java] support struct cross language serialization by @chaokunyang in https://github.com/alipay/fury/pull/523[Java] add java/python cross language row format tests by @chaokunyang in https://github.com/alipay/fury/pull/525feat: fix qrcode size in readme by @wangweipeng2 in https://github.com/alipay/fury/pull/526[Java] replace io.furyx with org.furyio by @chaokunyang in https://github.com/alipay/fury/pull/527[Java] Add missing map license by @chaokunyang in https://github.com/alipay/fury/pull/529[Java] reduce string serializer caller stack by jit by @chaokunyang in https://github.com/alipay/fury/pull/531[Java] fix nested map generics by @chaokunyang in https://github.com/alipay/fury/pull/533[Java] fix jdk11 string jit serialization by @chaokunyang in https://github.com/alipay/fury/pull/535[JavaScript] improve write performance by @wangweipeng2 in https://github.com/alipay/fury/pull/538[Java] refine java benchmarks by @chaokunyang in https://github.com/alipay/fury/pull/536[Java] fix fury java kryo/fst benchmark classloading by @chaokunyang in https://github.com/alipay/fury/pull/542[Java] Unsafe method invoke optimization by @chaokunyang in https://github.com/alipay/fury/pull/543[Java] Optimize string serialization mem ops by @chaokunyang in https://github.com/alipay/fury/pull/545[Java] Optimze jit generated code by @chaokunyang in https://github.com/alipay/fury/pull/548[Java] Optimize primitive fields jit read/write by @chaokunyang in https://github.com/alipay/fury/pull/550[Java] Fix benchmark plot by @chaokunyang in https://github.com/alipay/fury/pull/554[Java] Upload benchmark data by @chaokunyang in https://github.com/alipay/fury/pull/555[Docs] Update benchmarks by @chaokunyang in https://github.com/alipay/fury/pull/560[Docs] use a smaller size for benchmark plots by @chaokunyang in https://github.com/alipay/fury/pull/561[Docs] update docs by @chaokunyang in https://github.com/alipay/fury/pull/565[Doc] update docs by @chaokunyang in https://github.com/alipay/fury/pull/566[Docs] update readme by @chaokunyang in https://github.com/alipay/fury/pull/567[JavaScript] Import js write performance by @wangweipeng2 in https://github.com/alipay/fury/pull/569[Docs ] fix benchmarks figures align by @chaokunyang in https://github.com/alipay/fury/pull/571[Docs] fix python typehint comment by @chaokunyang in https://github.com/alipay/fury/pull/572[Docs] add row format to arrow conversion java example by @chaokunyang in https://github.com/alipay/fury/pull/573[JavaScript] update benchmark by @wangweipeng2 in https://github.com/alipay/fury/pull/574[JavaScript] easy type description by @wangweipeng2 in https://github.com/alipay/fury/pull/576[JavaScript] add generic constraints to the serializer by @wangweipeng2 in https://github.com/alipay/fury/pull/577[Docs] Refine benchmark plots by @chaokunyang in https://github.com/alipay/fury/pull/578[Docs] fix java header by @chaokunyang in https://github.com/alipay/fury/pull/582[Python] support secure mode for python by @chaokunyang in https://github.com/alipay/fury/pull/584[Docs] update readme speedup by @chaokunyang in https://github.com/alipay/fury/pull/585[Docs] remove Binary Serialization from header by @chaokunyang in https://github.com/alipay/fury/pull/586[Docs] add Serialization to header by @chaokunyang in https://github.com/alipay/fury/pull/587[Docs] fix invalid image links in cpp debug doc by @chaokunyang in https://github.com/alipay/fury/pull/589Bump protobuf-java from 3.11.0 to 3.16.3 in /java/fury-benchmark by @dependabot in https://github.com/alipay/fury/pull/590Bump testng from 7.3.0 to 7.5.1 in /java by @dependabot in https://github.com/alipay/fury/pull/591Bump checkstyle from 8.19 to 8.29 in /java by @dependabot in https://github.com/alipay/fury/pull/592Bump guava from 30.0-jre to 32.0.0-jre in /java by @dependabot in https://github.com/alipay/fury/pull/593Bump protobuf-java from 3.15.0 to 3.16.3 in /integration_tests by @dependabot in https://github.com/alipay/fury/pull/594[Java] replace log4j by log4j2 for test modules by @chaokunyang in https://github.com/alipay/fury/pull/595[JavaScript] update benchmark by @wangweipeng2 in https://github.com/alipay/fury/pull/597[Java] rename reference to ref by @chaokunyang in https://github.com/alipay/fury/pull/599[Java] fix checkstyle failure by @chaokunyang in https://github.com/alipay/fury/pull/602[Java] fix missing reference renaming by @chaokunyang in https://github.com/alipay/fury/pull/603[Java] Rename requireClassRegistration by @chaokunyang in https://github.com/alipay/fury/pull/604[JavaScript]: remove dependency on v8 by @wangweipeng2 in https://github.com/alipay/fury/pull/606[Rust] Add readme for fury rust by @chaokunyang in https://github.com/alipay/fury/pull/607[Java] add missing license for java code by @chaokunyang in https://github.com/alipay/fury/pull/608[Java] update java benchmarks by @chaokunyang in https://github.com/alipay/fury/pull/609[Docs] update java benchmarks chart size by @chaokunyang in https://github.com/alipay/fury/pull/610[Docs] use same color for fury best performance by @chaokunyang in https://github.com/alipay/fury/pull/611[Java] add MetaContext tests by @chaokunyang in https://github.com/alipay/fury/pull/613[Java] Add java misc tests by @chaokunyang in https://github.com/alipay/fury/pull/614[Java] Add codegen class loading/gc tests by @chaokunyang in https://github.com/alipay/fury/pull/616[Java] add warn logs when requireClassRegistration disabled by @chaokunyang in https://github.com/alipay/fury/pull/618[Docs] Add java adcanced user guide doc by @chaokunyang in https://github.com/alipay/fury/pull/621[Docs] Update java advanced doc by @chaokunyang in https://github.com/alipay/fury/pull/625[JavaScript] Eliminate polymorphism in JS code by @wangweipeng2 in https://github.com/alipay/fury/pull/627[Python] rename reference to ref for python by @chaokunyang in https://github.com/alipay/fury/pull/629[Java/Python] Rename crosslanguage to x by @chaokunyang in https://github.com/alipay/fury/pull/631[JavaScript] reduce generated code size by @wangweipeng2 in https://github.com/alipay/fury/pull/633[Java] update java snapshot url by @chaokunyang in https://github.com/alipay/fury/pull/635[CI] Enable Fury CI by @chaokunyang in https://github.com/alipay/fury/pull/636[Docs] add benchmark data by @chaokunyang in https://github.com/alipay/fury/pull/639[Doc] use camel naming for benchmark class doc by @chaokunyang in https://github.com/alipay/fury/pull/640[Docs] Update security doc by @chaokunyang in https://github.com/alipay/fury/pull/642[Java] update license for Generics by @chaokunyang in https://github.com/alipay/fury/pull/644[Java] fix generics license length by @chaokunyang in https://github.com/alipay/fury/pull/645[Java] update java security doc by @chaokunyang in https://github.com/alipay/fury/pull/646[Go] update golang readme by @chaokunyang in https://github.com/alipay/fury/pull/648[Doc] replace Fury.Language by Language by @chaokunyang in https://github.com/alipay/fury/pull/650[Java] update java row readme by @chaokunyang in https://github.com/alipay/fury/pull/651[Java] register guava serializers ahead by @chaokunyang in https://github.com/alipay/fury/pull/654[Docs] split user guide doc into 3 parts to sync with website by @chaokunyang in https://github.com/alipay/fury/pull/665[Docs] move guide docs to guide by @chaokunyang in https://github.com/alipay/fury/pull/667[Doc] sync files to home site by @wangweipeng2 in https://github.com/alipay/fury/pull/666[Java] Fix IndexOutOfBoundsException when new fury deserialize from InputStream by @chaokunyang in https://github.com/alipay/fury/pull/671[Doc] support front matter by @wangweipeng2 in https://github.com/alipay/fury/pull/672[Doc] rename inner fury to f when creating ThreadSafeFury by @chaokunyang in https://github.com/alipay/fury/pull/676[Java] Support string zerocopy for jdk14+ by @chaokunyang in https://github.com/alipay/fury/pull/677[CI] Add deploy script by @chaokunyang in https://github.com/alipay/fury/pull/688[Java] Support maven release by @chaokunyang in https://github.com/alipay/fury/pull/691[Doc] add java release jar for v0.1.0-alpha.1 by @chaokunyang in https://github.com/alipay/fury/pull/693[Doc] Fix release jar doc by @chaokunyang in https://github.com/alipay/fury/pull/694[Doc] Refine readme for more readability by @chaokunyang in https://github.com/alipay/fury/pull/695[Java] Add detailed lambda error by @chaokunyang in https://github.com/alipay/fury/pull/698[Doc] Fix threadsafe example by @chaokunyang in https://github.com/alipay/fury/pull/699[Docs] fix threadsafe fury in java guide by @chaokunyang in https://github.com/alipay/fury/pull/700[Docs] remove bracket from classLoader by @chaokunyang in https://github.com/alipay/fury/pull/701[Java] add maven source plugin by @chaokunyang in https://github.com/alipay/fury/pull/702[Java] Jdk serialization binary check by @chaokunyang in https://github.com/alipay/fury/pull/714[Java] add jdk migration doc by @chaokunyang in https://github.com/alipay/fury/pull/715[Java] Support jit for non public classes by @chaokunyang in https://github.com/alipay/fury/pull/719[Rust] rust lang initial version by @wangweipeng2 in https://github.com/alipay/fury/pull/718[Java] add type tag registration check by @chaokunyang in https://github.com/alipay/fury/pull/722[Doc] highlight warmup by @chaokunyang in https://github.com/alipay/fury/pull/723[Rust ] calculate the reserved space on compile time by @wangweipeng2 in https://github.com/alipay/fury/pull/725[Java/Python] disable reference tracking by default by @chaokunyang in https://github.com/alipay/fury/pull/727[Java] debug log code stats by @chaokunyang in https://github.com/alipay/fury/pull/728[Java] upgrade java install to 0.1.0-alpha.2 by @chaokunyang in https://github.com/alipay/fury/pull/731[Doc] use fury png logo by @chaokunyang in https://github.com/alipay/fury/pull/733[Doc] remove margin fury png logo by @chaokunyang in https://github.com/alipay/fury/pull/734[Doc] Refine logo and icon by @chaokunyang in https://github.com/alipay/fury/pull/735[ Rust ] Make the protocols of rust and js consistent by @wangweipeng2 in https://github.com/alipay/fury/pull/738[JavaScript] Make the protocols of rust and js consistent by @wangweipeng2 in https://github.com/alipay/fury/pull/739[Java] Remove guava from userdoc by @chaokunyang in https://github.com/alipay/fury/pull/740[Java] rename writeNonRefT to writeNonRef by @chaokunyang in https://github.com/alipay/fury/pull/743[Java] Optimize object array serialization by @chaokunyang in https://github.com/alipay/fury/pull/741[Java] avoid reflection in resolve/replace by @chaokunyang in https://github.com/alipay/fury/pull/744[Java] avoid reflection in writeObject/readOject/readObjectNoData by @chaokunyang in https://github.com/alipay/fury/pull/747[Java] optimize guava list serialization by @chaokunyang in https://github.com/alipay/fury/pull/748[Java] add MakeJDKFunction lambda factory by @chaokunyang in https://github.com/alipay/fury/pull/752[Java] Optimize guava List/Map/Set serialization by @chaokunyang in https://github.com/alipay/fury/pull/750[Doc] Add contributing guide doc by @chaokunyang in https://github.com/alipay/fury/pull/759[Doc] Create CODE_OF_CONDUCT.md by @chaokunyang in https://github.com/alipay/fury/pull/761[Doc] Fix broken link in README by @tisonkun in https://github.com/alipay/fury/pull/762[Rust] Several Rust idioms by @tisonkun in https://github.com/alipay/fury/pull/763[Java] fix write replace class failure by @chaokunyang in https://github.com/alipay/fury/pull/767[Java] replace withSecureMode by requireClassRegistration API by @chaokunyang in https://github.com/alipay/fury/pull/768[Doc] Update README.md by @chaokunyang in https://github.com/alipay/fury/pull/770[Doc] add javadoc for FuryBuilder by @chaokunyang in https://github.com/alipay/fury/pull/775[Doc] add doc for fury creation reuse by @chaokunyang in https://github.com/alipay/fury/pull/777[Java][Python] auto deploy java/python packages by @chaokunyang in https://github.com/alipay/fury/pull/781[Java] refine FuryBuilder API by @chaokunyang in https://github.com/alipay/fury/pull/784[CI] skip release tests by @chaokunyang in https://github.com/alipay/fury/pull/785Corrected grammar and paraphrasing to make the README easier to read by @hieu-ht in https://github.com/alipay/fury/pull/786Don't let CI run when the changed files are not the code by @hieu-ht in https://github.com/alipay/fury/pull/787[Java] use lambda for SynchronizedSerializers factory by @chaokunyang in https://github.com/alipay/fury/pull/789[Java] use lambda for unmodifiable serializers factory by @chaokunyang in https://github.com/alipay/fury/pull/790[Python] replace alpha/beta to a/b for python by @chaokunyang in https://github.com/alipay/fury/pull/792[Python] fix python bump version by @chaokunyang in https://github.com/alipay/fury/pull/793[CI] Fix bump version by @chaokunyang in https://github.com/alipay/fury/pull/795[CI] Fix py release by @chaokunyang in https://github.com/alipay/fury/pull/796[Doc] update python and java install by @chaokunyang in https://github.com/alipay/fury/pull/797Update README.md by @chaokunyang in https://github.com/alipay/fury/pull/800[Doc] Update java install version to 0.1.0-alpah.5 by @chaokunyang in https://github.com/alipay/fury/pull/801[CI] Fix pypi upload by @chaokunyang in https://github.com/alipay/fury/pull/803[Java] Add core java developer to maven pom by @chaokunyang in https://github.com/alipay/fury/pull/802[Java] add core java developer to maven modules pom by @chaokunyang in https://github.com/alipay/fury/pull/804[Java] support decode utf8 for java string serialization by @chaokunyang in https://github.com/alipay/fury/pull/806Update Java Deserialization Blacklist by @s31k31 in https://github.com/alipay/fury/pull/782chore: apply license format by @tisonkun in https://github.com/alipay/fury/pull/783[Java] use soft reference to avoid duplicate codegen by @chaokunyang in https://github.com/alipay/fury/pull/809  Full Changelog: https://github.com/alipay/fury/commits/v0.1.0 ","version":null,"tagName":"h2"},{"title":"Fury v0.1.2 released","type":0,"sectionRef":"#","url":"/blog/fury_0_1_2_release","content":"","keywords":"","version":null},{"title":"What's Changed​","type":1,"pageTitle":"Fury v0.1.2 released","url":"/blog/fury_0_1_2_release#whats-changed","content":" [Java] Skip toString in annotation invocation handler readObject (#746)[Python] Use cloudpickle for local function serialization (#914)[Python] fix row format getter (#915)  Full Changelog: https://github.com/alipay/fury/compare/v0.1.0...v0.1.1 ","version":null,"tagName":"h2"},{"title":"Fury v0.2.0 released","type":0,"sectionRef":"#","url":"/blog/fury_0_2_0_release","content":"","keywords":"","version":null},{"title":"Highlights​","type":1,"pageTitle":"Fury v0.2.0 released","url":"/blog/fury_0_2_0_release#highlights","content":" ","version":null,"tagName":"h2"},{"title":"Java​","type":1,"pageTitle":"Fury v0.2.0 released","url":"/blog/fury_0_2_0_release#java","content":" Support JDK17+ record JIT/Interpreter serializationSupport JDK17+ record JIT/Interpreter serialization backward/forward compatibilitySupport jdk9+ Immutable Collections JIT/Interpreter mode serialization, much faster compared to other frameworksNew collection serialization protocol by homogenization, 1.5x speed up, 2X space saving.Desgined and implemented a new long compression algorithm, with performance cost less than 10% but give 50% compresstion ratioSupport configuring compress int/long independently, enable int/long compression by defaultAdd class checker API and Whitelist/Blacklist based implementation to enhance security  ","version":null,"tagName":"h3"},{"title":"Python​","type":1,"pageTitle":"Fury v0.2.0 released","url":"/blog/fury_0_2_0_release#python","content":" Support pyarrow6 bazel buildSupport python 3.10  ","version":null,"tagName":"h3"},{"title":"JavaScript​","type":1,"pageTitle":"Fury v0.2.0 released","url":"/blog/fury_0_2_0_release#javascript","content":" [JavaScript] support fury for browser[JavaScript] support polymorphism[JavaScript] enhancement performance  ","version":null,"tagName":"h3"},{"title":"Golang​","type":1,"pageTitle":"Fury v0.2.0 released","url":"/blog/fury_0_2_0_release#golang","content":" Implement Golang serialization framework, which support reference, pointer, data serializationImplement serializers for string/numbers/slice/map/slice/struct/pointer  ","version":null,"tagName":"h3"},{"title":"What's Changed​","type":1,"pageTitle":"Fury v0.2.0 released","url":"/blog/fury_0_2_0_release#whats-changed","content":" [JavaScript] enhancement performance and bugfix by @wangweipeng2 in https://github.com/alipay/fury/pull/811[JavaScript] support polymorphism by @wangweipeng2 in https://github.com/alipay/fury/pull/814Create SECURITY.md by @chaokunyang in https://github.com/alipay/fury/pull/817[JavaScript] fix bug #703 by @wangweipeng2 in https://github.com/alipay/fury/pull/819[Java] fix isSecure check for xlang in java by @chaokunyang in https://github.com/alipay/fury/pull/822[Doc] add protocol wire format wip by @chaokunyang in https://github.com/alipay/fury/pull/823[JavaScript] write tag hash by @wangweipeng2 in https://github.com/alipay/fury/pull/825[JavaScript] support browser by @wangweipeng2 in https://github.com/alipay/fury/pull/830[Java] register empty object by default by @chaokunyang in https://github.com/alipay/fury/pull/829[Java] upgrade guava for CVE-2023-2976 by @chaokunyang in https://github.com/alipay/fury/pull/831[JavaScript] detect platform wrong by @wangweipeng2 in https://github.com/alipay/fury/pull/832[JavaScript] add test by @wangweipeng2 in https://github.com/alipay/fury/pull/836[Java] Add compatible ci for JDK8/11/13/15/17 by @chaokunyang in https://github.com/alipay/fury/pull/835[Java] use java.lang.ClassValue to cache Lookup by @chaokunyang in https://github.com/alipay/fury/pull/844[Java] Refactor integration tests by @chaokunyang in https://github.com/alipay/fury/pull/845[Java] suppress maven download logs by --no-transfer-progress by @chaokunyang in https://github.com/alipay/fury/pull/846[Java] add missing jdk primitive function by @chaokunyang in https://github.com/alipay/fury/pull/848[Java] make getter lambda functions by @chaokunyang in https://github.com/alipay/fury/pull/849[Java] add record utils by @chaokunyang in https://github.com/alipay/fury/pull/850[Java] Support access record field value by @chaokunyang in https://github.com/alipay/fury/pull/851[Java] interpreter mode support for record serialization by @chaokunyang in https://github.com/alipay/fury/pull/852[CI] Fix checkstyle by @chaokunyang in https://github.com/alipay/fury/pull/853[Java] Support jdk record forward/backward interpreter serialization by @chaokunyang in https://github.com/alipay/fury/pull/854[Java] Support jdk record metashare mode by @chaokunyang in https://github.com/alipay/fury/pull/855[Java] move record utils to record pkg by @chaokunyang in https://github.com/alipay/fury/pull/856[Java] move inner functions outside by @chaokunyang in https://github.com/alipay/fury/pull/857[Python] Support pyarrow6 bazel build by @chaokunyang in https://github.com/alipay/fury/pull/859[Python] add missing shared lib for python by @chaokunyang in https://github.com/alipay/fury/pull/862[Python] fix python deploy by @chaokunyang in https://github.com/alipay/fury/pull/863[Java] Jdk record compatible jit by @chaokunyang in https://github.com/alipay/fury/pull/864[Java] JIT serialization for JDK record by @chaokunyang in https://github.com/alipay/fury/pull/866[Java] support private record jit by @chaokunyang in https://github.com/alipay/fury/pull/869[Java] optimize buffer copy by @chaokunyang in https://github.com/alipay/fury/pull/870[Doc] Fix row format doc by @chaokunyang in https://github.com/alipay/fury/pull/873[Java] Support compress int long independently by @chaokunyang in https://github.com/alipay/fury/pull/875[Java] fix ofHashMap by @chaokunyang in https://github.com/alipay/fury/pull/877[Java] add jdk tools.jar for tests by @chaokunyang in https://github.com/alipay/fury/pull/881[Java] register common exception by @chaokunyang in https://github.com/alipay/fury/pull/879[Java] Fix lazy bean serializer by @chaokunyang in https://github.com/alipay/fury/pull/883[Java] print exception for fury creation by @chaokunyang in https://github.com/alipay/fury/pull/885[Java] remove getCurrentFury API by @chaokunyang in https://github.com/alipay/fury/pull/887[Java] Add fury map iterator api by @chaokunyang in https://github.com/alipay/fury/pull/889[Java] Add class checker API by @chaokunyang in https://github.com/alipay/fury/pull/890[Python] Fix python linux deploy missing shared library files by @chaokunyang in https://github.com/alipay/fury/pull/892[Java] refine AllowListChecker by @chaokunyang in https://github.com/alipay/fury/pull/893Update README.md by @chaokunyang in https://github.com/alipay/fury/pull/894[Java] support immutable collection/map jit and generics optimization by @chaokunyang in https://github.com/alipay/fury/pull/895[Java] cache generated guava constructor by @chaokunyang in https://github.com/alipay/fury/pull/897[Java] Optimize jdk9+ immutable collection serialization by @chaokunyang in https://github.com/alipay/fury/pull/900[Java] add jdk20 tests by @chaokunyang in https://github.com/alipay/fury/pull/901[Java] optimize duplicate fields utils by @chaokunyang in https://github.com/alipay/fury/pull/905[Java] fix jit error for package-level field with private type by @chaokunyang in https://github.com/alipay/fury/pull/907[Java] update blacklist by @chaokunyang in https://github.com/alipay/fury/pull/913[Python] Use cloudpickle for local function serialization by @chaokunyang in https://github.com/alipay/fury/pull/914[Python] fix row format getter by @chaokunyang in https://github.com/alipay/fury/pull/915[Java] disable class check by default by @chaokunyang in https://github.com/alipay/fury/pull/917[Java] refine java docs by @chaokunyang in https://github.com/alipay/fury/pull/918Update blacklist.txt by @chaokunyang in https://github.com/alipay/fury/pull/920[Java] Skip toString in annotation invocation handler readObject by @chaokunyang in https://github.com/alipay/fury/pull/922Optimize StringBuilder/StringBuffer serialization by @pandalee99 in https://github.com/alipay/fury/pull/908Bump release versin to 0.1.2 by @chaokunyang in https://github.com/alipay/fury/pull/924[Doc] add basic type java format doc by @chaokunyang in https://github.com/alipay/fury/pull/928[Java] speed test codegen speed by avoid duplicate codegen by @chaokunyang in https://github.com/alipay/fury/pull/929[Java] Optimize collection serialization protocol by homogenization by @chaokunyang in https://github.com/alipay/fury/pull/923Bump org.apache.avro:avro from 1.11.1 to 1.11.3 in /java/fury-benchmark by @dependabot in https://github.com/alipay/fury/pull/931[Java] Rename classinfocache to classinfoholder by @chaokunyang in https://github.com/alipay/fury/pull/933[Java] put together all primitive serializers by @chaokunyang in https://github.com/alipay/fury/pull/934[Java] Fix jvm crash caused by varint out-of-bound writing by @chaokunyang in https://github.com/alipay/fury/pull/937[Java] enable int compression by default by @chaokunyang in https://github.com/alipay/fury/pull/935[Java] put together all fury related config classes into config package by @chaokunyang in https://github.com/alipay/fury/pull/940[Java] Add SLI(small long as int) long encoding algorithm by @chaokunyang in https://github.com/alipay/fury/pull/942[Java] use raw type serializer for getSerialzier in jit by @chaokunyang in https://github.com/alipay/fury/pull/943[Java] use varint for class id encoding to reduce space cost by @chaokunyang in https://github.com/alipay/fury/pull/945[Java] Fix Collection/Map jit/interpreter protocol inconsisitency for generics instantiated subclass by @chaokunyang in https://github.com/alipay/fury/pull/947[Go] add fury go util and ci tests by @chaokunyang in https://github.com/alipay/fury/pull/950[Go] add fury go buffer implementation by @chaokunyang in https://github.com/alipay/fury/pull/952[Go] add fury go serialization framework by @chaokunyang in https://github.com/alipay/fury/pull/954[Go] add serializers for common go types by @chaokunyang in https://github.com/alipay/fury/pull/956[Java] fix varint writeindex grow for jit by @chaokunyang in https://github.com/alipay/fury/pull/957[Go] add fury go map serializer by @chaokunyang in https://github.com/alipay/fury/pull/959[Go] add slice serializer for fury go by @chaokunyang in https://github.com/alipay/fury/pull/961[Go] add set serializer for fury go by @chaokunyang in https://github.com/alipay/fury/pull/963[Go] Add struct serializer for fury go by @chaokunyang in https://github.com/alipay/fury/pull/965[Go] add ref tracking tests by @chaokunyang in https://github.com/alipay/fury/pull/967[Go] add fury type dispatch tests by @chaokunyang in https://github.com/alipay/fury/pull/969[Go] add fury serialization tests by @chaokunyang in https://github.com/alipay/fury/pull/971[Go] Add fury xlang tests by @chaokunyang in https://github.com/alipay/fury/pull/973[Go] rename Reference to Ref by @chaokunyang in https://github.com/alipay/fury/pull/975[Java] add jdk 21 tests by @chaokunyang in https://github.com/alipay/fury/pull/977[Java] add jdk 21 tests ci by @chaokunyang in https://github.com/alipay/fury/pull/978[Java] Optimize sli long read/write by @chaokunyang in https://github.com/alipay/fury/pull/981[Doc] upgrade docs by @chaokunyang in https://github.com/alipay/fury/pull/985 https://github.com/alipay/fury/pull/986 https://github.com/alipay/fury/pull/987[Java] add serializeJavaObject API to ThreadSafeFury by @chaokunyang in https://github.com/alipay/fury/pull/988[Java] fix jdk17/21 ci latest_jdk_tests skip by @chaokunyang in https://github.com/alipay/fury/pull/989  ","version":null,"tagName":"h2"},{"title":"New Contributors​","type":1,"pageTitle":"Fury v0.2.0 released","url":"/blog/fury_0_2_0_release#new-contributors","content":" @pandalee99 made their first contribution in https://github.com/alipay/fury/pull/908@ilxqx made their first contribution in https://github.com/fury-project/dubbo-serialization-fury/pull/1@T-baby made their first contribution in https://github.com/fury-project/dubbo-serialization-fury/pull/13  Full Changelog: https://github.com/alipay/fury/compare/v0.1.0...v0.2.0 ","version":null,"tagName":"h2"},{"title":"Fury v0.1.1 released","type":0,"sectionRef":"#","url":"/blog/fury_0_1_1_release","content":"","keywords":"","version":null},{"title":"Highlights​","type":1,"pageTitle":"Fury v0.1.1 released","url":"/blog/fury_0_1_1_release#highlights","content":" Java Dubbo fury integration: https://github.com/fury-project/dubbo-serialization-furyAdd class checker API to customize security check behaviour(#890) Python Support pyarrow6 bazel build (#859 #862)Support python 3.10 (#859 #862)  ","version":null,"tagName":"h2"},{"title":"What's Changed​","type":1,"pageTitle":"Fury v0.1.1 released","url":"/blog/fury_0_1_1_release#whats-changed","content":" [Java] Dubbo fury integration: https://github.com/fury-project/dubbo-serialization-fury[Java] fix isSecure check for xlang in java (#822)[Java] register empty object by default (#829)[Java] upgrade guava for(#831)[Python] Support pyarrow6 bazel build (#859)[Python] add missing shared lib for python (#862)[Java] optimize buffer copy (#870)[Doc] Fix row format doc (#873)[Java] fix ofHashMap (#877)[Java] add jdk tools.jar for tests (#881)[Java] Fix lazy bean serializer (#883)[Java] print exception for fury creation (#885)[Java] remove getCurrentFury API (#887)[Java] Add fury map iterator api (#889)[Java] Add class checker API (#890)[Python] Fix python linux deploy missing shared library files (#892)[[Java] refine AllowListChecker (#893)  Full Changelog: https://github.com/alipay/fury/compare/v0.1.0...v0.1.1 ","version":null,"tagName":"h2"},{"title":"Fury v0.3.1 released","type":0,"sectionRef":"#","url":"/blog/fury_0_3_1_release","content":"","keywords":"","version":null},{"title":"Highlight​","type":1,"pageTitle":"Fury v0.3.1 released","url":"/blog/fury_0_3_1_release#highlight","content":" Support python 3.11 and 3.12, drop python 3.6 supportRefactor collection serialization framework to support writeReplace JITIntegrate scala collection with fury java collection frameworkSupport scala collection jit serializationSupport shim dispatcher to resolve compatibility problems for common used classesUse lastest arrow 14 version for row format in Java and Python  ","version":null,"tagName":"h2"},{"title":"What's Changed​","type":1,"pageTitle":"Fury v0.3.1 released","url":"/blog/fury_0_3_1_release#whats-changed","content":" [Doc] add scala sbt install doc by @chaokunyang in https://github.com/alipay/fury/pull/1066[Doc] Update scala_guide.md by @chaokunyang in https://github.com/alipay/fury/pull/1067[Doc] Add scala 2/3 support doc by @chaokunyang in https://github.com/alipay/fury/pull/1068[Java] Refactor collection serialization framework to support writeReplace JIT by @chaokunyang in https://github.com/alipay/fury/pull/1062[Java] Refine collection package by @chaokunyang in https://github.com/alipay/fury/pull/1070[Java] merge map/collection into collection package by @chaokunyang in https://github.com/alipay/fury/pull/1072[Scala] integrate scala collection with fury java collection framework by @chaokunyang in https://github.com/alipay/fury/pull/1073remove unused part of build.sbt by @pjfanning in https://github.com/alipay/fury/pull/1074[Scala] get build to work with Scala 3 by @pjfanning in https://github.com/alipay/fury/pull/1075[Scala] support scala collection jit serialization by @chaokunyang in https://github.com/alipay/fury/pull/1077[Doc] add apache license section to readme by @caicancai in https://github.com/alipay/fury/pull/1080[Java] add option to disable class check warnings by @chaokunyang in https://github.com/alipay/fury/pull/1084[Java] Fix collection serialization NPE when all elements are null by @chaokunyang in https://github.com/alipay/fury/pull/1086[Java] FuryPooledObjectFactory getFury refactor, remove redundant recursive call by @mof-dev-3 in https://github.com/alipay/fury/pull/1088[Rust] add rust-version by @wangweipeng2 in https://github.com/alipay/fury/pull/1091[DOC] add javascript sample by @wangweipeng2 in https://github.com/alipay/fury/pull/1095Make sure the c++ standard is set to 17 by @PragmaTwice in https://github.com/alipay/fury/pull/1093Fix undefined behavior due to use of uninitialized field in Buffer by @PragmaTwice in https://github.com/alipay/fury/pull/1092[Rust] merge derive and make it sample by @wangweipeng2 in https://github.com/alipay/fury/pull/1098[DOC] add rust sample by @wangweipeng2 in https://github.com/alipay/fury/pull/1100Simplify endian utility functions and IsOneOf by @PragmaTwice in https://github.com/alipay/fury/pull/1096[Java] throw error if nested fury serialize happen in serialization by @chaokunyang in https://github.com/alipay/fury/pull/1103[C++] remove useless FromXXXEndian by @chaokunyang in https://github.com/alipay/fury/pull/1105[Rust ] Remove the magic numbers by @wangweipeng2 in https://github.com/alipay/fury/pull/1107[Rust] chore: add rust doc by @wangweipeng2 in https://github.com/alipay/fury/pull/1109[JavaScript] Fill in readme by @wangweipeng2 in https://github.com/alipay/fury/pull/1110chore: check xlang flag by @wangweipeng2 in https://github.com/alipay/fury/pull/1112[Java] Remove guava part1 by @chaokunyang in https://github.com/alipay/fury/pull/1114[Rust] Correct language flag by @wangweipeng2 in https://github.com/alipay/fury/pull/1120[Java] DateTimeUtils minor refactor, reuse floorDiv to calculate floorMod by @mof-dev-3 in https://github.com/alipay/fury/pull/1122[Python] Support python3.11/12 by @chaokunyang in https://github.com/alipay/fury/pull/1064[java] support shim dispatcher to resolve compatibility problems for common used classes by @xiguashu in https://github.com/alipay/fury/pull/1123  ","version":null,"tagName":"h2"},{"title":"New Contributors​","type":1,"pageTitle":"Fury v0.3.1 released","url":"/blog/fury_0_3_1_release#new-contributors","content":" @pjfanning made their first contribution in https://github.com/alipay/fury/pull/1074@mof-dev-3 made their first contribution in https://github.com/alipay/fury/pull/1088@PragmaTwice made their first contribution in https://github.com/alipay/fury/pull/1093@xiguashu made their first contribution in https://github.com/alipay/fury/pull/1123  Full Changelog: https://github.com/alipay/fury/compare/v0.3.0...v0.3.1 ","version":null,"tagName":"h2"},{"title":"Fury v0.2.1 released","type":0,"sectionRef":"#","url":"/blog/fury_0_2_1_release","content":"","keywords":"","version":null},{"title":"Highlight​","type":1,"pageTitle":"Fury v0.2.1 released","url":"/blog/fury_0_2_1_release#highlight","content":" [Go] Support tiny go compilation[Java] Support private JDK17+ record class JIT serialization  ","version":null,"tagName":"h2"},{"title":"Bug fix​","type":1,"pageTitle":"Fury v0.2.1 released","url":"/blog/fury_0_2_1_release#bug-fix","content":" Fix jit error for register private serializersUpgrade janino version to fix package name conflict with classname  ","version":null,"tagName":"h2"},{"title":"What's Changed​","type":1,"pageTitle":"Fury v0.2.1 released","url":"/blog/fury_0_2_1_release#whats-changed","content":" [Doc] Update JDK support doc by @chaokunyang in https://github.com/alipay/fury/pull/992[Go] Make compilation support tinygo by @springrain in https://github.com/alipay/fury/pull/991[Doc] fix config class imports by @chaokunyang in https://github.com/alipay/fury/pull/993[go] fixed typo in readme import path by @voldyman in https://github.com/alipay/fury/pull/995[Java] fix jit error for register private serializers by @chaokunyang in https://github.com/alipay/fury/pull/999[Java] Refine reflection contructor by MethodHandle by @chaokunyang in https://github.com/alipay/fury/pull/1000[Java] Fix private record JIT by @chaokunyang in https://github.com/alipay/fury/pull/1004[Java] Upgrade janino version to fix package name conflict with classname by @chaokunyang in https://github.com/alipay/fury/pull/1006[Java] fix janino deps for fury-benchmark by @chaokunyang in https://github.com/alipay/fury/pull/1007[Doc] Improve README by @caicancai in https://github.com/alipay/fury/pull/1009  ","version":null,"tagName":"h2"},{"title":"New Contributors​","type":1,"pageTitle":"Fury v0.2.1 released","url":"/blog/fury_0_2_1_release#new-contributors","content":" @springrain made their first contribution in https://github.com/alipay/fury/pull/991@voldyman made their first contribution in https://github.com/alipay/fury/pull/995@caicancai made their first contribution in https://github.com/alipay/fury/pull/1009  Full Changelog: https://github.com/alipay/fury/compare/v0.2.0...v0.2.1 ","version":null,"tagName":"h2"},{"title":"Fury v0.3.0 released","type":0,"sectionRef":"#","url":"/blog/fury_0_3_0_release","content":"","keywords":"","version":null},{"title":"Scala Serialization Guide​","type":1,"pageTitle":"Fury v0.3.0 released","url":"/blog/fury_0_3_0_release#scala-serialization-guide","content":" Install dependecy:  libraryDependencies += &quot;org.furyio&quot; % &quot;fury-core&quot; % &quot;0.3.0&quot;   Creating fury:  val fury = Fury.builder() .withScalaOptimizationEnabled(true) .requireClassRegistration(false) .withRefTracking(true) .build()   Serialize case objects:  case class Person(github: String, age: Int, id: Long) val p = Person(&quot;https://github.com/chaokunyang&quot;, 18, 1) println(fury.deserialize(fury.serialize(p))) println(fury.deserializeJavaObject(fury.serializeJavaObject(p)))   Serialize singleton objects:  object singleton { } val o1 = fury.deserialize(fury.serialize(singleton)) val o2 = fury.deserialize(fury.serialize(singleton)) println(o1 == o2)   Serialize collection objects:  val seq = Seq(1,2) val list = List(&quot;a&quot;, &quot;b&quot;) val map = Map(&quot;a&quot; -&gt; 1, &quot;b&quot; -&gt; 2) println(fury.deserialize(fury.serialize(seq))) println(fury.deserialize(fury.serialize(list))) println(fury.deserialize(fury.serialize(map)))   Serialize enum:  enum Color { case Red, Green, Blue } println(fury.deserialize(fury.serialize(Color.Green)))   ","version":null,"tagName":"h2"},{"title":"Highlight​","type":1,"pageTitle":"Fury v0.3.0 released","url":"/blog/fury_0_3_0_release#highlight","content":" [Scala] Support scala serialization: case/object/tuple/string/collection/enum/basic all supported[Scala] Add scala user documentation[Scala] add optimized scala singleton object serializer[Java] Make java.io.Externalizable compatible with Java writeReplace/readResolve API[Java] Integrate fury with dubbo https://github.com/apache/dubbo-spi-extensions/pull/226[Java] support bytes string serialization for jdk8 with JDK17 runtime  ","version":null,"tagName":"h2"},{"title":"BugFix​","type":1,"pageTitle":"Fury v0.3.0 released","url":"/blog/fury_0_3_0_release#bugfix","content":" [Java] Allow for InputStream not reading entire length[Java] Use ReflectionUtils.getCtrHandle() for non-public constructor in ExternalizableSerializer[Java] fix jdk compatible serialization for inheritance  ","version":null,"tagName":"h2"},{"title":"What's Changed​","type":1,"pageTitle":"Fury v0.3.0 released","url":"/blog/fury_0_3_0_release#whats-changed","content":" [Impove][Doc] Improve README by @caicancai in https://github.com/alipay/fury/pull/1011[Java] rename wrong ascii naming to latin by @chaokunyang in https://github.com/alipay/fury/pull/1013[Doc] Update go install doc by @chaokunyang in https://github.com/alipay/fury/pull/1015fix(grammatical): correct typos and improve grammar by @iamahens in https://github.com/alipay/fury/pull/1018[Improve][Doc] Improve README by @caicancai in https://github.com/alipay/fury/pull/1020[Improve][Doc] add environment requirement by @caicancai in https://github.com/alipay/fury/pull/1022chore(docs): fixed typos by @Smoothieewastaken in https://github.com/alipay/fury/pull/1023bugfix: read buffer error when object contain binary field by @wangweipeng2 in https://github.com/alipay/fury/pull/1026[Doc] Optimize class registration doc by @chaokunyang in https://github.com/alipay/fury/pull/1027[Java] fix jdk compatible serialization for inheritance by @chaokunyang in https://github.com/alipay/fury/pull/1030[Doc] add scala user doc by @chaokunyang in https://github.com/alipay/fury/pull/1028[Doc] refine scala doc by @chaokunyang in https://github.com/alipay/fury/pull/1031Update README.md - fix grammatrical errors in README. by @ayushrakesh in https://github.com/alipay/fury/pull/1037[Java] Support local static class jit by @chaokunyang in https://github.com/alipay/fury/pull/1036[Java] support bytes string serialization for jdk8 by @chaokunyang in https://github.com/alipay/fury/pull/1039[Java] set timeout to JITContextTest by @chaokunyang in https://github.com/alipay/fury/pull/1040[Java] fix string builder serialization for jdk8 with jdk17 runtime by @chaokunyang in https://github.com/alipay/fury/pull/1042[Doc] add auto code reviewers by @chaokunyang in https://github.com/alipay/fury/pull/1043[Java] Allow for InputStream not reading entire length by @knutwannheden in https://github.com/alipay/fury/pull/1034[Java] Use ReflectionUtils.getCtrHandle() in ExternalizableSerializer by @knutwannheden in https://github.com/alipay/fury/pull/1044[Improve] make maven-spotless-plugin version as a parameter by @caicancai in https://github.com/alipay/fury/pull/1046Update README.md by @Shivam250702 in https://github.com/alipay/fury/pull/1047[Java] support writeReplace/readResolve for Externalizable by @chaokunyang in https://github.com/alipay/fury/pull/1048Update README.md by @Spyrosigma in https://github.com/alipay/fury/pull/1051Grammatical error in CODE_OF_CONDUCT.md by @HimanshuMahto in https://github.com/alipay/fury/pull/1050Update scala link title README.md by @chaokunyang in https://github.com/alipay/fury/pull/1052[Doc] add scala readme and refine document by @chaokunyang in https://github.com/alipay/fury/pull/1041[Java] populate StackOverflowError with enable ref tracking message by @chaokunyang in https://github.com/alipay/fury/pull/1049[Scala] Setup scala project by @chaokunyang in https://github.com/alipay/fury/pull/1054[Scala] add scala singleton object serializer by @chaokunyang in https://github.com/alipay/fury/pull/1053Updated README.md by @vidhijain27 in https://github.com/alipay/fury/pull/1056[Scala] add scala tuple serialization tests by @chaokunyang in https://github.com/alipay/fury/pull/1059Empty ListExpression#genCode will throw npe by @farmerworking in https://github.com/alipay/fury/pull/1063  ","version":null,"tagName":"h2"},{"title":"New Contributors​","type":1,"pageTitle":"Fury v0.3.0 released","url":"/blog/fury_0_3_0_release#new-contributors","content":" @iamahens made their first contribution in https://github.com/alipay/fury/pull/1018@Smoothieewastaken made their first contribution in https://github.com/alipay/fury/pull/1023@ayushrakesh made their first contribution in https://github.com/alipay/fury/pull/1037@knutwannheden made their first contribution in https://github.com/alipay/fury/pull/1034@Shivam250702 made their first contribution in https://github.com/alipay/fury/pull/1047@Spyrosigma made their first contribution in https://github.com/alipay/fury/pull/1051@HimanshuMahto made their first contribution in https://github.com/alipay/fury/pull/1050@vidhijain27 made their first contribution in https://github.com/alipay/fury/pull/1056@farmerworking made their first contribution in https://github.com/alipay/fury/pull/1063  Full Changelog: https://github.com/alipay/fury/compare/v0.2.1...v0.3.0 ","version":null,"tagName":"h2"},{"title":"Fury 0.4.0 Released","type":0,"sectionRef":"#","url":"/blog/fury_0_4_0_release","content":"","keywords":"","version":null},{"title":"Highlight​","type":1,"pageTitle":"Fury 0.4.0 Released","url":"/blog/fury_0_4_0_release#highlight","content":" [Java] Support Graalvm native image. The implementation will generate all serialization code at image build time, the runtime will be extremely fast, see fury graalvm usage doc[Java] Fury vs JDK benchmark on Graalvm native image[Scala] Serialization support for package scoped object[C++] Reflection support by macro/template programing[C++] Automatic row format encoder  ","version":null,"tagName":"h2"},{"title":"What's Changed​","type":1,"pageTitle":"Fury 0.4.0 Released","url":"/blog/fury_0_4_0_release#whats-changed","content":" [Python] fix python release by @chaokunyang in https://github.com/alipay/fury/pull/1125[Java] make unsafe offset compatible with graalvm by @chaokunyang in https://github.com/alipay/fury/pull/1117[Scala] Fix scala package object JIT error by @chaokunyang in https://github.com/alipay/fury/pull/1130[Java] Refine maven pom config by @chaokunyang in https://github.com/alipay/fury/pull/1126[Rust] add rust building by @caicancai in https://github.com/alipay/fury/pull/1129[C++] Remove useless overload of Writer::WriteString by @PragmaTwice in https://github.com/alipay/fury/pull/1136[Rust] fix typo by @caicancai in https://github.com/alipay/fury/pull/1133[Rust] add mesaage about rust ci by @caicancai in https://github.com/alipay/fury/pull/1131[C++] Add move ctor/assign op to Status by @PragmaTwice in https://github.com/alipay/fury/pull/1134[Rust] fix cargo test error by @wangweipeng2 in https://github.com/alipay/fury/pull/1135[Rust] improve rust ci by @caicancai in https://github.com/alipay/fury/pull/1138[Scala] Fix scala collection serialization nested in pojo by @chaokunyang in https://github.com/alipay/fury/pull/1140[Java] make sting builder serializer codegen eager by @chaokunyang in https://github.com/alipay/fury/pull/1141[Rust] fix rust ci bug by @caicancai in https://github.com/alipay/fury/pull/1139[Java] support add static fields in fury codegen by @chaokunyang in https://github.com/alipay/fury/pull/1147[C++] Add the basic row format serializer for C++ class types via reflection by @PragmaTwice in https://github.com/alipay/fury/pull/1144[C++] Add duplicated fields detection in FURY_FIELD_INFO macro by @PragmaTwice in https://github.com/alipay/fury/pull/1151[Java] support create serializer when register class by @chaokunyang in https://github.com/alipay/fury/pull/1154[Java] Support graalvm native image by @chaokunyang in https://github.com/alipay/fury/pull/1143[C++] Support string type in RowEncoder by @PragmaTwice in https://github.com/alipay/fury/pull/1158[Scala] add graalvm support for scala singleton by @chaokunyang in https://github.com/alipay/fury/pull/1159[Scala] Fix scala singleton map/collection serialization in struct by @chaokunyang in https://github.com/alipay/fury/pull/1160[Java] add read resolve circular test suite by @chaokunyang in https://github.com/alipay/fury/pull/1161[Java] Remove load arrow serializers by default by @chaokunyang in https://github.com/alipay/fury/pull/1163[Java] Support thread safe fury for graalvm native image by @chaokunyang in https://github.com/alipay/fury/pull/1164[Scala] Fix package object serialization in scala App by @chaokunyang in https://github.com/alipay/fury/pull/1166[Java] add graalvm usage doc by @chaokunyang in https://github.com/alipay/fury/pull/1168[C++] Split util.h to bit_util.h and time_util.h by @PragmaTwice in https://github.com/alipay/fury/pull/1171[C++] Support cv-qualified types in row encoder by @PragmaTwice in https://github.com/alipay/fury/pull/1172[C++] Add support for nested class types in row encoder by @PragmaTwice in https://github.com/alipay/fury/pull/1173[Java] Add graalvm benchmark by @chaokunyang in https://github.com/alipay/fury/pull/1178[Java] Fix string key serializer ref tracking by @chaokunyang in https://github.com/alipay/fury/pull/1174[Java] Add graalvm benchmark test results by @chaokunyang in https://github.com/alipay/fury/pull/1180[Scala] fix package object inaccessible from source code by @chaokunyang in https://github.com/alipay/fury/pull/1181  Full Changelog: https://github.com/alipay/fury/compare/v0.3.1...v0.4.0 ","version":null,"tagName":"h2"},{"title":"Fury 0.4.1 Released","type":0,"sectionRef":"#","url":"/blog/fury_0_4_1_release","content":"","keywords":"","version":null},{"title":"Highlight​","type":1,"pageTitle":"Fury 0.4.1 Released","url":"/blog/fury_0_4_1_release#highlight","content":" [Rust] Support row format[C++] Support iterable types for RowEncoder[JavaScript] Support partial record[Java] Fix JIT error in corner case, now Fury can generate serializer for every class  ","version":null,"tagName":"h2"},{"title":"What's Changed​","type":1,"pageTitle":"Fury 0.4.1 Released","url":"/blog/fury_0_4_1_release#whats-changed","content":" [Doc] Refine issue template by a yaml form by @chaokunyang in https://github.com/alipay/fury/pull/1185[C++] Fix ownership problem for children writers by visitor by @PragmaTwice in https://github.com/alipay/fury/pull/1193[C++] Remove useless fields and macro in logging by @PragmaTwice in https://github.com/alipay/fury/pull/1195[Doc] add docs for java FuryBuilder #1188 by @mof-dev-3 in https://github.com/alipay/fury/pull/1192[Rust] support row format by @wangweipeng2 in https://github.com/alipay/fury/pull/1196[C++] Add RowEncoder wrapper to RowEncodeTrait by @PragmaTwice in https://github.com/alipay/fury/pull/1200[Rust] Row support more types by @wangweipeng2 in https://github.com/alipay/fury/pull/1202[Rust] Support row map by @wangweipeng2 in https://github.com/alipay/fury/pull/1206[C++] update bazel version from 4.2 to 6.3.2 by @chaokunyang in https://github.com/alipay/fury/pull/1204[JavaScript] Support partial record by @wangweipeng2 in https://github.com/alipay/fury/pull/1208[Java] fix package access level class accessor jit by @chaokunyang in https://github.com/alipay/fury/pull/1210[JavaScript] Fix register a description twice will get undefined serializer by @bytemain in https://github.com/alipay/fury/pull/1211[C++] Support iterable types in RowEncodeTrait by @PragmaTwice in https://github.com/alipay/fury/pull/1212[C++] Support iterable types for RowEncoder by @PragmaTwice in https://github.com/alipay/fury/pull/1215[Python] Refine py register class method by @chaokunyang in https://github.com/alipay/fury/pull/1218[Java] Clear extRegistry.getClassCtx if generate serializer class failed in https://github.com/alipay/fury/pull/1221  ","version":null,"tagName":"h2"},{"title":"New Contributors​","type":1,"pageTitle":"Fury 0.4.1 Released","url":"/blog/fury_0_4_1_release#new-contributors","content":" @bytemain made their first contribution in https://github.com/alipay/fury/pull/1211  Full Changelog: https://github.com/alipay/fury/compare/v0.4.0...v0.4.1 ","version":null,"tagName":"h2"},{"title":"Fury - A blazing fast multi-language serialization framework powered by jit and zero-copy","type":0,"sectionRef":"#","url":"/blog/fury_blazing_fast_multiple_language_serialization_framework","content":"","keywords":"","version":null},{"title":"Serialization Primitives​","type":1,"pageTitle":"Fury - A blazing fast multi-language serialization framework powered by jit and zero-copy","url":"/blog/fury_blazing_fast_multiple_language_serialization_framework#serialization-primitives","content":" Common serialization operations contains:  bitmap operationsnumber encoding/decodingint/long compressionString creation/copyString encoding: ASCII/UTF8/UTF16memory copyarray copy&amp;compressionmeta encoding&amp;compression&amp;cache  Fury use SIMD and other advanced language features to make basic operations extremely fast in every languages.  ","version":null,"tagName":"h2"},{"title":"Zero-Copy Serialization​","type":1,"pageTitle":"Fury - A blazing fast multi-language serialization framework powered by jit and zero-copy","url":"/blog/fury_blazing_fast_multiple_language_serialization_framework#zero-copy-serialization","content":" Large-scale data transfer often has multiple binary buffers in an object graph. Some serialization frameworks will write the binaries into an intermediate buffer and introduce multiple time-consuming memory copies. Fury implemented an out-of-band serialization protocol inspired by pickle5, ray and arrow, which cancapture all binary buffers in an object graph to avoid intermediate copies of these buffers. The following figure shows the serialization process of zero-copy:    Currently, Fury supports the following types of zero-copy:  java: all basic types of arrays, ByteBuffer, ArrowRecordBatch, and VectorSchemaRootpython: all arrays of the array module, numpy arrays, pyarrow.Table, and pyarrow.RecordBatchgolang:byte slice  You can also add the new zero copy type based on the Fury interface.  ","version":null,"tagName":"h2"},{"title":"JIT dynamic compilation acceleration​","type":1,"pageTitle":"Fury - A blazing fast multi-language serialization framework powered by jit and zero-copy","url":"/blog/fury_blazing_fast_multiple_language_serialization_framework#jit-dynamic-compilation-acceleration","content":" Custom type objects usually contain lots of type information, Fury used this information to generate efficient serialization code at runtime, which can push lots of runtime operations into the dynamic compilation stage. By inlining more methods, better code cache, reducing virtual method calls, conditional branches, hash lookup, metadata writes, and memory reads/writes, the serialization performance is greatly accelerated.  For Java, Fury implements a runtime codegen framework and defines an operator expression IR. Then fury can perform type inference based on the generic type information of the object at runtime to build an expression tree that describes the logic of serialized code. The codegen framework will generate efficient Java code from the expression tree, then pass to Janino to compile it into bytecode, and load it into the user's ClassLoader or the ClassLoader created by Fury, and finally compile it into efficient assembly code through Java JIT.  Since JVM JIT skips Big method compilation and inlining, Fury also implements an optimizer to split big methods into small methods recursively, thus ensuring that all code can be compiled and inlined.    Fury also supports asynchronous multithreaded compilation by running the codegen tasks in a thread pool, and using interpretation mode until JIT finishes to ensure no serialization burrs. Users can skip warm up serialization of objects.  Python and JavaScript codegen are similar. Generating source code is easier for development and troubleshooting problems.  Since serialization will manipulate objects extensively in each programming language, and the language does not expose the low-level API of the memory model, native methods call has a large cost too, so we cannot use LLVM to build a unified serializer JIT framework. Instead, we implemented a codegen framework for every language separately.  ","version":null,"tagName":"h2"},{"title":"Static code generation​","type":1,"pageTitle":"Fury - A blazing fast multi-language serialization framework powered by jit and zero-copy","url":"/blog/fury_blazing_fast_multiple_language_serialization_framework#static-code-generation","content":" Although JIT compilation can greatly improve serialization efficiency and generate better serialization code based on the statistical distribution of data at runtime, languages like C++ do not support reflection, have no virtual machines, and no low-level API for memory models. We cannot generate serialization code dynamically for such languages through JIT.  In such scenarios, Fury is implementing an AOT codegen framework, which generates the serialized code statically according to the object schema, and objects can be serialized automatically using the generated serializer. For Rust, Rust macro is used to generate code statically.  ","version":null,"tagName":"h2"},{"title":"Cache optimization​","type":1,"pageTitle":"Fury - A blazing fast multi-language serialization framework powered by jit and zero-copy","url":"/blog/fury_blazing_fast_multiple_language_serialization_framework#cache-optimization","content":" When serializing a custom type, fury will reorder fields to ensure that fields of the same type are serialized in order. This can hit more data cache and CPU instruction cache.  The basic type fields are written in descending order by byte size. In this way, if the initial addresses are aligned, subsequent read and write operations will occur at the position where the memory addresses are aligned, making CPU execution more efficient.  Multi-protocol Design and Implementation  Based on the multi-language serialization features provided by Fury core, we have built three serialization protocols for different scenarios:  Java serialization: suitable for pure Java serialization scenarios and provides up to170x speed up;Cross-language object graph serialization: suitable for application-oriented multi-language programming and high-performance cross-language serialization;Row-format serialization: suitable for distributed computing engines such as Spark/Flink/Dories/Velox/Features frameworks;  In the future, we will add new protocols for other core scenarios. Users can also build their own protocols based on Fury's serialization framework.  ","version":null,"tagName":"h2"},{"title":"Java serialization​","type":1,"pageTitle":"Fury - A blazing fast multi-language serialization framework powered by jit and zero-copy","url":"/blog/fury_blazing_fast_multiple_language_serialization_framework#java-serialization","content":" Java is widely used in big data, cloud native, microservices, and enterprise applications. Therefore, Fury made lots of optimizations for Java serialization, which reduces system latency and server costs a lot, and improves throughput significantly. Our implementation has the following highlights:  Blazing fast performance: Based on Java types, JIT compilation and Unsafe low-level operations, Fury is 170x faster than JDK, and 50~110x faster than Kryo/Hessian at most.100% JDK serialization API compatibility : supports all JDK custom serialization methods writeObject/readObject/writeReplace/readResolve/readObjectNoData natively to ensure the serialization correctness in any scenario. Kryo/Hessian have some correctness issues in these scenarios.Type compatibility: When the deserialization and serialization class schema are inconsistent, it can still deserialize correctly. It supports application upgrade and deployment, add/delete fields independently. Fury type-compatible mode is implemented with no performance loss compared to type-consistent mode.Metadata sharing : share metadata(class name, field name&amp;type, etc.) across multiple serializations under a context (TCP connection), meta will be sent to the peer only for the first serialization, the peer can reconstruct the same deserializer based on this information. Subsequent serialization will skip transferring metadata, which can reduce network traffic, and support type compatibility automatically.Zero copy support: supports out-of-band zero copy and off-heap memory read/write.  ","version":null,"tagName":"h2"},{"title":"Cross-language object graph serialization​","type":1,"pageTitle":"Fury - A blazing fast multi-language serialization framework powered by jit and zero-copy","url":"/blog/fury_blazing_fast_multiple_language_serialization_framework#cross-language-object-graph-serialization","content":" Fury cross-language object graph serialization is primarily used for scenarios that require higher dynamics and ease-of-use. Although frameworks like Protobuf/Flatbuffers support cross-language serialization, they still have limitations:  They require pre-defined IDLs and generate code statically ahead, lacking sufficient dynamics and flexibility;The generated classes don't conform to object-oriented design and it's impossible to add behavior to classes, which make them unsuitable for use as domain objects in cross-language application development.They don't support polymorphism. Object-oriented programming uses interfaces to invoke subclass methods, but this pattern isn't supported well in those frameworks. Although Flatbuffers offers Union, and Protobuf provides OneOf/Any, those API require check object type during serialization and deserialization, which isn't polymorphic.They don't support circular references and shared references. Users need to define a set of IDLs for domain objects and implement reference resolution by themselves, as well as writing code to convert between domain objects and protocol objects in each language. If the object graph depth is deep, more code needs to be written.  Due to the above limitations, Fury implemented a cross-language object graph serialization protocol that:  Automatically serializes any object across multiple languages: By defining classes in the serialization and deserialization peer, objects in one language can be automatically serialized into objects in another language without creating IDL files, compiling schema to generate code, or writing conversion code.Automatically serializes shared and circular references across multiple languages.Supports object type polymorphism, consistent with the object-oriented programming paradigm, and multiple subtypes can be automatically deserialized without manual intervention.Out-of-band zero-copy is also supported in this protocol.  Example of Automatic Cross-Language Serialization:    ","version":null,"tagName":"h2"},{"title":"Row-format​","type":1,"pageTitle":"Fury - A blazing fast multi-language serialization framework powered by jit and zero-copy","url":"/blog/fury_blazing_fast_multiple_language_serialization_framework#row-format","content":" For high-performance computing and large-scale data transfer scenarios, data serialization and transfer are often the performance bottlenecks of the system. If users only need to read part of the data or filter data based on some field of an object, deserializing the entire data will result in unnecessary overhead. Therefore, Fury provides a binary data structure for direct reading and writing on binary data to avoid serialization.  Apache Arrow is a standardized columnar storage format that supports binary read and write. However, columnar format is not suitable for all scenarios. Data in online and streaming computing are naturally stored row by row, and row is also used in columnar computing engines when involving data updates, Hash/Join/Aggregation operations.  However, there is no standardized implementation for row format.Computing engines such as Spark/Flink/Doris/Velox all defined their row format, which doesn't support cross-language and can only be used internally by themselves. Flatbuffers does support lazy deserialization, but it requires static compilation of schema IDL and management of offset, which is impossible for complex scenarios.  Therefore, Fury implemented a binary row format inspired by Spark Tungstenand Apache Arrow format, which allows random access and partial deserialization. Currently, Java/Python/C++ versions have been implemented, allowing direct reading and writing on binary data to avoid all serialization overhead, and can convert to arrow format automatically.    This format is densely stored, byte aligned and cache-friendly, which enables faster read and write operations. By avoiding deserialization, it reduces Java GC pressure and Python overhead. Based on Python's dynamics, Fury's data structure implements special methods such as getattr_/getitem/slice/etc., ensuring behavior consistency with Python dataclass/list/object, and users have no perception of this.  Performance Comparison  Here are some Java serialization performance data, where charts with &quot;compatible&quot; in the title are performance data under type compatible mode: support type forward/backward compatibility. and charts without &quot;compatible&quot; in the title are performance data without type compatibility: class schema must be same between serialization and deserialization. For fairness, Fury disabled the zero-copy feature for all tests.        Future planning(RoadMap)  Meta compression, auto meta sharing and cross-language schema compatibility.AOT Framework for c++/golang to generate code statically.C++/Rust object graph serialization supportGolang/Rust/NodeJS row format supportProtoBuf compatibility supportProtocols for features and knowledge graph serializationContinuously improve our serialization infrastructure for any new protocols  Join US  We are committed to building Fury into an open and neutral community project that pursues passion and innovation. The development and discussion are open-sourced and transparent in the community. Any form of participation is welcome, including but not limited to questions, code contributions, technical discussions, etc. We are looking forward to receiving your ideas and feedback, participating in the project together, pushing the project forward and creating a better serialization framework.  The GitHub address of the fury repository is:https://github.com/alipay/fury  Official website: https://furyio.org  All issues, PR, and Discussion are welcome. ","version":null,"tagName":"h2"},{"title":"How to build Fury","type":0,"sectionRef":"#","url":"/docs/guide/development","content":"","keywords":"","version":"Next"},{"title":"Build Fury Java​","type":1,"pageTitle":"How to build Fury","url":"/docs/guide/development#build-fury-java","content":" cd java mvn clean compile -DskipTests   Environment Requirements​  java 1.8+maven 3.6.3+  ","version":"Next","tagName":"h3"},{"title":"Build Fury Python​","type":1,"pageTitle":"How to build Fury","url":"/docs/guide/development#build-fury-python","content":" cd python pip install pyarrow==14.0.0 Cython wheel numpy pytest pip install -v -e .   Environment Requirements​  python 3.6+  ","version":"Next","tagName":"h3"},{"title":"Build Fury C++​","type":1,"pageTitle":"How to build Fury","url":"/docs/guide/development#build-fury-c","content":" Build fury row format：  pip install pyarrow==14.0.0 bazel build //cpp/fury/row:fury_row_format   Build fury row format encoder:  pip install pyarrow==14.0.0 bazel build //cpp/fury/encoder:fury_encoder   Environment Requirements​  compilers with C++17 supportbazel 6.3.2  ","version":"Next","tagName":"h3"},{"title":"Build Fury GoLang​","type":1,"pageTitle":"How to build Fury","url":"/docs/guide/development#build-fury-golang","content":" cd go/fury # run test go test -v # run xlang test go test -v fury_xlang_test.go   Environment Requirements​  go 1.13+  ","version":"Next","tagName":"h3"},{"title":"Build Fury Rust​","type":1,"pageTitle":"How to build Fury","url":"/docs/guide/development#build-fury-rust","content":" cd rust # build cargo build # run test cargo test   Environment Requirements​  curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh   ","version":"Next","tagName":"h3"},{"title":"Build Fury JavaScript​","type":1,"pageTitle":"How to build Fury","url":"/docs/guide/development#build-fury-javascript","content":" cd javascript npm install # run build npm run build # run test npm run test   Environment Requirements​  node 14+npm 8+ ","version":"Next","tagName":"h3"},{"title":"GraalVM Native Image","type":0,"sectionRef":"#","url":"/docs/guide/graalvm_guide","content":"","keywords":"","version":"Next"},{"title":"Not thread-safe Fury​","type":1,"pageTitle":"GraalVM Native Image","url":"/docs/guide/graalvm_guide#not-thread-safe-fury","content":" Example:  import org.apache.fury.Fury; import org.apache.fury.util.Preconditions; import java.util.List; import java.util.Map; public class Example { public record Record ( int f1, String f2, List&lt;String&gt; f3, Map&lt;String, Long&gt; f4) { } static Fury fury; static { fury = Fury.builder().build(); // register and generate serializer code. fury.register(Record.class, true); } public static void main(String[] args) { Record record = new Record(10, &quot;abc&quot;, List.of(&quot;str1&quot;, &quot;str2&quot;), Map.of(&quot;k1&quot;, 10L, &quot;k2&quot;, 20L)); System.out.println(record); byte[] bytes = fury.serialize(record); Object o = fury.deserialize(bytes); System.out.println(o); Preconditions.checkArgument(record.equals(o)); } }   Then add org.apache.fury.graalvm.Example build time init to native-image.properties configuration:  Args = --initialize-at-build-time=org.apache.fury.graalvm.Example   ","version":"Next","tagName":"h2"},{"title":"Thread-safe Fury​","type":1,"pageTitle":"GraalVM Native Image","url":"/docs/guide/graalvm_guide#thread-safe-fury","content":" import org.apache.fury.Fury; import org.apache.fury.ThreadLocalFury; import org.apache.fury.ThreadSafeFury; import org.apache.fury.util.Preconditions; import java.util.List; import java.util.Map; public class ThreadSafeExample { public record Foo ( int f1, String f2, List&lt;String&gt; f3, Map&lt;String, Long&gt; f4) { } static ThreadSafeFury fury; static { fury = new ThreadLocalFury(classLoader -&gt; { Fury f = Fury.builder().build(); // register and generate serializer code. f.register(Foo.class, true); return f; }); } public static void main(String[] args) { System.out.println(fury.deserialize(fury.serialize(&quot;abc&quot;))); System.out.println(fury.deserialize(fury.serialize(List.of(1,2,3)))); System.out.println(fury.deserialize(fury.serialize(Map.of(&quot;k1&quot;, 1, &quot;k2&quot;, 2)))); Foo foo = new Foo(10, &quot;abc&quot;, List.of(&quot;str1&quot;, &quot;str2&quot;), Map.of(&quot;k1&quot;, 10L, &quot;k2&quot;, 20L)); System.out.println(foo); byte[] bytes = fury.serialize(foo); Object o = fury.deserialize(bytes); System.out.println(o); } }   Then add org.apache.fury.graalvm.ThreadSafeExample build time init to native-image.properties configuration:  Args = --initialize-at-build-time=org.apache.fury.graalvm.ThreadSafeExample   ","version":"Next","tagName":"h2"},{"title":"Framework Integration​","type":1,"pageTitle":"GraalVM Native Image","url":"/docs/guide/graalvm_guide#framework-integration","content":" For framework developers, if you want to integrate fury for serialization, you can provided a configuration file to let the users to list all the classes they want to serialize, then you can load those classes and invokeorg.apache.fury.Fury.register(Class&lt;?&gt;, boolean) to register those classes in your Fury integration class, and configure that class be initialized at graalvm native image build time.  ","version":"Next","tagName":"h2"},{"title":"Benchmark​","type":1,"pageTitle":"GraalVM Native Image","url":"/docs/guide/graalvm_guide#benchmark","content":" Here we give two class benchmarks between Fury and Graalvm Serialization.  When Fury compression is disabled:  Struct: Fury is 46x speed, 43% size compared to JDK.Pojo: Fury is 12x speed, 56% size compared to JDK.  When Fury compression is enabled:  Struct: Fury is 24x speed, 31% size compared to JDK.Pojo: Fury is 12x speed, 48% size compared to JDK.  See [Benchmark.java] for benchmark code.  ","version":"Next","tagName":"h2"},{"title":"Struct Benchmark​","type":1,"pageTitle":"GraalVM Native Image","url":"/docs/guide/graalvm_guide#struct-benchmark","content":" Class Fields​  public class Struct implements Serializable { public int f1; public long f2; public float f3; public double f4; public int f5; public long f6; public float f7; public double f8; public int f9; public long f10; public float f11; public double f12; }   Benchmark Results​  No compression:  Benchmark repeat number: 400000 Object type: class org.apache.fury.graalvm.Struct Compress number: false Fury size: 76.0 JDK size: 178.0 Fury serialization took mills: 49 JDK serialization took mills: 2254 Compare speed: Fury is 45.70x speed of JDK Compare size: Fury is 0.43x size of JDK   Compress number:  Benchmark repeat number: 400000 Object type: class org.apache.fury.graalvm.Struct Compress number: true Fury size: 55.0 JDK size: 178.0 Fury serialization took mills: 130 JDK serialization took mills: 3161 Compare speed: Fury is 24.16x speed of JDK Compare size: Fury is 0.31x size of JDK   ","version":"Next","tagName":"h3"},{"title":"Pojo Benchmark​","type":1,"pageTitle":"GraalVM Native Image","url":"/docs/guide/graalvm_guide#pojo-benchmark","content":" Class Fields​  public class Foo implements Serializable { int f1; String f2; List&lt;String&gt; f3; Map&lt;String, Long&gt; f4; }   Benchmark Results​  No compression:  Benchmark repeat number: 400000 Object type: class org.apache.fury.graalvm.Foo Compress number: false Fury size: 541.0 JDK size: 964.0 Fury serialization took mills: 1663 JDK serialization took mills: 16266 Compare speed: Fury is 12.19x speed of JDK Compare size: Fury is 0.56x size of JDK   Compress number:  Benchmark repeat number: 400000 Object type: class org.apache.fury.graalvm.Foo Compress number: true Fury size: 459.0 JDK size: 964.0 Fury serialization took mills: 1289 JDK serialization took mills: 15069 Compare speed: Fury is 12.11x speed of JDK Compare size: Fury is 0.48x size of JDK  ","version":"Next","tagName":"h3"},{"title":"Scala serialization","type":0,"sectionRef":"#","url":"/docs/guide/scala_guide","content":"","keywords":"","version":"Next"},{"title":"Install​","type":1,"pageTitle":"Scala serialization","url":"/docs/guide/scala_guide#install","content":" libraryDependencies += &quot;org.apache.fury&quot; % &quot;fury-core&quot; % &quot;0.4.1&quot;   ","version":"Next","tagName":"h2"},{"title":"Fury creation​","type":1,"pageTitle":"Scala serialization","url":"/docs/guide/scala_guide#fury-creation","content":" When using fury for scala serialization, you should create fury at least with following options:  val fury = Fury.builder() .withScalaOptimizationEnabled(true) .requireClassRegistration(true) .withRefTracking(true) .build()   Depending on the object types you serialize, you may need to register some scala internal types:  fury.register(Class.forName(&quot;scala.collection.generic.DefaultSerializationProxy&quot;)) fury.register(Class.forName(&quot;scala.Enumeration.Val&quot;))   If you want to avoid such registration, you can disable class registration by FuryBuilder#requireClassRegistration(false). Note that this option allow to deserialize objects unknown types, more flexible but may be insecure if the classes contains malicious code.  And circular references are common in scala, Reference tracking should be enabled by FuryBuilder#withRefTracking(true). If you don't enable reference tracking, StackOverflowError may happen for some scala versions when serializing scala Enumeration.  Note that fury instance should be shared between multiple serialization, the creation of fury instance is not cheap.  If you use shared fury instance across multiple threads, you should create ThreadSafeFury instead by FuryBuilder#buildThreadSafeFury() instead.  ","version":"Next","tagName":"h2"},{"title":"Serialize case object​","type":1,"pageTitle":"Scala serialization","url":"/docs/guide/scala_guide#serialize-case-object","content":" case class Person(github: String, age: Int, id: Long) val p = Person(&quot;https://github.com/chaokunyang&quot;, 18, 1) println(fury.deserialize(fury.serialize(p))) println(fury.deserializeJavaObject(fury.serializeJavaObject(p)))   ","version":"Next","tagName":"h2"},{"title":"Serialize pojo​","type":1,"pageTitle":"Scala serialization","url":"/docs/guide/scala_guide#serialize-pojo","content":" class Foo(f1: Int, f2: String) { override def toString: String = s&quot;Foo($f1, $f2)&quot; } println(fury.deserialize(fury.serialize(Foo(1, &quot;chaokunyang&quot;))))   ","version":"Next","tagName":"h2"},{"title":"Serialize object singleton​","type":1,"pageTitle":"Scala serialization","url":"/docs/guide/scala_guide#serialize-object-singleton","content":" object singleton { } val o1 = fury.deserialize(fury.serialize(singleton)) val o2 = fury.deserialize(fury.serialize(singleton)) println(o1 == o2)   ","version":"Next","tagName":"h2"},{"title":"Serialize collection​","type":1,"pageTitle":"Scala serialization","url":"/docs/guide/scala_guide#serialize-collection","content":" val seq = Seq(1,2) val list = List(&quot;a&quot;, &quot;b&quot;) val map = Map(&quot;a&quot; -&gt; 1, &quot;b&quot; -&gt; 2) println(fury.deserialize(fury.serialize(seq))) println(fury.deserialize(fury.serialize(list))) println(fury.deserialize(fury.serialize(map)))   ","version":"Next","tagName":"h2"},{"title":"Serialize Tuple​","type":1,"pageTitle":"Scala serialization","url":"/docs/guide/scala_guide#serialize-tuple","content":" val tuple = Tuple2(100, 10000L) println(fury.deserialize(fury.serialize(tuple))) val tuple = Tuple4(100, 10000L, 10000L, &quot;str&quot;) println(fury.deserialize(fury.serialize(tuple)))   ","version":"Next","tagName":"h2"},{"title":"Serialize Enum​","type":1,"pageTitle":"Scala serialization","url":"/docs/guide/scala_guide#serialize-enum","content":" ","version":"Next","tagName":"h2"},{"title":"Scala3 Enum​","type":1,"pageTitle":"Scala serialization","url":"/docs/guide/scala_guide#scala3-enum","content":" enum Color { case Red, Green, Blue } println(fury.deserialize(fury.serialize(Color.Green)))   ","version":"Next","tagName":"h3"},{"title":"Scala2 Enum​","type":1,"pageTitle":"Scala serialization","url":"/docs/guide/scala_guide#scala2-enum","content":" object ColorEnum extends Enumeration { type ColorEnum = Value val Red, Green, Blue = Value } println(fury.deserialize(fury.serialize(ColorEnum.Green)))   ","version":"Next","tagName":"h3"},{"title":"Serialize Option​","type":1,"pageTitle":"Scala serialization","url":"/docs/guide/scala_guide#serialize-option","content":" val opt: Option[Long] = Some(100) println(fury.deserialize(fury.serialize(opt))) val opt1: Option[Long] = None println(fury.deserialize(fury.serialize(opt1)))   Performance  Scala pojo/bean/case/object are supported by fury jit well, the performance is as good as fury java.  Scala collections and generics doesn't follow java collection framework, and is not fully integrated with Fury JIT in current release version. The performance won't be as good as fury collections serialization for java.  The execution for scala collections will invoke Java serialization API writeObject/readObject/writeReplace/readResolve/readObjectNoData/Externalizable with fury ObjectStream implementation. Although org.apache.fury.serializer.ObjectStreamSerializer is much faster than JDK ObjectOutputStream/ObjectInputStream, but it still doesn't know how use scala collection generics.  In future we plan to provide more optimization for scala types, see https://github.com/apache/incubator-fury/issues/682, stay tuned!  Scala collections serialization is finished in https://github.com/apache/incubator-fury/pull/1073, if you want better performance, please use fury snapshot version. ","version":"Next","tagName":"h2"},{"title":"Type Mapping of Xlang Serialization","type":0,"sectionRef":"#","url":"/docs/guide/xlang_type_mapping","content":"Type Mapping of Xlang Serialization Coming soon.","keywords":"","version":"Next"},{"title":"Introduction","type":0,"sectionRef":"#","url":"/docs/introduction/","content":"","keywords":"","version":"Next"},{"title":"Protocols​","type":1,"pageTitle":"Introduction","url":"/docs/introduction/#protocols","content":" Different scenarios have different serialization requirements. Fury designed and implemented multiple binary protocols for those requirements:  Cross-language object graph protocol: Cross-language serialize any object automatically, no need for IDL definition, schema compilation and object to/from protocol conversion.Support shared reference and circular reference, no duplicate data or recursion error.Support object polymorphism. Native java/python object graph protocol: highly-optimized based on type system of the language.Row format protocol: a cache-friendly binary random access format, supports skipping serialization and partial serialization, and can convert to column-format automatically.  New protocols can be added easily based on fury existing buffer, encoding, meta, codegen and other capabilities. All of those share same codebase, and the optimization for one protocol can be reused by another protocol.  ","version":"Next","tagName":"h2"},{"title":"Compatibility​","type":1,"pageTitle":"Introduction","url":"/docs/introduction/#compatibility","content":" ","version":"Next","tagName":"h2"},{"title":"Schema Compatibility​","type":1,"pageTitle":"Introduction","url":"/docs/introduction/#schema-compatibility","content":" Fury java object graph serialization support class schema forward/backward compatibility. The serialization peer and deserialization peer can add/delete fields independently.  We plan to add support cross-language serialization after meta compression are finished.  ","version":"Next","tagName":"h3"},{"title":"Binary Compatibility​","type":1,"pageTitle":"Introduction","url":"/docs/introduction/#binary-compatibility","content":" We are still improving our protocols, binary compatibility are not ensured between fury releases for now. Please shade fury if you will upgrade fury in the future.  Binary compatibility will be ensured before fury 1.0.  ","version":"Next","tagName":"h3"},{"title":"Security​","type":1,"pageTitle":"Introduction","url":"/docs/introduction/#security","content":" Static serialization such as row format are secure by nature. But dynamic object graph serialization supports deserialize unregistered types, which can introduce security risks.  For example, the deserialization may invoke init constructor or equals/hashCode method, if the method body contains malicious code, the system will be at risks.  Fury provides a class registration mode option and enabled by default for this protocol, which allows deserializing trusted registered types or built-in types only for security.  Fury provides a class registration option and enabled by default for such protocols, which allows only deserializing trusted registered types or built-in types. Do not disable class registration or class registration checks unless you can ensure your environment is indeed secure. We are not responsible for security if you disabled the class registration option.  ","version":"Next","tagName":"h2"},{"title":"RoadMap​","type":1,"pageTitle":"Introduction","url":"/docs/introduction/#roadmap","content":" Meta compression, auto meta sharing and cross-language schema compatibility.AOT Framework for c++/golang to generate code statically.C++/Rust object graph serialization supportGolang/Rust/NodeJS row format supportProtoBuffer compatibility supportProtocols for features and knowledge graph serializationContinuously improve our serialization infrastructure for any new protocols  ","version":"Next","tagName":"h2"},{"title":"How to Contribute​","type":1,"pageTitle":"Introduction","url":"/docs/introduction/#how-to-contribute","content":" Please read the CONTRIBUTING guide for instructions on how to contribute. ","version":"Next","tagName":"h2"},{"title":"Row Format Guide","type":0,"sectionRef":"#","url":"/docs/guide/row_format_guide","content":"","keywords":"","version":"Next"},{"title":"Row format protocol​","type":1,"pageTitle":"Row Format Guide","url":"/docs/guide/row_format_guide#row-format-protocol","content":" ","version":"Next","tagName":"h2"},{"title":"Java​","type":1,"pageTitle":"Row Format Guide","url":"/docs/guide/row_format_guide#java","content":" public class Bar { String f1; List&lt;Long&gt; f2; } public class Foo { int f1; List&lt;Integer&gt; f2; Map&lt;String, Integer&gt; f3; List&lt;Bar&gt; f4; } RowEncoder&lt;Foo&gt; encoder = Encoders.bean(Foo.class); Foo foo = new Foo(); foo.f1 = 10; foo.f2 = IntStream.range(0, 1000000).boxed().collect(Collectors.toList()); foo.f3 = IntStream.range(0, 1000000).boxed().collect(Collectors.toMap(i -&gt; &quot;k&quot;+i, i-&gt;i)); List&lt;Bar&gt; bars = new ArrayList&lt;&gt;(1000000); for (int i = 0; i &lt; 1000000; i++) { Bar bar = new Bar(); bar.f1 = &quot;s&quot;+i; bar.f2 = LongStream.range(0, 10).boxed().collect(Collectors.toList()); bars.add(bar); } foo.f4 = bars; // Can be zero-copy read by python BinaryRow binaryRow = encoder.toRow(foo); // can be data from python Foo newFoo = encoder.fromRow(binaryRow); // zero-copy read List&lt;Integer&gt; f2 BinaryArray binaryArray2 = binaryRow.getArray(1); // zero-copy read List&lt;Bar&gt; f4 BinaryArray binaryArray4 = binaryRow.getArray(3); // zero-copy read 11th element of `readList&lt;Bar&gt; f4` BinaryRow barStruct = binaryArray4.getStruct(10); // zero-copy read 6th of f2 of 11th element of `readList&lt;Bar&gt; f4` barStruct.getArray(1).getLong(5); RowEncoder&lt;Bar&gt; barEncoder = Encoders.bean(Bar.class); // deserialize part of data. Bar newBar = barEncoder.fromRow(barStruct); Bar newBar2 = barEncoder.fromRow(binaryArray4.getStruct(20));   ","version":"Next","tagName":"h3"},{"title":"Python​","type":1,"pageTitle":"Row Format Guide","url":"/docs/guide/row_format_guide#python","content":" @dataclass class Bar: f1: str f2: List[pa.int64] @dataclass class Foo: f1: pa.int32 f2: List[pa.int32] f3: Dict[str, pa.int32] f4: List[Bar] encoder = pyfury.encoder(Foo) foo = Foo(f1=10, f2=list(range(1000_000)), f3={f&quot;k{i}&quot;: i for i in range(1000_000)}, f4=[Bar(f1=f&quot;s{i}&quot;, f2=list(range(10))) for i in range(1000_000)]) binary: bytes = encoder.to_row(foo).to_bytes() print(f&quot;start: {datetime.datetime.now()}&quot;) foo_row = pyfury.RowData(encoder.schema, binary) print(foo_row.f2[100000], foo_row.f4[100000].f1, foo_row.f4[200000].f2[5]) print(f&quot;end: {datetime.datetime.now()}&quot;) binary = pickle.dumps(foo) print(f&quot;pickle start: {datetime.datetime.now()}&quot;) new_foo = pickle.loads(binary) print(new_foo.f2[100000], new_foo.f4[100000].f1, new_foo.f4[200000].f2[5]) print(f&quot;pickle end: {datetime.datetime.now()}&quot;)   ","version":"Next","tagName":"h3"},{"title":"Apache Arrow Support​","type":1,"pageTitle":"Row Format Guide","url":"/docs/guide/row_format_guide#apache-arrow-support","content":" Fury Format also supports automatic conversion from/to Arrow Table/RecordBatch.  Java:  Schema schema = TypeInference.inferSchema(BeanA.class); ArrowWriter arrowWriter = ArrowUtils.createArrowWriter(schema); Encoder&lt;BeanA&gt; encoder = Encoders.rowEncoder(BeanA.class); for (int i = 0; i &lt; 10; i++) { BeanA beanA = BeanA.createBeanA(2); arrowWriter.write(encoder.toRow(beanA)); } return arrowWriter.finishAsRecordBatch();   Python:  import pyfury encoder = pyfury.encoder(Foo) encoder.to_arrow_record_batch([foo] * 10000) encoder.to_arrow_table([foo] * 10000)   C++  std::shared_ptr&lt;ArrowWriter&gt; arrow_writer; EXPECT_TRUE( ArrowWriter::Make(schema, ::arrow::default_memory_pool(), &amp;arrow_writer) .ok()); for (auto &amp;row : rows) { EXPECT_TRUE(arrow_writer-&gt;Write(row).ok()); } std::shared_ptr&lt;::arrow::RecordBatch&gt; record_batch; EXPECT_TRUE(arrow_writer-&gt;Finish(&amp;record_batch).ok()); EXPECT_TRUE(record_batch-&gt;Validate().ok()); EXPECT_EQ(record_batch-&gt;num_columns(), schema-&gt;num_fields()); EXPECT_EQ(record_batch-&gt;num_rows(), row_nums);   Schema schema = TypeInference.inferSchema(BeanA.class); ArrowWriter arrowWriter = ArrowUtils.createArrowWriter(schema); Encoder&lt;BeanA&gt; encoder = Encoders.rowEncoder(BeanA.class); for (int i = 0; i &lt; 10; i++) { BeanA beanA = BeanA.createBeanA(2); arrowWriter.write(encoder.toRow(beanA)); } return arrowWriter.finishAsRecordBatch();  ","version":"Next","tagName":"h3"},{"title":"Benchmark","type":0,"sectionRef":"#","url":"/docs/introduction/benchmark","content":"","keywords":"","version":"Next"},{"title":"Java Serialization​","type":1,"pageTitle":"Benchmark","url":"/docs/introduction/benchmark#java-serialization","content":"         ","version":"Next","tagName":"h3"},{"title":"Java Deserialization​","type":1,"pageTitle":"Benchmark","url":"/docs/introduction/benchmark#java-deserialization","content":"         See benchmarks for more benchmarks about type forward/backward compatibility, off-heap support, zero-copy serialization.  ","version":"Next","tagName":"h3"},{"title":"JavaScript​","type":1,"pageTitle":"Benchmark","url":"/docs/introduction/benchmark#javascript","content":"   The data used for this bar graph includes a complex object that has many kinds of field types, and the size of the JSON data is 3KB.  See benchmarks for the benchmark code. ","version":"Next","tagName":"h3"},{"title":"Features","type":0,"sectionRef":"#","url":"/docs/introduction/features","content":"Features Multiple languages: Java/Python/C++/Golang/Javascript/Rust.Zero-copy: cross-language out-of-band serialization inspired by pickle5 and off-heap read/write.High performance: A highly-extensible JIT framework to generate serializer code at runtime in an async multi-thread way to speed serialization, providing 20-170x speed up by: reduce memory access by inline variable in generated code.reduce virtual method invocation by inline call in generated code.reduce conditional branching.reduce hash lookup.binary protocols: object graph, row format and so on. In addition to cross-language serialization, Fury also features at: Drop-in replace Java serialization frameworks such as JDK/Kryo/Hessian without modifying any code, but 100x faster. It can greatly improve the efficiency of high-performance RPC calls, data transfer and object persistence.JDK serialization 100% compatible, support java custom serializationwriteObject/readObject/writeReplace/readResolve/readObjectNoData natively.Supports shared and circular reference object serialization for golang.Supports automatic object serialization for golang.","keywords":"","version":"Next"},{"title":"Row Format","type":0,"sectionRef":"#","url":"/docs/specification/fury_row_format_spec","content":"Row Format Coming soon","keywords":"","version":"Next"},{"title":"Fury Java Serialization Specification","type":0,"sectionRef":"#","url":"/docs/specification/fury_java_serialization_spec","content":"","keywords":"","version":"Next"},{"title":"Spec overview​","type":1,"pageTitle":"Fury Java Serialization Specification","url":"/docs/specification/fury_java_serialization_spec#spec-overview","content":" Fury Java Serialization is an automatic object serialization framework that supports reference and polymorphism. Fury will convert an object from/to fury java serialization binary format. Fury has two core concepts for java serialization:  Fury Java Binary formatFramework to convert object to/from Fury Java Binary format  The serialization format is a dynamic binary format. The dynamics and reference/polymorphism support make Fury flexible, much more easy to use, but also introduce more complexities compared to static serialization frameworks. So the format will be more complex.  Here is the overall format:  | fury header | object ref meta | object class meta | object value data |   The data are serialized using little endian byte order overall. If bytes swap is costly for some object, Fury will write the byte order for that object into the data instead of converting it to little endian.  ","version":"Next","tagName":"h2"},{"title":"Fury header​","type":1,"pageTitle":"Fury Java Serialization Specification","url":"/docs/specification/fury_java_serialization_spec#fury-header","content":" Fury header consists starts one byte:  | 4 bits | 1 bit | 1 bit | 1 bit | 1 bit | optional 4 bytes | +---------------+-------+-------+--------+-------+------------------------------------+ | reserved bits | oob | xlang | endian | null | unsigned int for meta start offset |   null flag: 1 when object is null, 0 otherwise. If an object is null, other bits won't be set.endian flag: 1 when data is encoded by little endian, 0 for big endian.xlang flag: 1 when serialization uses xlang format, 0 when serialization uses Fury java format.oob flag: 1 when passed BufferCallback is not null, 0 otherwise.  If meta share mode is enabled, an uncompressed unsigned int is appended to indicate the start offset of metadata.  ","version":"Next","tagName":"h2"},{"title":"Reference Meta​","type":1,"pageTitle":"Fury Java Serialization Specification","url":"/docs/specification/fury_java_serialization_spec#reference-meta","content":" Reference tracking handles whether the object is null, and whether to track reference for the object by writing corresponding flags and maintaining internal state.  Reference flags:  Flag\tByte Value\tDescriptionNULL FLAG\t-3\tThis flag indicates the object is a null value. We don't use another byte to indicate REF, so that we can save one byte. REF FLAG\t-2\tThis flag indicates the object is already serialized previously, and fury will write a ref id with unsigned varint format instead of serialize it again NOT_NULL VALUE FLAG\t-1\tThis flag indicates the object is a non-null value and fury doesn't track ref for this type of object. REF VALUE FLAG\t0\tThis flag indicates the object is referencable and the first time to serialize.  When reference tracking is disabled globally or for specific types, or for certain types within a particular context(e.g., a field of a class), only the NULL and NOT_NULL VALUE flags will be used for reference meta.  ","version":"Next","tagName":"h2"},{"title":"Class Meta​","type":1,"pageTitle":"Fury Java Serialization Specification","url":"/docs/specification/fury_java_serialization_spec#class-meta","content":" Fury supports to register class by an optional id, the registration can be used for security check and class identification. If a class is registered, it will have a user-provided or an auto-growing unsigned int i.e. class_id.  Depending on whether meta share mode and registration is enabled for current class, Fury will write class meta differently.  ","version":"Next","tagName":"h2"},{"title":"Schema consistent​","type":1,"pageTitle":"Fury Java Serialization Specification","url":"/docs/specification/fury_java_serialization_spec#schema-consistent","content":" If schema consistent mode is enabled globally or enabled for current class, class meta will be written as follows:  If class is registered, it will be written as a fury unsigned varint: class_id &lt;&lt; 1.If class is not registered: If class is not an array, fury will write one byte 0bxxxxxxx1 first, then write class name. The first little bit is 1, which is different from first bit 0 of encoded class id. Fury can use this information to determine whether to read class by class id for deserialization. If class is not registered and class is an array, fury will write one byte dimensions &lt;&lt; 1 | 1 first, then write component class subsequently. This can reduce array class name cost if component class is or will be serialized.Class will be written as two enumerated fury unsigned by default: package name and class name. If meta share mode is enabled, class will be written as an unsigned varint which points to index in MetaContext.  ","version":"Next","tagName":"h3"},{"title":"Schema evolution​","type":1,"pageTitle":"Fury Java Serialization Specification","url":"/docs/specification/fury_java_serialization_spec#schema-evolution","content":" If schema evolution mode is enabled globally or enabled for current class, class meta will be written as follows:  If meta share mode is not enabled, class meta will be written as schema consistent mode. Additionally, field meta such as field type and name will be written with the field value using a key-value like layout.If meta share mode is enabled, class meta will be written as a meta-share encoded binary if class hasn't been written before, otherwise an unsigned varint id which references to previous written class meta will be written.  ","version":"Next","tagName":"h3"},{"title":"Meta share​","type":1,"pageTitle":"Fury Java Serialization Specification","url":"/docs/specification/fury_java_serialization_spec#meta-share","content":" This mode will forbid streaming writing since it needs to look back for update the start offset after the whole object graph writing and meta collecting is finished. Only in this way we can ensure deserialization failure doesn't lost shared meta. Meta streamline will be supported in the future for enclosed meta sharing which doesn't cross multiple serializations of different objects.  For Schema consistent mode, class will be encoded as an enumerated string by full class name. Here we mainly describe the meta layout for schema evolution mode:  | 8 bytes meta header | variable bytes | variable bytes | variable bytes | +-------------------------------+--------------------+-------------------+----------------+ | 7 bytes hash + 1 bytes header | current class meta | parent class meta | ... |   Class meta are encoded from parent class to leaf class, only class with serializable fields will be encoded.  ","version":"Next","tagName":"h2"},{"title":"Meta header​","type":1,"pageTitle":"Fury Java Serialization Specification","url":"/docs/specification/fury_java_serialization_spec#meta-header","content":" Meta header is a 64 bits number value encoded in little endian order.  Lowest 4 digits 0b0000~0b1110 are used to record num classes. 0b1111 is preserved to indicate that Fury need to read more bytes for length using Fury unsigned int encoding. If current class doesn't has parent class, or parent class doesn't have fields to serialize, or we're in a context which serialize fields of current class only( ObjectStreamSerializer#SlotInfo is an example), num classes will be 1.5rd bit is used to indicate whether this class needs schema evolution.Other 56 bits is used to store the unique hash of flags + all layers class meta.  ","version":"Next","tagName":"h3"},{"title":"Single layer class meta​","type":1,"pageTitle":"Fury Java Serialization Specification","url":"/docs/specification/fury_java_serialization_spec#single-layer-class-meta","content":" | unsigned varint | meta string | meta string | field info: variable bytes | variable bytes | ... | +----------------------------+-----------------------+---------------------+-------------------------------+-----------------+-----+ | num fields + register flag | header + package name | header + class name | header + type id + field name | next field info | ... |   num fields: encode num fields &lt;&lt; 1 | register flag(1 when class registered) as unsigned varint. If class is registered, then an unsigned varint class id will be written next, package and class name will be omitted.If current class is schema consistent, then num field will be 0 to flag it.If current class isn't schema consistent, then num field will be the number of compatible fields. For example, users can use tag id to mark some field as compatible field in schema consistent context. In such cases, schema consistent fields will be serialized first, then compatible fields will be serialized next. At deserialization, Fury will use fields info of those fields which aren't annotated by tag id for deserializing schema consistent fields, then use fields info in meta for deserializing compatible fields. Package name encoding(omitted when class is registered): Header: If meta string encoding is LOWER_SPECIAL and the length of encoded string &lt;= 128, then header will be7 bits size + flag(set). Otherwise, header will be 4 bits unset + 3 bits encoding flags + flag(unset) Package name: If bit flag is set, then package name will be encoded meta string binary.Otherwise, it will be | unsigned varint length | encoded meta string binary | Class name encoding(omitted when class is registered):: header: If meta string encoding is in LOWER_SPECIAL~LOWER_UPPER_DIGIT_SPECIAL (0~3), and the length of encoded string &lt;= 32， then the header will be 5 bits size + 2 bits encoding flags + flag(set).Otherwise, header will be | unsigned varint length | encoded meta string binary | Field info: header(8 bits): reserved 1 bit + 3 bits field name encoding + polymorphism flag + nullability flag + ref tracking flag + tag id flag. Users can use annotation to provide those info. tag id: when set to 1, field name will be written by an unsigned varint tag id.ref tracking: when set to 0, ref tracking will be disabled for this field.nullability: when set to 0, this field won't be null.polymorphism: when set to 1, the actual type of field will be the declared field type even the type if not final.3 bits field name encoding will be set to meta string encoding flags when tag id is not set. type id: For registered type-consistent classes, it will be the registered class id.Otherwise it will be encoded as OBJECT_ID if it isn't final and FINAL_OBJECT_ID if it's final. The meta for such types is written separately instead of inlining here is to reduce meta space cost if object of this type is serialized in current object graph multiple times, and the field value may be null too. Collection Type Info: collection type will have an extra byte for elements info. Users can use annotation to provide those info. elements type sameelements tracking refelements nullabilityelements declared type Map Type Info: map type will have an extra byte for kv items info. Users can use annotation to provide those info. keys type samekeys tracking refkeys nullabilitykeys declared typevalues type samevalues tracking refvalues nullabilityvalues declared type Field name: If type id is set, type id will be used instead. Otherwise meta string encoding length and data will be written instead.  Field order are left as implementation details, which is not exposed to specification, the deserialization need to resort fields based on Fury field comparator. In this way, fury can compute statistics for field names or types and using a more compact encoding.  ","version":"Next","tagName":"h3"},{"title":"Other layers class meta​","type":1,"pageTitle":"Fury Java Serialization Specification","url":"/docs/specification/fury_java_serialization_spec#other-layers-class-meta","content":" Same encoding algorithm as the previous layer except:  header + package name: Header: If package name has been written before: varint index + sharing flag(set) will be writtenIf package name hasn't been written before: If meta string encoding is LOWER_SPECIAL and the length of encoded string &lt;= 64, then header will be6 bits size + encoding flag(set) + sharing flag(unset).Otherwise, header will be 3 bits unset + 3 bits encoding flags + encoding flag(unset) + sharing flag(unset)  ","version":"Next","tagName":"h3"},{"title":"Meta String​","type":1,"pageTitle":"Fury Java Serialization Specification","url":"/docs/specification/fury_java_serialization_spec#meta-string","content":" Meta string is mainly used to encode meta strings such as class name and field names.  ","version":"Next","tagName":"h2"},{"title":"Encoding Algorithms​","type":1,"pageTitle":"Fury Java Serialization Specification","url":"/docs/specification/fury_java_serialization_spec#encoding-algorithms","content":" String binary encoding algorithm:  Algorithm\tPattern\tDescriptionLOWER_SPECIAL\ta-z._$|\tevery char is written using 5 bits, a-z: 0b00000~0b11001, ._$|: 0b11010~0b11101 LOWER_UPPER_DIGIT_SPECIAL\ta-zA-Z0~9._$\tevery char is written using 6 bits, a-z: 0b00000~0b11110, A-Z: 0b11010~0b110011, 0~9: 0b110100~0b111101, ._$: 0b111110~0b1000000 UTF-8\tany chars\tUTF-8 encoding  Encoding flags:  Encoding Flag\tPattern\tEncoding AlgorithmLOWER_SPECIAL\tevery char is in a-z._$|\tLOWER_SPECIAL REP_FIRST_LOWER_SPECIAL\tevery char is in a-z._$ except first char is upper case\treplace first upper case char to lower case, then use LOWER_SPECIAL REP_MUL_LOWER_SPECIAL\tevery char is in a-zA-Z._$\treplace every upper case char by | + lower case, then use LOWER_SPECIAL, use this encoding if it's smaller than Encoding 3 LOWER_UPPER_DIGIT_SPECIAL\tevery char is in a-zA-Z._$\tuse LOWER_UPPER_DIGIT_SPECIAL encoding if it's smaller than Encoding 2 UTF8\tany utf-8 char\tuse UTF-8 encoding Compression\tany utf-8 char\tlossless compression  Depending on cases, one can choose encoding flags + data jointly, uses 3 bits of first byte for flags and other bytes for data.  ","version":"Next","tagName":"h3"},{"title":"Shared meta string​","type":1,"pageTitle":"Fury Java Serialization Specification","url":"/docs/specification/fury_java_serialization_spec#shared-meta-string","content":" The shared meta string format consists of header and encoded string binary. Header of encoded string binary will be inlined in shared meta header.  Header is written using little endian order, Fury can read this flag first to determine how to deserialize the data.  Write by data​  If string hasn't been written before, the data will be written as follows:  | unsigned varint: string binary size + 1 bit: not written before | 56 bits: unique hash | 3 bits encoding flags + string binary |   If string binary size is less than 16 bytes, the hash will be omitted to save spaces. Unique hash can be omitted too if caller pass a flag to disable it. In such cases, the format will be:  | unsigned varint: string binary size + 1 bit: not written before | 3 bits encoding flags + string binary |   Write by ref​  If string has been written before, the data will be written as follows:  | unsigned varint: written string id + 1 bit: written before |   ","version":"Next","tagName":"h3"},{"title":"Value Format​","type":1,"pageTitle":"Fury Java Serialization Specification","url":"/docs/specification/fury_java_serialization_spec#value-format","content":" ","version":"Next","tagName":"h2"},{"title":"Basic types​","type":1,"pageTitle":"Fury Java Serialization Specification","url":"/docs/specification/fury_java_serialization_spec#basic-types","content":" Bool​  size: 1 byteformat: 0 for false, 1 for true  Byte​  size: 1 byteformat: write as pure byte.  Short​  size: 2 bytebyte order: little endian order  Char​  size: 2 bytebyte order: little endian order  Unsigned int​  size: 1~5 byteFormat: The most significant bit (MSB) in every byte indicates whether to have the next byte. If first bit is set i.e. b &amp; 0x80 == 0x80, then the next byte should be read until the first bit of the next byte is unset.  Signed int​  size: 1~5 byteFormat: First convert the number into positive unsigned int by (v &lt;&lt; 1) ^ (v &gt;&gt; 31) ZigZag algorithm, then encoding it as an unsigned int.  Unsigned long​  size: 1~9 byteFury PVL(Progressive Variable-length Long) Encoding: positive long format: first bit in every byte indicates whether to have the next byte. If first bit is set i.e. b &amp; 0x80 == 0x80, then the next byte should be read until the first bit is unset.  Signed long​  size: 1~9 byteFury SLI(Small long as int) Encoding: If long is in [-1073741824, 1073741823], encode as 4 bytes int: | little-endian: ((int) value) &lt;&lt; 1 |Otherwise write as 9 bytes: | 0b1 | little-endian 8 bytes long | Fury PVL(Progressive Variable-length Long) Encoding: First convert the number into positive unsigned long by (v &lt;&lt; 1) ^ (v &gt;&gt; 63) ZigZag algorithm to reduce cost of small negative numbers, then encoding it as an unsigned long.  Float​  size: 4 byteformat: convert float to 4 bytes int by Float.floatToRawIntBits, then write as binary by little endian order.  Double​  size: 8 byteformat: convert double to 8 bytes int by Double.doubleToRawLongBits, then write as binary by little endian order.  ","version":"Next","tagName":"h3"},{"title":"String​","type":1,"pageTitle":"Fury Java Serialization Specification","url":"/docs/specification/fury_java_serialization_spec#string","content":" Format:  | header: size &lt;&lt; 2 | 2 bits encoding flags | binary data |   size + encoding will be concat as a long and encoded as an unsigned var long. The little 2 bits is used for encoding: 0 for latin, 1 for utf-16, 2 for utf-8.encoded string binary data based on encoding: latin/utf-16/utf-8.  Which encoding to choose:  For JDK8: fury detect latin at runtime, if string is latin string, then use latin encoding, otherwise use utf-16.For JDK9+: fury use coder in String object for encoding, latin/utf-16 will be used for encoding.If the string is encoded by utf-8, then fury will use utf-8 to decode the data. But currently fury doesn't enable utf-8 encoding by default for java. Cross-language string serialization of fury uses utf-8 by default.  ","version":"Next","tagName":"h3"},{"title":"Collection​","type":1,"pageTitle":"Fury Java Serialization Specification","url":"/docs/specification/fury_java_serialization_spec#collection","content":" All collection serializers must extend AbstractCollectionSerializer.  Format:  length(unsigned varint) | collection header | elements header | elements data   Collection header​  For ArrayList/LinkedArrayList/HashSet/LinkedHashSet, this will be empty.For TreeSet, this will be ComparatorFor subclass of ArrayList, this may be extra object field info.  Elements header​  In most cases, all collection elements are same type and not null, elements header will encode those homogeneous information to avoid the cost of writing it for every element. Specifically, there are four kinds of information which will be encoded by elements header, each use one bit:  If track elements ref, use the first bit 0b1 of the header to flag it.If the collection has null, use the second bit 0b10 of the header to flag it. If ref tracking is enabled for this element type, this flag is invalid.If the collection element types are not declared type, use the 3rd bit 0b100 of the header to flag it.If the collection element types are different, use the 4rd bit 0b1000 header to flag it.  By default, all bits are unset, which means all elements won't track ref, all elements are same type, not null and the actual element is the declared type in the custom class field.  Elements data​  Based on the elements header, the serialization of elements data may skip ref flag/null flag/element class info.  CollectionSerializer#write/read can be taken as an example.  ","version":"Next","tagName":"h3"},{"title":"Array​","type":1,"pageTitle":"Fury Java Serialization Specification","url":"/docs/specification/fury_java_serialization_spec#array","content":" Primitive array​  Primitive array are taken as a binary buffer, serialization will just write the length of array size as an unsigned int, then copy the whole buffer into the stream.  Such serialization won't compress the array. If users want to compress primitive array, users need to register custom serializers for such types.  Object array​  Object array is serialized using the collection format. Object component type will be taken as collection element generic type.  ","version":"Next","tagName":"h3"},{"title":"Map​","type":1,"pageTitle":"Fury Java Serialization Specification","url":"/docs/specification/fury_java_serialization_spec#map","content":" All Map serializers must extend AbstractMapSerializer.  Format:  | length(unsigned varint) | map header | key value pairs data |   Map header​  For HashMap/LinkedHashMap, this will be empty.For TreeMap, this will be ComparatorFor other Map, this may be extra object field info.  Map Key-Value data​  Map iteration is too expensive, Fury won't compute the header like for collection before since it introduceconsiderable overhead. Users can use MapFieldInfo annotation to provide header in advance. Otherwise Fury will use first key-value pair to predict header optimistically, and update the chunk header if the prediction failed at some pair.  Fury will serialize map chunk by chunk, every chunk has 127 pairs at most.  | 1 byte | 1 byte | variable bytes | +----------------+----------------+-----------------+ | chunk size: N | KV header | N*2 objects |   KV header:  If track key ref, use the first bit 0b1 of the header to flag it.If the key has null, use the second bit 0b10 of the header to flag it. If ref tracking is enabled for this key type, this flag is invalid.If the key types of map are different, use the 3rd bit 0b100 of the header to flag it.If the actual key type of map is not the declared key type, use the 4rd bit 0b1000 of the header to flag it.If track value ref, use the 5th bit 0b10000 of the header to flag it.If the value has null, use the 6th bit 0b100000 of the header to flag it. If ref tracking is enabled for this value type, this flag is invalid.If the value types of map are different, use the 7rd bit 0b1000000 header to flag it.If the value type of map is not the declared value type, use the 8rd bit 0b10000000 of the header to flag it.  If streaming write is enabled, which means Fury can't update written chunk size. In such cases, map key-value data format will be:  | 1 byte | variable bytes | +----------------+-----------------+ | KV header | N*2 objects |   KV header will be a header marked by MapFieldInfo in java. For languages such as golang, this can be computed in advance for non-interface types in most times.  ","version":"Next","tagName":"h3"},{"title":"Enum​","type":1,"pageTitle":"Fury Java Serialization Specification","url":"/docs/specification/fury_java_serialization_spec#enum","content":" Enums are serialized as an unsigned var int. If the order of enum values change, the deserialized enum value may not be the value users expect. In such cases, users must register enum serializer by make it write enum value as an enumerated string with unique hash disabled.  ","version":"Next","tagName":"h3"},{"title":"Object​","type":1,"pageTitle":"Fury Java Serialization Specification","url":"/docs/specification/fury_java_serialization_spec#object","content":" Object means object of pojo/struct/bean/record type. Object will be serialized by writing its fields data in fury order.  Depending on schema compatibility, objects will have different formats.  Field order​  Field will be ordered as following, every group of fields will have its own order:  primitive fields: larger size type first, smaller later, variable size type last.boxed primitive fields: same order as primitive fieldsfinal fields: same type together, then sorted by field name lexicographically.collection fields: same order as final fieldsmap fields: same order as final fieldsother fields: same order as final fields  Schema consistent​  Object fields will be serialized one by one using following format:  Primitive field value: | var bytes | +----------------+ | value data | +----------------+ Boxed field value: | one byte | var bytes | +-----------+---------------+ | null flag | field value | +-----------+---------------+ field value of final type with ref tracking: | var bytes | var objects | +-----------+-------------+ | ref meta | value data | +-----------+-------------+ field value of final type without ref tracking: | one byte | var objects | +-----------+-------------+ | null flag | field value | +-----------+-------------+ field value of non-final type with ref tracking: | one byte | var bytes | var objects | +-----------+-------------+-------------+ | ref meta | class meta | value data | +-----------+-------------+-------------+ field value of non-final type without ref tracking: | one byte | var bytes | var objects | +-----------+------------+------------+ | null flag | class meta | value data | +-----------+------------+------------+   Schema evolution​  Schema evolution have similar format as schema consistent mode for object except:  For this object type itself, schema consistent mode will write class by id/name, but schema evolution mode will write class field names, types and other meta too, see Class meta.Class meta of final custom type needs to be written too, because peers may not have this class defined.  ","version":"Next","tagName":"h3"},{"title":"Class​","type":1,"pageTitle":"Fury Java Serialization Specification","url":"/docs/specification/fury_java_serialization_spec#class","content":" Class will be serialized using class meta format.  ","version":"Next","tagName":"h3"},{"title":"Implementation guidelines​","type":1,"pageTitle":"Fury Java Serialization Specification","url":"/docs/specification/fury_java_serialization_spec#implementation-guidelines","content":" Try to merge multiple bytes into an int/long write before writing to reduce memory IO and bound check cost.Read multiple bytes as an int/long, then split into multiple bytes to reduce memory IO and bound check cost.Try to use one varint/long to write flags and length together to save one byte cost and reduce memory io.Condition branches are less expensive compared to memory IO cost unless there are too many branches. ","version":"Next","tagName":"h2"},{"title":"Java object graph serialization","type":0,"sectionRef":"#","url":"/docs/guide/java_object_graph_guide","content":"","keywords":"","version":"Next"},{"title":"Quick Start​","type":1,"pageTitle":"Java object graph serialization","url":"/docs/guide/java_object_graph_guide#quick-start","content":" Note that fury creation is not cheap, the fury instances should be reused between serializations instead of creating it everytime. You should keep fury to a static global variable, or instance variable of some singleton object or limited objects.  Fury for single-thread usage:  import java.util.List; import java.util.Arrays; import org.apache.fury.*; import org.apache.fury.config.*; public class Example { public static void main(String[] args) { SomeClass object = new SomeClass(); // Note that Fury instances should be reused between // multiple serializations of different objects. Fury fury = Fury.builder().withLanguage(Language.JAVA) // Allow to deserialize objects unknown types, more flexible // but may be insecure if the classes contains malicious code. .requireClassRegistration(true) .build(); // Registering types can reduce class name serialization overhead, but not mandatory. // If class registration enabled, all custom types must be registered. fury.register(SomeClass.class); byte[] bytes = fury.serialize(object); System.out.println(fury.deserialize(bytes)); } }   Fury for multiple-thread usage:  import java.util.List; import java.util.Arrays; import org.apache.fury.*; import org.apache.fury.config.*; public class Example { public static void main(String[] args) { SomeClass object = new SomeClass(); // Note that Fury instances should be reused between // multiple serializations of different objects. ThreadSafeFury fury = new ThreadLocalFury(classLoader -&gt; { Fury f = Fury.builder().withLanguage(Language.JAVA) .withClassLoader(classLoader).build(); f.register(SomeClass.class); return f; }); byte[] bytes = fury.serialize(object); System.out.println(fury.deserialize(bytes)); } }   Fury instances reuse example:  import java.util.List; import java.util.Arrays; import org.apache.fury.*; import org.apache.fury.config.*; public class Example { // reuse fury. private static final ThreadSafeFury fury = Fury.builder() // Allow to deserialize objects unknown types, more flexible // but may be insecure if the classes contains malicious code. .requireClassRegistration(true) .buildThreadSafeFury(); public static void main(String[] args) { SomeClass object = new SomeClass(); byte[] bytes = fury.serialize(object); System.out.println(fury.deserialize(bytes)); } }   ","version":"Next","tagName":"h2"},{"title":"FuryBuilder options​","type":1,"pageTitle":"Java object graph serialization","url":"/docs/guide/java_object_graph_guide#furybuilder--options","content":" Option Name\tDescription\tDefault ValuetimeRefIgnored\tWhether to ignore reference tracking of all time types registered in TimeSerializers and subclasses of those types when ref tracking is enabled. If ignored, ref tracking of every time type can be enabled by invoking Fury#registerSerializer(Class, Serializer). For example, fury.registerSerializer(Date.class, new DateSerializer(fury, true)). Note that enabling ref tracking should happen before serializer codegen of any types which contain time fields. Otherwise, those fields will still skip ref tracking.\ttrue compressInt\tEnables or disables int compression for smaller size.\ttrue compressLong\tEnables or disables long compression for smaller size.\ttrue compressString\tEnables or disables string compression for smaller size.\ttrue classLoader\tThe classloader should not be updated; Fury caches class metadata. Use LoaderBinding or ThreadSafeFury for classloader updates.\tThread.currentThread().getContextClassLoader() compatibleMode\tType forward/backward compatibility config. Also Related to checkClassVersion config. SCHEMA_CONSISTENT: Class schema must be consistent between serialization peer and deserialization peer. COMPATIBLE: Class schema can be different between serialization peer and deserialization peer. They can add/delete fields independently.\tCompatibleMode.SCHEMA_CONSISTENT checkClassVersion\tDetermines whether to check the consistency of the class schema. If enabled, Fury checks, writes, and checks consistency using the classVersionHash. It will be automatically disabled when CompatibleMode#COMPATIBLE is enabled. Disabling is not recommended unless you can ensure the class won't evolve.\tfalse checkJdkClassSerializable\tEnables or disables checking of Serializable interface for classes under java.*. If a class under java.* is not Serializable, Fury will throw an UnsupportedOperationException.\ttrue registerGuavaTypes\tWhether to pre-register Guava types such as RegularImmutableMap/RegularImmutableList. These types are not public API, but seem pretty stable.\ttrue requireClassRegistration\tDisabling may allow unknown classes to be deserialized, potentially causing security risks.\ttrue suppressClassRegistrationWarnings\tWhether to suppress class registration warnings. The warnings can be used for security audit, but may be annoying, this suppression will be enabled by default.\ttrue shareMetaContext\tEnables or disables meta share mode.\tfalse deserializeUnexistedClass\tEnables or disables deserialization/skipping of data for non-existent classes.\tfalse codeGenEnabled\tDisabling may result in faster initial serialization but slower subsequent serializations.\ttrue asyncCompilationEnabled\tIf enabled, serialization uses interpreter mode first and switches to JIT serialization after async serializer JIT for a class is finished.\tfalse scalaOptimizationEnabled\tEnables or disables Scala-specific serialization optimization.\tfalse  ","version":"Next","tagName":"h2"},{"title":"Advanced Usage​","type":1,"pageTitle":"Java object graph serialization","url":"/docs/guide/java_object_graph_guide#advanced-usage","content":" ","version":"Next","tagName":"h2"},{"title":"Fury creation​","type":1,"pageTitle":"Java object graph serialization","url":"/docs/guide/java_object_graph_guide#fury-creation","content":" Single thread fury:  Fury fury = Fury.builder() .withLanguage(Language.JAVA) // enable reference tracking for shared/circular reference. // Disable it will have better performance if no duplicate reference. .withRefTracking(false) .withCompatibleMode(CompatibleMode.SCHEMA_CONSISTENT) // enable type forward/backward compatibility // disable it for small size and better performance. // .withCompatibleMode(CompatibleMode.COMPATIBLE) // enable async multi-threaded compilation. .withAsyncCompilation(true) .build(); byte[] bytes = fury.serialize(object); System.out.println(fury.deserialize(bytes));   Thread-safe fury:  ThreadSafeFury fury = Fury.builder() .withLanguage(Language.JAVA) // enable reference tracking for shared/circular reference. // Disable it will have better performance if no duplicate reference. .withRefTracking(false) // compress int for smaller size // .withIntCompressed(true) // compress long for smaller size // .withLongCompressed(true) .withCompatibleMode(CompatibleMode.SCHEMA_CONSISTENT) // enable type forward/backward compatibility // disable it for small size and better performance. // .withCompatibleMode(CompatibleMode.COMPATIBLE) // enable async multi-threaded compilation. .withAsyncCompilation(true) .buildThreadSafeFury(); byte[] bytes = fury.serialize(object); System.out.println(fury.deserialize(bytes));   ","version":"Next","tagName":"h3"},{"title":"Smaller size​","type":1,"pageTitle":"Java object graph serialization","url":"/docs/guide/java_object_graph_guide#smaller-size","content":" FuryBuilder#withIntCompressed/FuryBuilder#withLongCompressed can be used to compress int/long for smaller size. Normally compress int is enough.  Both compression are enabled by default, if the serialized is not important, for example, you use flatbuffers for serialization before, which doesn't compress anything, then you should disable compression. If your data are all numbers, the compression may bring 80% performance regression.  For int compression, fury use 1~5 bytes for encoding. First bit in every byte indicate whether has next byte. if first bit is set, then next byte will be read util first bit of next byte is unset.  For long compression, fury support two encoding:  Fury SLI(Small long as int) Encoding (used by default): If long is in [-1073741824, 1073741823], encode as 4 bytes int: | little-endian: ((int) value) &lt;&lt; 1 |Otherwise write as 9 bytes: | 0b1 | little-endian 8bytes long | Fury PVL(Progressive Variable-length Long) Encoding: First bit in every byte indicate whether has next byte. if first bit is set, then next byte will be read util first bit of next byte is unset.Negative number will be converted to positive number by (v &lt;&lt; 1) ^ (v &gt;&gt; 63) to reduce cost of small negative numbers.  If a number are long type, it can't be represented by smaller bytes mostly, the compression won't get good enough result, not worthy compared to performance cost. Maybe you should try to disable long compression if you find it didn't bring much space savings.  ","version":"Next","tagName":"h3"},{"title":"Implement a customized serializer​","type":1,"pageTitle":"Java object graph serialization","url":"/docs/guide/java_object_graph_guide#implement-a-customized-serializer","content":" In some cases, you may want to implement a serializer for your type, especially some class customize serialization by JDK writeObject/writeReplace/readObject/readResolve, which is very inefficient. For example, you don't want following Foo#writeObjectgot invoked, you can take following FooSerializer as an example:  class Foo { public long f1; private void writeObject(ObjectOutputStream s) throws IOException { System.out.println(f1); s.defaultWriteObject(); } } class FooSerializer extends Serializer&lt;Foo&gt; { public FooSerializer(Fury fury) { super(fury, Foo.class); } @Override public void write(MemoryBuffer buffer, Foo value) { buffer.writeLong(value.f1); } @Override public Foo read(MemoryBuffer buffer) { Foo foo = new Foo(); foo.f1 = buffer.readLong(); return foo; } }   Register serializer:  Fury fury = getFury(); fury.registerSerializer(Foo.class, new FooSerializer(fury));   ","version":"Next","tagName":"h3"},{"title":"Security & Class Registration​","type":1,"pageTitle":"Java object graph serialization","url":"/docs/guide/java_object_graph_guide#security--class-registration","content":" FuryBuilder#requireClassRegistration can be used to disable class registration, this will allow to deserialize objects unknown types, more flexible but may be insecure if the classes contains malicious code.  Do not disable class registration unless you can ensure your environment is secure. Malicious code in init/equals/hashCode can be executed when deserializing unknown/untrusted types when this option disabled.  Class registration can not only reduce security risks, but also avoid classname serialization cost.  You can register class with API Fury#register.  Note that class registration order is important, serialization and deserialization peer should have same registration order.  Fury fury = xxx; fury.register(SomeClass.class); fury.register(SomeClass1.class, 200);   If you invoke FuryBuilder#requireClassRegistration(false) to disable class registration check, you can set org.apache.fury.resolver.ClassChecker by ClassResolver#setClassChecker to control which classes are allowed for serialization. For example, you can allow classes started with org.example.* by:  Fury fury = xxx; fury.getClassResolver().setClassChecker((classResolver, className) -&gt; className.startsWith(&quot;org.example.&quot;));   AllowListChecker checker = new AllowListChecker(AllowListChecker.CheckLevel.STRICT); ThreadSafeFury fury = new ThreadLocalFury(classLoader -&gt; { Fury f = Fury.builder().requireClassRegistration(true).withClassLoader(classLoader).build(); f.getClassResolver().setClassChecker(checker); checker.addListener(f.getClassResolver()); return f; }); checker.allowClass(&quot;org.example.*&quot;);   Fury also provided a org.apache.fury.resolver.AllowListChecker which is allowed/disallowed list based checker to simplify the customization of class check mechanism. You can use this checker or implement more sophisticated checker by yourself.  ","version":"Next","tagName":"h3"},{"title":"Serializer Registration​","type":1,"pageTitle":"Java object graph serialization","url":"/docs/guide/java_object_graph_guide#serializer-registration","content":" You can also register a custom serializer for a class by Fury#registerSerializer API.  Or implement java.io.Externalizable for a class.  ","version":"Next","tagName":"h3"},{"title":"Zero-Copy Serialization​","type":1,"pageTitle":"Java object graph serialization","url":"/docs/guide/java_object_graph_guide#zero-copy-serialization","content":" import org.apache.fury.*; import org.apache.fury.config.*; import org.apache.fury.serializers.BufferObject; import org.apache.fury.memory.MemoryBuffer; import java.util.*; import java.util.stream.Collectors; public class ZeroCopyExample { // Note that fury instance should be reused instead of creation every time. static Fury fury = Fury.builder() .withLanguage(Language.JAVA) .build(); // mvn exec:java -Dexec.mainClass=&quot;io.ray.fury.examples.ZeroCopyExample&quot; public static void main(String[] args) { List&lt;Object&gt; list = Arrays.asList(&quot;str&quot;, new byte[1000], new int[100], new double[100]); Collection&lt;BufferObject&gt; bufferObjects = new ArrayList&lt;&gt;(); byte[] bytes = fury.serialize(list, e -&gt; !bufferObjects.add(e)); List&lt;MemoryBuffer&gt; buffers = bufferObjects.stream() .map(BufferObject::toBuffer).collect(Collectors.toList()); System.out.println(fury.deserialize(bytes, buffers)); } }   ","version":"Next","tagName":"h3"},{"title":"Meta Sharing​","type":1,"pageTitle":"Java object graph serialization","url":"/docs/guide/java_object_graph_guide#meta-sharing","content":" Fury supports share type metadata (class name, field name, final field type information, etc.) between multiple serializations in a context (ex. TCP connection), and this information will be sent to the peer during the first serialization in the context. Based on this metadata, the peer can rebuild the same deserializer, which avoids transmitting metadata for subsequent serializations and reduces network traffic pressure and supports type forward/backward compatibility automatically.  // Fury.builder() // .withLanguage(Language.JAVA) // .withRefTracking(false) // // share meta across serialization. // .withMetaContextShare(true) // Not thread-safe fury. MetaContext context = xxx; fury.getSerializationContext().setMetaContext(context); byte[] bytes = fury.serialize(o); // Not thread-safe fury. MetaContext context = xxx; fury.getSerializationContext().setMetaContext(context); fury.deserialize(bytes) // Thread-safe fury fury.setClassLoader(beanA.getClass().getClassLoader()); byte[] serialized = fury.execute( f -&gt; { f.getSerializationContext().setMetaContext(context); return f.serialize(beanA); } ); // thread-safe fury fury.setClassLoader(beanA.getClass().getClassLoader()); Object newObj = fury.execute( f -&gt; { f.getSerializationContext().setMetaContext(context); return f.deserialize(serialized); } );   ","version":"Next","tagName":"h3"},{"title":"Deserialize un-exited classes.​","type":1,"pageTitle":"Java object graph serialization","url":"/docs/guide/java_object_graph_guide#deserialize-un-exited-classes","content":" Fury support deserializing unexisted classes, this feature can be enabled by FuryBuilder#deserializeUnexistedClass(true). When enabled, and metadata sharing enabled, Fury will store the deserialized data of this type in a lazy subclass of Map. By using the lazy map implemented by Fury, the rebalance cost of filling map during deserialization can be avoided, which further improves performance. If this data is sent to another process and the class exists in this process, the data will be deserialized into the object of this type without losing any information.  If metadata sharing is not enabled, the new class data will be skipped and an UnexistedSkipClass stub object will be returned.  ","version":"Next","tagName":"h3"},{"title":"Migration​","type":1,"pageTitle":"Java object graph serialization","url":"/docs/guide/java_object_graph_guide#migration","content":" ","version":"Next","tagName":"h2"},{"title":"JDK migration​","type":1,"pageTitle":"Java object graph serialization","url":"/docs/guide/java_object_graph_guide#jdk-migration","content":" If you use jdk serialization before, and you can't upgrade your client and server at the same time, which is common for online application. Fury provided an util method org.apache.fury.serializer.JavaSerializer.serializedByJDK to check whether the binary are generated by jdk serialization, you use following pattern to make exiting serialization protocol-aware, then upgrade serialization to fury in an async rolling-up way:  if (JavaSerializer.serializedByJDK(bytes)) { ObjectInputStream objectInputStream = xxx; return objectInputStream.readObject(); } else { return fury.deserialize(bytes); }   ","version":"Next","tagName":"h3"},{"title":"Upgrade fury​","type":1,"pageTitle":"Java object graph serialization","url":"/docs/guide/java_object_graph_guide#upgrade-fury","content":" Currently binary compatibility is ensured for minor versions only. For example, if you are using furyv0.2.0, binary compatibility will be provided if you upgrade to fury v0.2.1. But if upgrade to fury v0.4.1, no binary compatibility are ensured. Most of the time there is no need to upgrade fury to newer major version, the current version is fast and compact enough, and we provide some minor fix for recent older versions.  But if you do want to upgrade fury for better performance and smaller size, you need to write fury version as header to serialized data using code like following to keep binary compatibility:  MemoryBuffer buffer = xxx; buffer.writeVarInt(2); fury.serialize(buffer, obj);   Then for deserialization, you need:  MemoryBuffer buffer = xxx; int furyVersion = buffer.readVarInt() Fury fury = getFury(furyVersion); fury.deserialize(buffer);   getFury is a method to load corresponding fury, you can shade and relocate different version of fury to different package, and load fury by version.  If you upgrade fury by minor version, or you won't have data serialized by older fury, you can upgrade fury directly, no need to versioning the data.  ","version":"Next","tagName":"h3"},{"title":"Trouble shooting​","type":1,"pageTitle":"Java object graph serialization","url":"/docs/guide/java_object_graph_guide#trouble-shooting","content":" ","version":"Next","tagName":"h2"},{"title":"Class inconsistency and class version check​","type":1,"pageTitle":"Java object graph serialization","url":"/docs/guide/java_object_graph_guide#class-inconsistency-and-class-version-check","content":" If you create fury without setting CompatibleMode to org.apache.fury.config.CompatibleMode.COMPATIBLE, and you got a strange serialization error, it may be caused by class inconsistency between serialization peer and deserialization peer.  In such cases, you can invoke FuryBuilder#withClassVersionCheck to create fury to validate it, if deserialization throws org.apache.fury.exception.ClassNotCompatibleException, it shows class are inconsistent, and you should create fury withFuryBuilder#withCompaibleMode(CompatibleMode.COMPATIBLE).  CompatibleMode.COMPATIBLE has more performance and space cost, do not set it by default if your classes are always consistent between serialization and deserialization.  ","version":"Next","tagName":"h3"},{"title":"Use wrong API for deserialization​","type":1,"pageTitle":"Java object graph serialization","url":"/docs/guide/java_object_graph_guide#use-wrong-api-for-deserialization","content":" If you serialize an object by invoking Fury#serialize, you should invoke Fury#deserialize for deserialization instead ofFury#deserializeJavaObject.  If you serialize an object by invoking Fury#serializeJavaObject, you should invoke Fury#deserializeJavaObject for deserialization instead of Fury#deserializeJavaObjectAndClass/Fury#deserialize.  If you serialize an object by invoking Fury#serializeJavaObjectAndClass, you should invoke Fury#deserializeJavaObjectAndClass for deserialization instead of Fury#deserializeJavaObject/Fury#deserialize. ","version":"Next","tagName":"h3"},{"title":"Xlang Object Graph Guide","type":0,"sectionRef":"#","url":"/docs/guide/xlang_object_graph_guide","content":"","keywords":"","version":"Next"},{"title":"Cross-language object graph serialization​","type":1,"pageTitle":"Xlang Object Graph Guide","url":"/docs/guide/xlang_object_graph_guide#cross-language-object-graph-serialization","content":" ","version":"Next","tagName":"h2"},{"title":"Serialize built-in types​","type":1,"pageTitle":"Xlang Object Graph Guide","url":"/docs/guide/xlang_object_graph_guide#serialize-built-in-types","content":" Common types can be serialized automatically: primitive numeric types, string, binary, array, list, map and so on.  Java  import org.apache.fury.*; import org.apache.fury.config.*; import java.util.*; public class Example1 { public static void main(String[] args) { Fury fury = Fury.builder().withLanguage(Language.XLANG).build(); List&lt;Object&gt; list = ofArrayList(true, false, &quot;str&quot;, -1.1, 1, new int[100], new double[20]); byte[] bytes = fury.serialize(list); // bytes can be data serialized by other languages. fury.deserialize(bytes); Map&lt;Object, Object&gt; map = new HashMap&lt;&gt;(); map.put(&quot;k1&quot;, &quot;v1&quot;); map.put(&quot;k2&quot;, list); map.put(&quot;k3&quot;, -1); bytes = fury.serialize(map); // bytes can be data serialized by other languages. fury.deserialize(bytes); } }   Python  import pyfury import numpy as np fury = pyfury.Fury() object_list = [True, False, &quot;str&quot;, -1.1, 1, np.full(100, 0, dtype=np.int32), np.full(20, 0.0, dtype=np.double)] data = fury.serialize(object_list) # bytes can be data serialized by other languages. new_list = fury.deserialize(data) object_map = {&quot;k1&quot;: &quot;v1&quot;, &quot;k2&quot;: object_list, &quot;k3&quot;: -1} data = fury.serialize(object_map) # bytes can be data serialized by other languages. new_map = fury.deserialize(data) print(new_map)   Golang  package main import furygo &quot;github.com/apache/incubator-fury/fury/go/fury&quot; import &quot;fmt&quot; func main() { list := []interface{}{true, false, &quot;str&quot;, -1.1, 1, make([]int32, 10), make([]float64, 20)} fury := furygo.NewFury() bytes, err := fury.Marshal(list) if err != nil { panic(err) } var newValue interface{} // bytes can be data serialized by other languages. if err := fury.Unmarshal(bytes, &amp;newValue); err != nil { panic(err) } fmt.Println(newValue) dict := map[string]interface{}{ &quot;k1&quot;: &quot;v1&quot;, &quot;k2&quot;: list, &quot;k3&quot;: -1, } bytes, err = fury.Marshal(dict) if err != nil { panic(err) } // bytes can be data serialized by other languages. if err := fury.Unmarshal(bytes, &amp;newValue); err != nil { panic(err) } fmt.Println(newValue) }   JavaScript  import Fury from '@furyjs/fury'; /** * @furyjs/hps use v8's fast-calls-api that can be called directly by jit, ensure that the version of Node is 20 or above. * Experimental feature, installation success cannot be guaranteed at this moment * If you are unable to install the module, replace it with `const hps = null;` **/ import hps from '@furyjs/hps'; const fury = new Fury({ hps }); const input = fury.serialize('hello fury'); const result = fury.deserialize(input); console.log(result);   Rust  use chrono::{NaiveDate, NaiveDateTime}; use fury::{from_buffer, to_buffer, Fury}; use std::collections::HashMap; fn run() { let bin: Vec&lt;u8&gt; = to_buffer(&amp;&quot;hello&quot;.to_string()); let obj: String = from_buffer(&amp;bin).expect(&quot;should success&quot;); assert_eq!(&quot;hello&quot;.to_string(), obj); }   ","version":"Next","tagName":"h3"},{"title":"Serialize custom types​","type":1,"pageTitle":"Xlang Object Graph Guide","url":"/docs/guide/xlang_object_graph_guide#serialize-custom-types","content":" Serializing user-defined types needs registering the custom type using the register API to establish the mapping relationship between the type in different languages.  Java  import org.apache.fury.*; import org.apache.fury.config.*; import java.util.*; public class Example2 { public static class SomeClass1 { Object f1; Map&lt;Byte, Integer&gt; f2; } public static class SomeClass2 { Object f1; String f2; List&lt;Object&gt; f3; Map&lt;Byte, Integer&gt; f4; Byte f5; Short f6; Integer f7; Long f8; Float f9; Double f10; short[] f11; List&lt;Short&gt; f12; } public static Object createObject() { SomeClass1 obj1 = new SomeClass1(); obj1.f1 = true; obj1.f2 = ofHashMap((byte) -1, 2); SomeClass2 obj = new SomeClass2(); obj.f1 = obj1; obj.f2 = &quot;abc&quot;; obj.f3 = ofArrayList(&quot;abc&quot;, &quot;abc&quot;); obj.f4 = ofHashMap((byte) 1, 2); obj.f5 = Byte.MAX_VALUE; obj.f6 = Short.MAX_VALUE; obj.f7 = Integer.MAX_VALUE; obj.f8 = Long.MAX_VALUE; obj.f9 = 1.0f / 2; obj.f10 = 1 / 3.0; obj.f11 = new short[]{(short) 1, (short) 2}; obj.f12 = ofArrayList((short) -1, (short) 4); return obj; } // mvn exec:java -Dexec.mainClass=&quot;org.apache.fury.examples.Example2&quot; public static void main(String[] args) { Fury fury = Fury.builder().withLanguage(Language.XLANG).build(); fury.register(SomeClass1.class, &quot;example.SomeClass1&quot;); fury.register(SomeClass2.class, &quot;example.SomeClass2&quot;); byte[] bytes = fury.serialize(createObject()); // bytes can be data serialized by other languages. System.out.println(fury.deserialize(bytes)); } }   Python  from dataclasses import dataclass from typing import List, Dict, Any import pyfury, array @dataclass class SomeClass1: f1: Any f2: Dict[pyfury.Int8Type, pyfury.Int32Type] @dataclass class SomeClass2: f1: Any = None f2: str = None f3: List[str] = None f4: Dict[pyfury.Int8Type, pyfury.Int32Type] = None f5: pyfury.Int8Type = None f6: pyfury.Int16Type = None f7: pyfury.Int32Type = None # int type will be taken as `pyfury.Int64Type`. # use `pyfury.Int32Type` for type hint if peer # are more narrow type. f8: int = None f9: pyfury.Float32Type = None # float type will be taken as `pyfury.Float64Type` f10: float = None f11: pyfury.Int16ArrayType = None f12: List[pyfury.Int16Type] = None if __name__ == &quot;__main__&quot;: f = pyfury.Fury() f.register_class(SomeClass1, type_tag=&quot;example.SomeClass1&quot;) f.register_class(SomeClass2, type_tag=&quot;example.SomeClass2&quot;) obj1 = SomeClass1(f1=True, f2={-1: 2}) obj = SomeClass2( f1=obj1, f2=&quot;abc&quot;, f3=[&quot;abc&quot;, &quot;abc&quot;], f4={1: 2}, f5=2 ** 7 - 1, f6=2 ** 15 - 1, f7=2 ** 31 - 1, f8=2 ** 63 - 1, f9=1.0 / 2, f10=1 / 3.0, f11=array.array(&quot;h&quot;, [1, 2]), f12=[-1, 4], ) data = f.serialize(obj) # bytes can be data serialized by other languages. print(f.deserialize(data))   Golang  package main import furygo &quot;github.com/apache/incubator-fury/fury/go/fury&quot; import &quot;fmt&quot; func main() { type SomeClass1 struct { F1 interface{} F2 string F3 []interface{} F4 map[int8]int32 F5 int8 F6 int16 F7 int32 F8 int64 F9 float32 F10 float64 F11 []int16 F12 fury.Int16Slice } type SomeClas2 struct { F1 interface{} F2 map[int8]int32 } fury := furygo.NewFury() if err := fury.RegisterTagType(&quot;example.SomeClass1&quot;, SomeClass1{}); err != nil { panic(err) } if err := fury.RegisterTagType(&quot;example.SomeClass2&quot;, SomeClass2{}); err != nil { panic(err) } obj1 := &amp;SomeClass1{} obj1.F1 = true obj1.F2 = map[int8]int32{-1: 2} obj := &amp;SomeClass1{} obj.F1 = obj1 obj.F2 = &quot;abc&quot; obj.F3 = []interface{}{&quot;abc&quot;, &quot;abc&quot;} f4 := map[int8]int32{1: 2} obj.F4 = f4 obj.F5 = fury.MaxInt8 obj.F6 = fury.MaxInt16 obj.F7 = fury.MaxInt32 obj.F8 = fury.MaxInt64 obj.F9 = 1.0 / 2 obj.F10 = 1 / 3.0 obj.F11 = []int16{1, 2} obj.F12 = []int16{-1, 4} bytes, err := fury.Marshal(obj); if err != nil { panic(err) } var newValue interface{} // bytes can be data serialized by other languages. if err := fury.Unmarshal(bytes, &amp;newValue); err != nil { panic(err) } fmt.Println(newValue) }   JavaScript  import Fury, { Type, InternalSerializerType } from '@furyjs/fury'; /** * @furyjs/hps use v8's fast-calls-api that can be called directly by jit, ensure that the version of Node is 20 or above. * Experimental feature, installation success cannot be guaranteed at this moment * If you are unable to install the module, replace it with `const hps = null;` **/ import hps from '@furyjs/hps'; // Now we describe data structures using JSON, but in the future, we will use more ways. const description = Type.object('example.foo', { foo: Type.string(), }); const fury = new Fury({ hps }); const { serialize, deserialize } = fury.registerSerializer(description); const input = serialize({ foo: 'hello fury' }); const result = deserialize(input); console.log(result);   Rust  use chrono::{NaiveDate, NaiveDateTime}; use fury::{from_buffer, to_buffer, Fury}; use std::collections::HashMap; #[test] fn complex_struct() { #[derive(Fury, Debug, PartialEq)] #[tag(&quot;example.foo2&quot;)] struct Animal { category: String, } #[derive(Fury, Debug, PartialEq)] #[tag(&quot;example.foo&quot;)] struct Person { c1: Vec&lt;u8&gt;, // binary c2: Vec&lt;i16&gt;, // primitive array animal: Vec&lt;Animal&gt;, c3: Vec&lt;Vec&lt;u8&gt;&gt;, name: String, c4: HashMap&lt;String, String&gt;, age: u16, op: Option&lt;String&gt;, op2: Option&lt;String&gt;, date: NaiveDate, time: NaiveDateTime, c5: f32, c6: f64, } let person: Person = Person { c1: vec![1, 2, 3], c2: vec![5, 6, 7], c3: vec![vec![1, 2], vec![1, 3]], animal: vec![Animal { category: &quot;Dog&quot;.to_string(), }], c4: HashMap::from([ (&quot;hello1&quot;.to_string(), &quot;hello2&quot;.to_string()), (&quot;hello2&quot;.to_string(), &quot;hello3&quot;.to_string()), ]), age: 12, name: &quot;helo&quot;.to_string(), op: Some(&quot;option&quot;.to_string()), op2: None, date: NaiveDate::from_ymd_opt(2025, 12, 12).unwrap(), time: NaiveDateTime::from_timestamp_opt(1689912359, 0).unwrap(), c5: 2.0, c6: 4.0, }; let bin: Vec&lt;u8&gt; = to_buffer(&amp;person); let obj: Person = from_buffer(&amp;bin).expect(&quot;should success&quot;); assert_eq!(person, obj); }   ","version":"Next","tagName":"h3"},{"title":"Serialize Shared Reference and Circular Reference​","type":1,"pageTitle":"Xlang Object Graph Guide","url":"/docs/guide/xlang_object_graph_guide#serialize-shared-reference-and-circular-reference","content":" Shared reference and circular reference can be serialized automatically, no duplicate data or recursion error.  Java  import org.apache.fury.*; import org.apache.fury.config.*; import java.util.*; public class ReferenceExample { public static class SomeClass { SomeClass f1; Map&lt;String, String&gt; f2; Map&lt;String, String&gt; f3; } public static Object createObject() { SomeClass obj = new SomeClass(); obj.f1 = obj; obj.f2 = ofHashMap(&quot;k1&quot;, &quot;v1&quot;, &quot;k2&quot;, &quot;v2&quot;); obj.f3 = obj.f2; return obj; } // mvn exec:java -Dexec.mainClass=&quot;org.apache.fury.examples.ReferenceExample&quot; public static void main(String[] args) { Fury fury = Fury.builder().withLanguage(Language.XLANG) .withRefTracking(true).build(); fury.register(SomeClass.class, &quot;example.SomeClass&quot;); byte[] bytes = fury.serialize(createObject()); // bytes can be data serialized by other languages. System.out.println(fury.deserialize(bytes)); } }   Python  from typing import Dict import pyfury class SomeClass: f1: &quot;SomeClass&quot; f2: Dict[str, str] f3: Dict[str, str] fury = pyfury.Fury(ref_tracking=True) fury.register_class(SomeClass, type_tag=&quot;example.SomeClass&quot;) obj = SomeClass() obj.f2 = {&quot;k1&quot;: &quot;v1&quot;, &quot;k2&quot;: &quot;v2&quot;} obj.f1, obj.f3 = obj, obj.f2 data = fury.serialize(obj) # bytes can be data serialized by other languages. print(fury.deserialize(data))   Golang  package main import furygo &quot;github.com/apache/incubator-fury/fury/go/fury&quot; import &quot;fmt&quot; func main() { type SomeClass struct { F1 *SomeClass F2 map[string]string F3 map[string]string } fury := furygo.NewFury(true) if err := fury.RegisterTagType(&quot;example.SomeClass&quot;, SomeClass{}); err != nil { panic(err) } value := &amp;SomeClass{F2: map[string]string{&quot;k1&quot;: &quot;v1&quot;, &quot;k2&quot;: &quot;v2&quot;}} value.F3 = value.F2 value.F1 = value bytes, err := fury.Marshal(value) if err != nil { } var newValue interface{} // bytes can be data serialized by other languages. if err := fury.Unmarshal(bytes, &amp;newValue); err != nil { panic(err) } fmt.Println(newValue) }   JavaScript  import Fury, { Type } from '@furyjs/fury'; /** * @furyjs/hps use v8's fast-calls-api that can be called directly by jit, ensure that the version of Node is 20 or above. * Experimental feature, installation success cannot be guaranteed at this moment * If you are unable to install the module, replace it with `const hps = null;` **/ import hps from '@furyjs/hps'; const description = Type.object('example.foo', { foo: Type.string(), bar: Type.object('example.foo'), }); const fury = new Fury({ hps }); const { serialize, deserialize } = fury.registerSerializer(description); const data: any = { foo: 'hello fury', }; data.bar = data; const input = serialize(data); const result = deserialize(input); console.log(result.bar.foo === result.foo);   JavaScriptReference cannot be implemented because of rust ownership restrictions  ","version":"Next","tagName":"h3"},{"title":"Zero-Copy Serialization​","type":1,"pageTitle":"Xlang Object Graph Guide","url":"/docs/guide/xlang_object_graph_guide#zero-copy-serialization","content":" Java  import org.apache.fury.*; import org.apache.fury.config.*; import org.apache.fury.serializers.BufferObject; import org.apache.fury.memory.MemoryBuffer; import java.util.*; import java.util.stream.Collectors; public class ZeroCopyExample { // mvn exec:java -Dexec.mainClass=&quot;io.ray.fury.examples.ZeroCopyExample&quot; public static void main(String[] args) { Fury fury = Fury.builder().withLanguage(Language.XLANG).build(); List&lt;Object&gt; list = ofArrayList(&quot;str&quot;, new byte[1000], new int[100], new double[100]); Collection&lt;BufferObject&gt; bufferObjects = new ArrayList&lt;&gt;(); byte[] bytes = fury.serialize(list, e -&gt; !bufferObjects.add(e)); // bytes can be data serialized by other languages. List&lt;MemoryBuffer&gt; buffers = bufferObjects.stream() .map(BufferObject::toBuffer).collect(Collectors.toList()); System.out.println(fury.deserialize(bytes, buffers)); } }   Python  import array import pyfury import numpy as np fury = pyfury.Fury() list_ = [&quot;str&quot;, bytes(bytearray(1000)), array.array(&quot;i&quot;, range(100)), np.full(100, 0.0, dtype=np.double)] serialized_objects = [] data = fury.serialize(list_, buffer_callback=serialized_objects.append) buffers = [o.to_buffer() for o in serialized_objects] # bytes can be data serialized by other languages. print(fury.deserialize(data, buffers=buffers))   Golang  package main import furygo &quot;github.com/apache/incubator-fury/fury/go/fury&quot; import &quot;fmt&quot; func main() { fury := furygo.NewFury() list := []interface{}{&quot;str&quot;, make([]byte, 1000)} buf := fury.NewByteBuffer(nil) var bufferObjects []fury.BufferObject fury.Serialize(buf, list, func(o fury.BufferObject) bool { bufferObjects = append(bufferObjects, o) return false }) var newList []interface{} var buffers []*fury.ByteBuffer for _, o := range bufferObjects { buffers = append(buffers, o.ToBuffer()) } if err := fury.Deserialize(buf, &amp;newList, buffers); err != nil { panic(err) } fmt.Println(newList) }   JavaScript  // Coming soon  ","version":"Next","tagName":"h3"},{"title":"Install","type":0,"sectionRef":"#","url":"/docs/start/install","content":"","keywords":"","version":"Next"},{"title":"Java​","type":1,"pageTitle":"Install","url":"/docs/start/install#java","content":" Nightly snapshot:  &lt;repositories&gt; &lt;repository&gt; &lt;id&gt;apache&lt;/id&gt; &lt;url&gt;https://repository.apache.org/snapshots/&lt;/url&gt; &lt;releases&gt; &lt;enabled&gt;false&lt;/enabled&gt; &lt;/releases&gt; &lt;snapshots&gt; &lt;enabled&gt;true&lt;/enabled&gt; &lt;/snapshots&gt; &lt;/repository&gt; &lt;/repositories&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.fury&lt;/groupId&gt; &lt;artifactId&gt;fury-core&lt;/artifactId&gt; &lt;version&gt;0.5.0-SNAPSHOT&lt;/version&gt; &lt;/dependency&gt; &lt;!-- row/arrow format support --&gt; &lt;!-- &lt;dependency&gt; &lt;groupId&gt;org.apache.fury&lt;/groupId&gt; &lt;artifactId&gt;fury-format&lt;/artifactId&gt; &lt;version&gt;0.5.0-SNAPSHOT&lt;/version&gt; &lt;/dependency&gt; --&gt;   Release version:  &lt;dependency&gt; &lt;groupId&gt;org.furyio&lt;/groupId&gt; &lt;artifactId&gt;fury-core&lt;/artifactId&gt; &lt;version&gt;0.4.1&lt;/version&gt; &lt;/dependency&gt; &lt;!-- row/arrow format support --&gt; &lt;!-- &lt;dependency&gt; &lt;groupId&gt;org.furyio&lt;/groupId&gt; &lt;artifactId&gt;fury-format&lt;/artifactId&gt; &lt;version&gt;0.4.1&lt;/version&gt; &lt;/dependency&gt; --&gt;   Maven groupId will be changed to org.apache.fury when next version is released.  ","version":"Next","tagName":"h3"},{"title":"Scala​","type":1,"pageTitle":"Install","url":"/docs/start/install#scala","content":" libraryDependencies += &quot;org.furyio&quot; % &quot;fury-core&quot; % &quot;0.4.1&quot;   ","version":"Next","tagName":"h3"},{"title":"Python​","type":1,"pageTitle":"Install","url":"/docs/start/install#python","content":" # Python wheel will be released in the future. # Currently you need to specify `--pre` to install # the unstable version. pip install pyfury   ","version":"Next","tagName":"h3"},{"title":"Golang​","type":1,"pageTitle":"Install","url":"/docs/start/install#golang","content":" go get github.com/apache/incubator-fury/go/fury   ","version":"Next","tagName":"h3"},{"title":"JavaScript​","type":1,"pageTitle":"Install","url":"/docs/start/install#javascript","content":" npm install @furyjs/fury   ","version":"Next","tagName":"h3"},{"title":"Rust​","type":1,"pageTitle":"Install","url":"/docs/start/install#rust","content":" # Cargo.toml [dependencies] fury = { git= &quot;https://github.com/apache/incubator-fury.git&quot;, branch = &quot;main&quot; } lazy_static = { version = &quot;1.4.0&quot; }  ","version":"Next","tagName":"h3"},{"title":"Cross-language Serialization Specification","type":0,"sectionRef":"#","url":"/docs/specification/fury_xlang_serialization_spec","content":"","keywords":"","version":"Next"},{"title":"Type Systems​","type":1,"pageTitle":"Cross-language Serialization Specification","url":"/docs/specification/fury_xlang_serialization_spec#type-systems","content":" ","version":"Next","tagName":"h2"},{"title":"Data Types​","type":1,"pageTitle":"Cross-language Serialization Specification","url":"/docs/specification/fury_xlang_serialization_spec#data-types","content":" bool: a boolean value (true or false).int8: a 8-bit signed integer.int16: a 16-bit signed integer.int32: a 32-bit signed integer.var_int32: a 32-bit signed integer which use fury var_int32 encoding.fixed_int32: a 32-bit signed integer which use two's complement encoding.int64: a 64-bit signed integer.var_int64: a 64-bit signed integer which use fury PVL encoding.sli_int64: a 64-bit signed integer which use fury SLI encoding.fixed_int64: a 64-bit signed integer which use two's complement encoding.float16: a 16-bit floating point number.float32: a 32-bit floating point number.float64: a 64-bit floating point number including NaN and Infinity.string: a text string encoded using Latin1/UTF16/UTF-8 encoding.enum: a data type consisting of a set of named values. Rust enum with non-predefined field values are not supported as an enum.list: a sequence of objects.set: an unordered set of unique elements.map: a map of key-value pairs. Mutable types such as list/map/set/array/tensor/arrow are not allowed as key of map.time types: duration: an absolute length of time, independent of any calendar/timezone, as a count of nanoseconds.timestamp: a point in time, independent of any calendar/timezone, as a count of nanoseconds. The count is relative to an epoch at UTC midnight on January 1, 1970. decimal: exact decimal value represented as an integer value in two's complement.binary: an variable-length array of bytes.array type: only allow numeric components. Other arrays will be taken as List. The implementation should support the interoperability between array and list. array: multidimensional array which every sub-array can have different sizes but all have same type.bool_array: one dimensional int16 array.int16_array: one dimensional int16 array.int32_array: one dimensional int32 array.int64_array: one dimensional int64 array.float16_array: one dimensional half_float_16 array.float32_array: one dimensional float32 array.float64_array: one dimensional float64 array. tensor: a multidimensional dense array of fixed-size values such as a NumPy ndarray.sparse tensor: a multidimensional array whose elements are almost all zeros.arrow record batch: an arrow record batch object.arrow table: an arrow table object.  Note:  Unsigned int/long are not added here, since not every language support those types.  ","version":"Next","tagName":"h3"},{"title":"Type disambiguation​","type":1,"pageTitle":"Cross-language Serialization Specification","url":"/docs/specification/fury_xlang_serialization_spec#type-disambiguation","content":" Due to differences between type systems of languages, those types can't be mapped one-to-one between languages. When deserializing, Fury use the target data structure type and the data type in the data jointly to determine how to deserialize and populate the target data structure. For example:  class Foo { int[] intArray; Object[] objects; List&lt;Object&gt; objectList; } class Foo2 { int[] intArray; List&lt;Object&gt; objects; List&lt;Object&gt; objectList; }   intArray has an int32_array type. But both objects and objectList fields in the serialize data have list data type. When deserializing, the implementation will create an Object array for objects, but create a ArrayListfor objectList to populate its elements. And the serialized data of Foo can be deserialized into Foo2 too.  Users can also provide meta hints for fields of a type, or the type whole. Here is an example in java which use annotation to provide such information.   @TypeInfo(fieldsNullable = false, trackingRef = false, polymorphic = false) class Foo { @FieldInfo(trackingRef = false) int[] intArray; @FieldInfo(polymorphic = true) Object object; @FieldInfo(tagId = 1, nullable = true) List&lt;Object&gt; objectList; }   Such information can be provided in other languages too:  cpp: use macro and template.golang: use struct tag.python: use typehint.rust: use macro.  ","version":"Next","tagName":"h3"},{"title":"Type ID​","type":1,"pageTitle":"Cross-language Serialization Specification","url":"/docs/specification/fury_xlang_serialization_spec#type-id","content":" All internal data types are expressed using an ID in range -64~-1. Users can use 0~32703 for representing their types. At runtime, all type ids are added by 64, and then encoded as an unsigned varint.  ","version":"Next","tagName":"h3"},{"title":"Type mapping​","type":1,"pageTitle":"Cross-language Serialization Specification","url":"/docs/specification/fury_xlang_serialization_spec#type-mapping","content":" See Type mapping  ","version":"Next","tagName":"h3"},{"title":"Spec overview​","type":1,"pageTitle":"Cross-language Serialization Specification","url":"/docs/specification/fury_xlang_serialization_spec#spec-overview","content":" Here is the overall format:  | fury header | object ref meta | object type meta | object value data |   The data are serialized using little endian byte order overall. If bytes swap is costly for some object, Fury will write the byte order for that object into the data instead of converting it to little endian.  ","version":"Next","tagName":"h2"},{"title":"Fury header​","type":1,"pageTitle":"Cross-language Serialization Specification","url":"/docs/specification/fury_xlang_serialization_spec#fury-header","content":" Fury header consists starts one byte:  | 2 bytes | 4 bits | 1 bit | 1 bit | 1 bit | 1 bit | optional 4 bytes | +--------------+---------------+-------+-------+--------+-------+------------------------------------+ | magic number | reserved bits | oob | xlang | endian | null | unsigned int for meta start offset |   magic number: used to identify fury serialization protocol, current version use 0x62d4.null flag: 1 when object is null, 0 otherwise. If an object is null, other bits won't be set.endian flag: 1 when data is encoded by little endian, 0 for big endian.xlang flag: 1 when serialization uses xlang format, 0 when serialization uses Fury java format.oob flag: 1 when passed BufferCallback is not null, 0 otherwise.  If meta share mode is enabled, an uncompressed unsigned int is appended to indicate the start offset of metadata.  ","version":"Next","tagName":"h2"},{"title":"Reference Meta​","type":1,"pageTitle":"Cross-language Serialization Specification","url":"/docs/specification/fury_xlang_serialization_spec#reference-meta","content":" Reference tracking handles whether the object is null, and whether to track reference for the object by writing corresponding flags and maintaining internal state.  Reference flags:  Flag\tByte Value\tDescriptionNULL FLAG\t-3\tThis flag indicates the object is a null value. We don't use another byte to indicate REF, so that we can save one byte. REF FLAG\t-2\tThis flag indicates the object is already serialized previously, and fury will write a ref id with unsigned varint format instead of serialize it again NOT_NULL VALUE FLAG\t-1\tThis flag indicates the object is a non-null value and fury doesn't track ref for this type of object. REF VALUE FLAG\t0\tThis flag indicates the object is referencable and the first time to serialize.  When reference tracking is disabled globally or for specific types, or for certain types within a particular context(e.g., a field of a type), only the NULL and NOT_NULL VALUE flags will be used for reference meta.  For languages which doesn't support reference such as rust, reference tracking must be disabled for correct deserialization by fury rust implementation.  For languages whose object values are not null by default:  In rust, Fury takes Option:None as a null valueIn c++, Fury takes std::nullopt as a null valueIn golang, Fury takes null interface/pointer as a null value  If one want to deserialize in languages like Java/Python/JavaScript, he should mark the type with all fields not-null by default, or using schema-evolution mode to carry the not-null fields info in the data.  ","version":"Next","tagName":"h2"},{"title":"Type Meta​","type":1,"pageTitle":"Cross-language Serialization Specification","url":"/docs/specification/fury_xlang_serialization_spec#type-meta","content":" For every type to be serialized, it must be registered with an optional ID first. The registered type will have a user-provided or an auto-growing unsigned int i.e. type_id. The registration can be used for security check and type identification. The id of user registered type will be added by 64 to make space for Fury internal data types.  Depending on whether meta share mode and registration is enabled for current type, Fury will write type meta differently.  ","version":"Next","tagName":"h2"},{"title":"Schema consistent​","type":1,"pageTitle":"Cross-language Serialization Specification","url":"/docs/specification/fury_xlang_serialization_spec#schema-consistent","content":" If schema consistent mode is enabled globally when creating fury, type meta will be written as a fury unsigned varint of type_id. Schema evolution related meta will be ignored.If schema evolution mode is enabled globally when creating fury, and current class is configured to use schema consistent mode like struct vs table in flatbuffers: Type meta will be add to captured_type_defs: captured_type_defs[type def stub] = map size ahead when registering type.Get index of the meta in captured_type_defs, write that index as | unsigned varint: index |.  ","version":"Next","tagName":"h3"},{"title":"Schema evolution​","type":1,"pageTitle":"Cross-language Serialization Specification","url":"/docs/specification/fury_xlang_serialization_spec#schema-evolution","content":" If schema evolution mode is enabled globally when creating fury, and enabled for current type, type meta will be written using one of the following mode. Which mode to use is configured when creating fury.  Normal mode(meta share not enabled): If type meta hasn't been written before, add type defto captured_type_defs: captured_type_defs[type def] = map size.Get index of the meta in captured_type_defs, write that index as | unsigned varint: index |.After finished the serialization of the object graph, fury will start to write captured_type_defs: Firstly, set current to meta start offset of fury headerThen write captured_type_defs one by one: buffer.write_var_uint32(len(writting_type_defs) - len(schema_consistent_type_def_stubs)) for type_meta in writting_type_defs: if not type_meta.is_stub(): type_meta.write_type_def(buffer) writing_type_defs = copy(schema_consistent_type_def_stubs) Meta share mode: the writing steps are same as the normal mode, but captured_type_defs will be shared across multiple serializations of different objects. For example, suppose we have a batch to serialize: captured_type_defs = {} stream = ... # add `Type1` to `captured_type_defs` and write `Type1` fury.serialize(stream, [Type1()]) # add `Type2` to `captured_type_defs` and write `Type2`, `Type1` is written before. fury.serialize(stream, [Type1(), Type2()]) # `Type1` and `Type2` are written before, no need to write meta. fury.serialize(stream, [Type1(), Type2()]) Streaming mode(streaming mode doesn't support meta share): If type meta hasn't been written before, the data will be written as: | unsigned varint: 0b11111111 | type def | If type meta has been written before, the data will be written as: | unsigned varint: written index &lt;&lt; 1 | written index is the id in captured_type_defs.With this mode, meta start offset can be omitted.  The normal mode and meta share mode will forbid streaming writing since it needs to look back for update the start offset after the whole object graph writing and meta collecting is finished. Only in this way we can ensure deserialization failure in meta share mode doesn't lost shared meta.  Type Def​  Here we mainly describe the meta layout for schema evolution mode:  | 8 bytes meta header | variable bytes | variable bytes | variable bytes | +-------------------------------+--------------------+-------------------+----------------+ | 7 bytes hash + 1 bytes header | current type meta | parent type meta | ... |   Type meta are encoded from parent type to leaf type, only type with serializable fields will be encoded.  Meta header​  Meta header is a 64 bits number value encoded in little endian order.  Lowest 4 digits 0b0000~0b1110 are used to record num classes. 0b1111 is preserved to indicate that Fury need to read more bytes for length using Fury unsigned int encoding. If current type doesn't has parent type, or parent type doesn't have fields to serialize, or we're in a context which serialize fields of current type only, num classes will be 1.The 5th bit is used to indicate whether this type needs schema evolution.Other 56 bits are used to store the unique hash of flags + all layers type meta.  Single layer type meta​  | unsigned varint | var uint | field info: variable bytes | variable bytes | ... | +-----------------+----------+-------------------------------+-----------------+-----+ | num_fields | type id | header + type id + field name | next field info | ... |   num fields: encode num fields as unsigned varint. If the current type is schema consistent, then num_fields will be 0 to flag it.If the current type isn't schema consistent, then num_fields will be the number of compatible fields. For example, users can use tag id to mark some fields as compatible fields in schema consistent context. In such cases, schema consistent fields will be serialized first, then compatible fields will be serialized next. At deserialization, Fury will use fields info of those fields which aren't annotated by tag id for deserializing schema consistent fields, then use fields info in meta for deserializing compatible fields. type id: the registered id for the current type, which will be written as an unsigned varint.field info: Header(8 bits): Format: reserved 1 bit + 3 bits field name encoding + polymorphism flag + nullability flag + ref tracking flag + tag id flag. Users can use annotation to provide that info. tag id: when set to 1, the field name will be written by an unsigned varint tag id.ref tracking: when set to 0, ref tracking will be disabled for this field.nullability: when set to 0, this field won't be null.polymorphism: when set to 1, the actual type of field will be the declared field type even the type if not final.3 bits field name encoding will be set to meta string encoding flags when tag id is not set. Type id: For registered type-consistent classes, it will be the registered type id.Otherwise it will be encoded as OBJECT_ID if it isn't final and FINAL_OBJECT_ID if it's final. The meta for such types is written separately instead of inlining here is to reduce meta space cost if object of this type is serialized in the current object graph multiple times, and the field value may be null too. List Type Info: this type will have an extra byte for elements info. Users can use annotation to provide that info. elements type sameelements tracking refelements nullabilityelements declared type Map Type Info: this type will have an extra byte for kv items info. Users can use annotation to provide that info. keys type samekeys tracking refkeys nullabilitykeys declared typevalues type samevalues tracking refvalues nullabilityvalues declared type Field name: If tag id is set, tag id will be used instead. Otherwise meta string encoding length and data will be written instead.  Field order are left as implementation details, which is not exposed to specification, the deserialization need to resort fields based on Fury field comparator. In this way, fury can compute statistics for field names or types and using a more compact encoding.  Other layers type meta​  Same encoding algorithm as the previous layer.  ","version":"Next","tagName":"h3"},{"title":"Meta String​","type":1,"pageTitle":"Cross-language Serialization Specification","url":"/docs/specification/fury_xlang_serialization_spec#meta-string","content":" Meta string is mainly used to encode meta strings such as field names.  ","version":"Next","tagName":"h2"},{"title":"Encoding Algorithms​","type":1,"pageTitle":"Cross-language Serialization Specification","url":"/docs/specification/fury_xlang_serialization_spec#encoding-algorithms","content":" String binary encoding algorithm:  Algorithm\tPattern\tDescriptionLOWER_SPECIAL\ta-z._$|\tevery char is written using 5 bits, a-z: 0b00000~0b11001, ._$|: 0b11010~0b11101 LOWER_UPPER_DIGIT_SPECIAL\ta-zA-Z0~9._$\tevery char is written using 6 bits, a-z: 0b00000~0b11110, A-Z: 0b11010~0b110011, 0~9: 0b110100~0b111101, ._$: 0b111110~0b1000000 UTF-8\tany chars\tUTF-8 encoding  Encoding flags:  Encoding Flag\tPattern\tEncoding AlgorithmLOWER_SPECIAL\tevery char is in a-z._$|\tLOWER_SPECIAL REP_FIRST_LOWER_SPECIAL\tevery char is in a-z._$ except first char is upper case\treplace first upper case char to lower case, then use LOWER_SPECIAL REP_MUL_LOWER_SPECIAL\tevery char is in a-zA-Z._$\treplace every upper case char by | + lower case, then use LOWER_SPECIAL, use this encoding if it's smaller than Encoding 3 LOWER_UPPER_DIGIT_SPECIAL\tevery char is in a-zA-Z._$\tuse LOWER_UPPER_DIGIT_SPECIAL encoding if it's smaller than Encoding 2 UTF8\tany utf-8 char\tuse UTF-8 encoding Compression\tany utf-8 char\tlossless compression  Depending on cases, one can choose encoding flags + data jointly, uses 3 bits of first byte for flags and other bytes for data.  ","version":"Next","tagName":"h3"},{"title":"Value Format​","type":1,"pageTitle":"Cross-language Serialization Specification","url":"/docs/specification/fury_xlang_serialization_spec#value-format","content":" ","version":"Next","tagName":"h2"},{"title":"Basic types​","type":1,"pageTitle":"Cross-language Serialization Specification","url":"/docs/specification/fury_xlang_serialization_spec#basic-types","content":" bool​  size: 1 byteformat: 0 for false, 1 for true  int8​  size: 1 byteformat: write as pure byte.  int16​  size: 2 bytebyte order: raw bytes of little endian order  unsigned int32​  size: 4 bytebyte order: raw bytes of little endian order  unsigned varint32​  size: 1~5 byteFormat: The most significant bit (MSB) in every byte indicates whether to have the next byte. If first bit is set i.e. b &amp; 0x80 == 0x80, then the next byte should be read until the first bit of the next byte is unset.  signed int32​  size: 4 bytebyte order: raw bytes of little endian order  signed varint32​  size: 1~5 byteFormat: First convert the number into positive unsigned int by (v &lt;&lt; 1) ^ (v &gt;&gt; 31) ZigZag algorithm, then encode it as an unsigned varint.  unsigned int64​  size: 8 bytebyte order: raw bytes of little endian order  unsigned varint64​  size: 1~9 byteFury SLI(Small long as int) Encoding: If long is in [0, 2147483647], encode as 4 bytes int: | little-endian: ((int) value) &lt;&lt; 1 |Otherwise write as 9 bytes: | 0b1 | little-endian 8 bytes long | Fury PVL(Progressive Variable-length Long) Encoding: positive long format: first bit in every byte indicates whether to have the next byte. If first bit is set i.e. b &amp; 0x80 == 0x80, then the next byte should be read until the first bit is unset.  signed int64​  size: 8 bytebyte order: raw bytes of little endian order  signed varint64​  size: 1~9 byteFury SLI(Small long as int) Encoding: If long is in [-1073741824, 1073741823], encode as 4 bytes int: | little-endian: ((int) value) &lt;&lt; 1 |Otherwise write as 9 bytes: | 0b1 | little-endian 8 bytes long | Fury PVL(Progressive Variable-length Long) Encoding: First convert the number into positive unsigned long by (v &lt;&lt; 1) ^ (v &gt;&gt; 63) ZigZag algorithm to reduce cost of small negative numbers, then encoding it as an unsigned long.  float32​  size: 4 byteformat: encode the specified floating-point value according to the IEEE 754 floating-point &quot;single format&quot; bit layout, preserving Not-a-Number (NaN) values, then write as binary by little endian order.  float64​  size: 8 byteformat: encode the specified floating-point value according to the IEEE 754 floating-point &quot;double format&quot; bit layout, preserving Not-a-Number (NaN) values. then write as binary by little endian order.  ","version":"Next","tagName":"h3"},{"title":"string​","type":1,"pageTitle":"Cross-language Serialization Specification","url":"/docs/specification/fury_xlang_serialization_spec#string","content":" Format:  | unsigned varint64: size &lt;&lt; 2 `bitor` 2 bits encoding flags | binary data |   size + encoding will be concat as a long and encoded as an unsigned varint64. The little 2 bits is used for encoding: 0 for latin1(ISO-8859-1), 1 for utf-16, 2 for utf-8.encoded string binary data based on encoding: latin/utf-16/utf-8.  Which encoding to choose:  For JDK8: fury detect latin at runtime, if string is latin string, then use latin encoding, otherwise use utf-16.For JDK9+: fury use coder in String object for encoding, latin/utf-16 will be used for encoding.If the string is encoded by utf-8, then fury will use utf-8 to decode the data. Cross-language string serialization of fury uses utf-8 by default.  ","version":"Next","tagName":"h3"},{"title":"list​","type":1,"pageTitle":"Cross-language Serialization Specification","url":"/docs/specification/fury_xlang_serialization_spec#list","content":" Format:  | unsigned varint64: length &lt;&lt; 4 `bitor` 4 bits elements header | elements data |   elements header​  In most cases, all elements are same type and not null, elements header will encode those homogeneous information to avoid the cost of writing it for every element. Specifically, there are four kinds of information which will be encoded by elements header, each use one bit:  If track elements ref, use the first bit 0b1 of the header to flag it.If the elements have null, use the second bit 0b10 of the header to flag it. If ref tracking is enabled for this element type, this flag is invalid.If the element types are not the declared type, use the 3rd bit 0b100 of the header to flag it.If the element types are different, use the 4rd bit 0b1000 header to flag it.  By default, all bits are unset, which means all elements won't track ref, all elements are same type, not null and the actual element is the declared type in the custom type field.  elements data​  Based on the elements header, the serialization of elements data may skip ref flag/null flag/element type info.  fury = ... buffer = ... elems = ... if element_type_is_same: if not is_declared_type: fury.write_type(buffer, elem_type) elem_serializer = get_serializer(...) if track_ref: for elem in elems: if not ref_resolver.write_ref_or_null(buffer, elem): elem_serializer.write(buffer, elem) elif has_null: for elem in elems: if elem is None: buffer.write_byte(null_flag) else: buffer.write_byte(not_null_flag) elem_serializer.write(buffer, elem) else: for elem in elems: elem_serializer.write(buffer, elem) else: if track_ref: for elem in elems: fury.write_ref(buffer, elem) elif has_null: for elem in elems: fury.write_nullable(buffer, elem) else: for elem in elems: fury.write_value(buffer, elem)   CollectionSerializer#writeElementscan be taken as an example.  ","version":"Next","tagName":"h3"},{"title":"array​","type":1,"pageTitle":"Cross-language Serialization Specification","url":"/docs/specification/fury_xlang_serialization_spec#array","content":" primitive array​  Primitive array are taken as a binary buffer, serialization will just write the length of array size as an unsigned int, then copy the whole buffer into the stream.  Such serialization won't compress the array. If users want to compress primitive array, users need to register custom serializers for such types or mark it as list type.  object array​  Object array is serialized using the list format. Object component type will be taken as list element generic type.  ","version":"Next","tagName":"h3"},{"title":"map​","type":1,"pageTitle":"Cross-language Serialization Specification","url":"/docs/specification/fury_xlang_serialization_spec#map","content":" All Map serializers must extend AbstractMapSerializer.  Format:  | length(unsigned varint) | key value chunk data | ... | key value chunk data |   map key-value chunk data​  Map iteration is too expensive, Fury won't compute the header like for list since it introduceconsiderable overhead. Users can use MapFieldInfo annotation to provide the header in advance. Otherwise Fury will use first key-value pair to predict header optimistically, and update the chunk header if the prediction failed at some pair.  Fury will serialize the map chunk by chunk, every chunk has 127 pairs at most.  | 1 byte | 1 byte | variable bytes | +----------------+----------------+-----------------+ | chunk size: N | KV header | N*2 objects |   KV header:  If track key ref, use the first bit 0b1 of the header to flag it.If the key has null, use the second bit 0b10 of the header to flag it. If ref tracking is enabled for this key type, this flag is invalid.If the key types of map are different, use the 3rd bit 0b100 of the header to flag it.If the actual key type of the map is not the declared key type, use the 4rd bit 0b1000 of the header to flag it.If track value ref, use the 5th bit 0b10000 of the header to flag it.If the value has null, use the 6th bit 0b100000 of the header to flag it. If ref tracking is enabled for this value type, this flag is invalid.If the value types of the map are different, use the 7rd bit 0b1000000 header to flag it.If the value type of map is not the declared value type, use the 8rd bit 0b10000000 of the header to flag it.  If streaming write is enabled, which means Fury can't update written chunk size. In such cases, map key-value data format will be:  | 1 byte | variable bytes | +----------------+-----------------+ | KV header | N*2 objects |   KV header will be a header marked by MapFieldInfo in java. For languages such as golang, this can be computed in advance for non-interface types most times.  ","version":"Next","tagName":"h3"},{"title":"enum​","type":1,"pageTitle":"Cross-language Serialization Specification","url":"/docs/specification/fury_xlang_serialization_spec#enum","content":" Enums are serialized as an unsigned var int. If the order of enum values change, the deserialized enum value may not be the value users expect. In such cases, users must register enum serializer by make it write enum value as an enumerated string with unique hash disabled.  ","version":"Next","tagName":"h3"},{"title":"decimal​","type":1,"pageTitle":"Cross-language Serialization Specification","url":"/docs/specification/fury_xlang_serialization_spec#decimal","content":" Not supported for now.  ","version":"Next","tagName":"h3"},{"title":"struct​","type":1,"pageTitle":"Cross-language Serialization Specification","url":"/docs/specification/fury_xlang_serialization_spec#struct","content":" Struct means object of class/pojo/struct/bean/record type. Struct will be serialized by writing its fields data in fury order.  Depending on schema compatibility, structs will have different formats.  field order​  Field will be ordered as following, every group of fields will have its own order:  primitive fields: larger size type first, smaller later, variable size type last.boxed primitive fields: same order as primitive fieldsfinal fields: same type together, then sorted by field name lexicographically.list fields: same order as final fieldsmap fields: same order as final fieldsother fields: same order as final fields  schema consistent​  Object will be written as:  | 4 byte | variable bytes | +---------------+------------------+ | type hash | field values |   Type hash is used to check the type schema consistency across languages. Type hash will be the first 32 bits of 56 bits value of the type meta.  Object fields will be serialized one by one using following format:  not null primitive field value: | var bytes | +----------------+ | value data | +----------------+ nullable primitive field value: | one byte | var bytes | +-----------+---------------+ | null flag | field value | +-----------+---------------+ field value of final type with ref tracking: | var bytes | var objects | +-----------+-------------+ | ref meta | value data | +-----------+-------------+ field value of final type without ref tracking: | one byte | var objects | +-----------+-------------+ | null flag | field value | +-----------+-------------+ field value of non-final type with ref tracking: | one byte | var bytes | var objects | +-----------+-------------+-------------+ | ref meta | type meta | value data | +-----------+-------------+-------------+ field value of non-final type without ref tracking: | one byte | var bytes | var objects | +-----------+------------+------------+ | null flag | type meta | value data | +-----------+------------+------------+   Schema evolution​  Schema evolution have similar format as schema consistent mode for object except:  For the object type, schema consistent mode will write type by id only, but schema evolution mode will write type consisting of field names, types and other meta too, see Type meta.Type meta of final custom type needs to be written too, because peers may not have this type defined.  ","version":"Next","tagName":"h3"},{"title":"Type​","type":1,"pageTitle":"Cross-language Serialization Specification","url":"/docs/specification/fury_xlang_serialization_spec#type","content":" Type will be serialized using type meta format.  ","version":"Next","tagName":"h3"},{"title":"Implementation guidelines​","type":1,"pageTitle":"Cross-language Serialization Specification","url":"/docs/specification/fury_xlang_serialization_spec#implementation-guidelines","content":" ","version":"Next","tagName":"h2"},{"title":"How to reduce memory read/write code​","type":1,"pageTitle":"Cross-language Serialization Specification","url":"/docs/specification/fury_xlang_serialization_spec#how-to-reduce-memory-readwrite-code","content":" Try to merge multiple bytes into an int/long write before writing to reduce memory IO and bound check cost.Read multiple bytes as an int/long, then split into multiple bytes to reduce memory IO and bound check cost.Try to use one varint/long to write flags and length together to save one byte cost and reduce memory io.Condition branches are less expensive compared to memory IO cost unless there are too many branches.  ","version":"Next","tagName":"h3"},{"title":"Fast deserialization for static languages without runtime codegen support​","type":1,"pageTitle":"Cross-language Serialization Specification","url":"/docs/specification/fury_xlang_serialization_spec#fast-deserialization-for-static-languages-without-runtime-codegen-support","content":" For type evolution, the serializer will encode the type meta into the serialized data. The deserializer will compare this meta with class meta in the current process, and use the diff to determine how to deserialize the data.  For java/javascript/python, we can use the diff to generate serializer code at runtime and load it as class/function for deserialization. In this way, the type evolution will be as fast as type consist mode.  For C++/Rust, we can't generate the serializer code at runtime. So we need to generate the code at compile-time using meta programming. But at that time, we don't know the type schema in other processes, so we can't generate the serializer code for such inconsistent types. We may need to generate the code which has a loop and compare field name one by one to decide whether to deserialize and assign the field or skip the field value.  One fast way is that we can optimize the string comparison into jump instructions:  Assume the current type has n fields, and the peer type has n1 fields.Generate an auto growing field id from 0 for every sorted field in the current type at the compile time.Compare the received type meta with current type, generate same id if the field name is same, otherwise generate an auto growing id starting from n, cache this meta at runtime.Iterate the fields of received type meta, use a switch to compare the field id to deserialize data and assign/skip field value. Continuous field id will be optimized into jump in switch block, so it will very fast.  Here is an example, suppose process A has a class Foo with version 1 defined as Foo1, process B has a class Foowith version 2 defined as Foo2:  // class Foo with version 1 class Foo1 { int32_t v1; // id 0 std::string v2; // id 1 }; // class Foo with version 2 class Foo2 { // id 0, but will have id 2 in process A bool v0; // id 1, but will have id 0 in process A int32_t v1; // id 2, but will have id 3 in process A int64_t long_value; // id 3, but will have id 1 in process A std::string v2; // id 4, but will have id 4 in process A std::vector&lt;std::string&gt; list; };   When process A received serialized Foo2 from process B, here is how it deserialize the data:  Foo1 foo1 = ...; const std::vector&lt;fury::FieldInfo&gt; &amp;field_infos = type_meta.field_infos; for (const auto &amp;field_info : field_infos) { switch (field_info.field_id) { case 0: foo1.v1 = buffer.read_varint32(); break; case 1: foo1.v2 = fury.read_string(); break; default: fury.skip_data(field_info); } }  ","version":"Next","tagName":"h3"},{"title":"Usage","type":0,"sectionRef":"#","url":"/docs/start/usage","content":"","keywords":"","version":"Next"},{"title":"Java Serialization​","type":1,"pageTitle":"Usage","url":"/docs/start/usage#java-serialization","content":" import java.util.List; import java.util.Arrays; import io.fury.*; public class Example { public static void main(String[] args) { SomeClass object = new SomeClass(); // Note that Fury instances should be reused between // multiple serializations of different objects. Fury fury = Fury.builder().withLanguage(Language.JAVA) // Allow to deserialize objects unknown types, // more flexible but less secure. // .withSecureMode(false) .build(); // Registering types can reduce class name serialization overhead, but not mandatory. // If secure mode enabled, all custom types must be registered. fury.register(SomeClass.class); byte[] bytes = fury.serialize(object); System.out.println(fury.deserialize(bytes)); } }   ","version":"Next","tagName":"h2"},{"title":"CrossLanguage Serialization​","type":1,"pageTitle":"Usage","url":"/docs/start/usage#crosslanguage-serialization","content":" ","version":"Next","tagName":"h2"},{"title":"Java​","type":1,"pageTitle":"Usage","url":"/docs/start/usage#java","content":" import com.google.common.collect.ImmutableMap; import io.fury.*; import java.util.Map; public class ReferenceExample { public static class SomeClass { SomeClass f1; Map&lt;String, String&gt; f2; Map&lt;String, String&gt; f3; } public static Object createObject() { SomeClass obj = new SomeClass(); obj.f1 = obj; obj.f2 = ImmutableMap.of(&quot;k1&quot;, &quot;v1&quot;, &quot;k2&quot;, &quot;v2&quot;); obj.f3 = obj.f2; return obj; } // mvn exec:java -Dexec.mainClass=&quot;io.fury.examples.ReferenceExample&quot; public static void main(String[] args) { Fury fury = Fury.builder().withLanguage(Language.XLANG) .withRefTracking(true).build(); fury.register(SomeClass.class, &quot;example.SomeClass&quot;); byte[] bytes = fury.serialize(createObject()); // bytes can be data serialized by other languages. System.out.println(fury.deserialize(bytes)); ; } }   ","version":"Next","tagName":"h3"},{"title":"Python​","type":1,"pageTitle":"Usage","url":"/docs/start/usage#python","content":" from typing import Dict import pyfury class SomeClass: f1: &quot;SomeClass&quot; f2: Dict[str, str] f3: Dict[str, str] fury = pyfury.Fury(ref_tracking=True) fury.register_class(SomeClass, &quot;example.SomeClass&quot;) obj = SomeClass() obj.f2 = {&quot;k1&quot;: &quot;v1&quot;, &quot;k2&quot;: &quot;v2&quot;} obj.f1, obj.f3 = obj, obj.f2 data = fury.serialize(obj) # bytes can be data serialized by other languages. print(fury.deserialize(data))   ","version":"Next","tagName":"h3"},{"title":"Golang​","type":1,"pageTitle":"Usage","url":"/docs/start/usage#golang","content":" package main import furygo &quot;https://github.com/apache/incubator-fury/go/fury&quot; import &quot;fmt&quot; func main() { type SomeClass struct { F1 *SomeClass F2 map[string]string F3 map[string]string } fury := furygo.NewFury(true) if err := fury.RegisterTagType(&quot;example.SomeClass&quot;, SomeClass{}); err != nil { panic(err) } value := &amp;SomeClass{F2: map[string]string{&quot;k1&quot;: &quot;v1&quot;, &quot;k2&quot;: &quot;v2&quot;}} value.F3 = value.F2 value.F1 = value bytes, err := fury.Marshal(value) if err != nil { } var newValue interface{} // bytes can be data serialized by other languages. if err := fury.Unmarshal(bytes, &amp;newValue); err != nil { panic(err) } fmt.Println(newValue) }   ","version":"Next","tagName":"h3"},{"title":"JavaScript​","type":1,"pageTitle":"Usage","url":"/docs/start/usage#javascript","content":" import Fury, { Type } from '@furyjs/fury'; /** * @furyjs/hps use v8's fast-calls-api that can be called directly by jit, ensure that the version of Node is 20 or above. * Experimental feature, installation success cannot be guaranteed at this moment * If you are unable to install the module, replace it with `const hps = null;` **/ import hps from '@furyjs/hps'; // Now we describe data structures using JSON, but in the future, we will use more ways. const description = Type.object('example.foo', { foo: Type.string(), }); const fury = new Fury({ hps }); const { serialize, deserialize } = fury.registerSerializer(description); const input = serialize({ foo: 'hello fury' }); const result = deserialize(input); console.log(result);   ","version":"Next","tagName":"h3"},{"title":"Rust​","type":1,"pageTitle":"Usage","url":"/docs/start/usage#rust","content":" use fury::{from_buffer, to_buffer, Fury}; #[derive(Fury, Debug, PartialEq)] #[tag(&quot;example.foo&quot;)] struct Animal { name: String, category: String, } #[derive(Fury, Debug, PartialEq)] #[tag(&quot;example.bar&quot;)] struct Person { name: String, age: u32, pets: Vec&lt;Animal&gt;, } fn main() { let penson = Person { name: &quot;hello&quot;.to_string(), age: 12, pets: vec![ Animal { name: &quot;world1&quot;.to_string(), category: &quot;cat&quot;.to_string(), }, Animal { name: &quot;world2&quot;.to_string(), category: &quot;dog&quot;.to_string(), }, ], }; let bin = to_buffer(&amp;penson); let obj: Person = from_buffer(&amp;bin).expect(&quot;should success&quot;); assert_eq!(obj, penson); }  ","version":"Next","tagName":"h3"}],"options":{"id":"default"}}